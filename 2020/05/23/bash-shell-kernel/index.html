<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Bash-Shell-Kernel, HTML, PWN, PowerShell, Web, Python, Linux">
    <meta name="description" content="热爱生活，注重过程">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Bash-Shell-Kernel | kylin小小鱼</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">
	<script src="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script>
    <script src="/libs/jquery/jquery.min.js"></script>
	
    
<style type="text/css" lang="css">
    #loading-container{
        position: fixed;
        top: 0;
        left: 0;
        min-height: 100vh;
        width: 100vw;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: #FFF;
        text-align: center;
        /* loader页面消失采用渐隐的方式*/
        -webkit-transition: opacity 1s ease;
        -moz-transition: opacity 1s ease;
        -o-transition: opacity 1s ease;
        transition: opacity 1s ease;
    }
    .loading-image{
        width: 120px;
        height: 50px;
        transform: translate(-50%);
    }

    .loading-image div:nth-child(2) {
        -webkit-animation: pacman-balls 1s linear 0s infinite;
        animation: pacman-balls 1s linear 0s infinite
    }

    .loading-image div:nth-child(3) {
        -webkit-animation: pacman-balls 1s linear .33s infinite;
        animation: pacman-balls 1s linear .33s infinite
    }

    .loading-image div:nth-child(4) {
        -webkit-animation: pacman-balls 1s linear .66s infinite;
        animation: pacman-balls 1s linear .66s infinite
    }

    .loading-image div:nth-child(5) {
        -webkit-animation: pacman-balls 1s linear .99s infinite;
        animation: pacman-balls 1s linear .99s infinite
    }

   .loading-image div:first-of-type {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_up .5s 0s infinite;
        animation: rotate_pacman_half_up .5s 0s infinite;
    }
    .loading-image div:nth-child(2) {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_down .5s 0s infinite;
        animation: rotate_pacman_half_down .5s 0s infinite;
        margin-top: -50px;
    }
    @-webkit-keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @-webkit-keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @-webkit-keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}

    @keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}


    .loading-image div:nth-child(3),
    .loading-image div:nth-child(4),
    .loading-image div:nth-child(5),
    .loading-image div:nth-child(6){
        background-color: #49b1f5;
        width: 15px;
        height: 15px;
        border-radius: 100%;
        margin: 2px;
        width: 10px;
        height: 10px;
        position: absolute;
        transform: translateY(-6.25px);
        top: 25px;
        left: 100px;
    }
    .loading-text{
        margin-bottom: 20vh;
        text-align: center;
        color: #2c3e50;
        font-size: 2rem;
        box-sizing: border-box;
        padding: 0 10px;
        text-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    @media only screen and (max-width: 500px) {
         .loading-text{
            font-size: 1.5rem;
         }
    }
    .fadeout {
        opacity: 0;
        filter: alpha(opacity=0);
    }
    /* logo出现动画 */
    @-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}100%{opacity:1;-webkit-transform:none;transform:none}}
    @keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);}}
 </style>
 <script>
(function () {
    const loaded = function(){
       setTimeout(function(){
            const loader = document.getElementById("loading-container");
            loader.className="fadeout" ;//使用渐隐的方法淡出loading page
            // document.getElementById("body-wrap").style.display="flex";
            setTimeout(function(){
                loader.style.display="none";
            },1000); 
        },1000);//强制显示loading page 1s  
    };
    loaded();
})()
 </script><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><style type="text/css" lang="css">
    #loading-container{
        position: fixed;
        top: 0;
        left: 0;
        min-height: 100vh;
        width: 100vw;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: #FFF;
        text-align: center;
        /* loader页面消失采用渐隐的方式*/
        -webkit-transition: opacity 1s ease;
        -moz-transition: opacity 1s ease;
        -o-transition: opacity 1s ease;
        transition: opacity 1s ease;
    }
    .loading-image{
        width: 120px;
        height: 50px;
        transform: translate(-50%);
    }

    .loading-image div:nth-child(2) {
        -webkit-animation: pacman-balls 1s linear 0s infinite;
        animation: pacman-balls 1s linear 0s infinite
    }

    .loading-image div:nth-child(3) {
        -webkit-animation: pacman-balls 1s linear .33s infinite;
        animation: pacman-balls 1s linear .33s infinite
    }

    .loading-image div:nth-child(4) {
        -webkit-animation: pacman-balls 1s linear .66s infinite;
        animation: pacman-balls 1s linear .66s infinite
    }

    .loading-image div:nth-child(5) {
        -webkit-animation: pacman-balls 1s linear .99s infinite;
        animation: pacman-balls 1s linear .99s infinite
    }

   .loading-image div:first-of-type {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_up .5s 0s infinite;
        animation: rotate_pacman_half_up .5s 0s infinite;
    }
    .loading-image div:nth-child(2) {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_down .5s 0s infinite;
        animation: rotate_pacman_half_down .5s 0s infinite;
        margin-top: -50px;
    }
    @-webkit-keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @-webkit-keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @-webkit-keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}

    @keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}


    .loading-image div:nth-child(3),
    .loading-image div:nth-child(4),
    .loading-image div:nth-child(5),
    .loading-image div:nth-child(6){
        background-color: #49b1f5;
        width: 15px;
        height: 15px;
        border-radius: 100%;
        margin: 2px;
        width: 10px;
        height: 10px;
        position: absolute;
        transform: translateY(-6.25px);
        top: 25px;
        left: 100px;
    }
    .loading-text{
        margin-bottom: 20vh;
        text-align: center;
        color: #2c3e50;
        font-size: 2rem;
        box-sizing: border-box;
        padding: 0 10px;
        text-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    @media only screen and (max-width: 500px) {
         .loading-text{
            font-size: 1.5rem;
         }
    }
    .fadeout {
        opacity: 0;
        filter: alpha(opacity=0);
    }
    /* logo出现动画 */
    @-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}100%{opacity:1;-webkit-transform:none;transform:none}}
    @keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);}}
 </style>
 <script>
(function () {
    const loaded = function(){
       setTimeout(function(){
            const loader = document.getElementById("loading-container");
            loader.className="fadeout" ;//使用渐隐的方法淡出loading page
            // document.getElementById("body-wrap").style.display="flex";
            setTimeout(function(){
                loader.style.display="none";
            },1000); 
        },1000);//强制显示loading page 1s  
    };
    loaded();
})()
 </script></head>



 <div id="loading-container">
     <p class="loading-text">玩命加载中 . . . </p> 
     <div class="loading-image">
         <div></div>
         <div></div>
         <div></div>
         <div></div> 
         <div></div>
     </div>
 </div><body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">kylin小小鱼</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">kylin小小鱼</div>
        <div class="logo-desc">
            
            热爱生活，注重过程
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/5.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Bash-Shell-Kernel</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Linux/">
                                <span class="chip bg-color">Linux</span>
                            </a>
                        
                            <a href="/tags/Bash-Shell/">
                                <span class="chip bg-color">Bash-Shell</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Linux/" class="post-category">
                                Linux
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-05-23
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2020-05-23
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    14.8k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    58 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>

        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h3 id="Bash-–-Shell"><a href="#Bash-–-Shell" class="headerlink" title="Bash – Shell"></a>Bash – Shell</h3><h4 id="1-Bash-解释器"><a href="#1-Bash-解释器" class="headerlink" title="1. Bash 解释器"></a>1. Bash 解释器</h4><h5 id="1-1-一个命令的生命"><a href="#1-1-一个命令的生命" class="headerlink" title="1.1 一个命令的生命"></a>1.1 一个命令的生命</h5><ol>
<li>读取命令行</li>
<li>bash解析命令行：引号、命令替换、重定向、创建管道等 （对应于 1.2.1）</li>
<li>启动进程：fork()子bash进程</li>
<li>exec 加载程序替换fork出来的子bash进程（搜索命令路径）</li>
<li>命令开始执行：<ol>
<li>解析命令选项、参数（对应于1.2.2）</li>
<li>执行主代码逻辑</li>
<li>退出：退出状态码</li>
</ol>
</li>
<li>bash接收状态码，为命令子进程收尸</li>
</ol>
<h5 id="1-2-注意"><a href="#1-2-注意" class="headerlink" title="1.2 注意"></a>1.2 注意</h5><ol>
<li>shell需要解析的部分：特殊符号（<code>&#39;&#39; 、 &quot;&quot;  、$()、 &gt; 、 &lt; 、 |</code>）</li>
<li>命令自身需要解析的部分：选项、参数、特殊符号</li>
<li>特殊符号有可能会出现冲突，如果这个特殊符号，想要被shell解析，则不应该使用双引号、单引号包围，也不能使用反斜线转义。如果这些特殊符号想要被程序自身解析，则必须得使用引号包围，或者反斜线转义。</li>
</ol>
<pre class=" language-shell"><code class="language-shell">//例： ls  *  与  grep  “a.*”
//ls  中的*代表 通配符，用来匹配文件
//grep中的*代表正则表达式中的 * 的含义
//所以grep中的*需要使用引号包裹起来,防止被shell的解析</code></pre>
<h5 id="1-3-解释器解释语句"><a href="#1-3-解释器解释语句" class="headerlink" title="1.3 解释器解释语句"></a>1.3 解释器解释语句</h5><p>解释型语言：Python 、Shell 、Perl、AWK</p>
<p>解释特点：</p>
<ul>
<li>读一句  解释一句  忘记一句</li>
<li>读一段  解释一段（函数、代码段） 忘记一段</li>
<li>先定义再调用</li>
</ul>
<h5 id="1-4-shell与bash的关系"><a href="#1-4-shell与bash的关系" class="headerlink" title="1.4 shell与bash的关系"></a>1.4 shell与bash的关系</h5><ol>
<li>shell是一门语言，bash只是其中一种</li>
<li>shell是一种解释器，bash只是其中一种</li>
<li>sh指向某种shell</li>
<li>除了bash之外还有csh、dash、ksh、powershell、cmd等</li>
</ol>
<h4 id="2-bash交互式、登录式"><a href="#2-bash交互式、登录式" class="headerlink" title="2. bash交互式、登录式"></a>2. bash交互式、登录式</h4><p>交互式与登录式不对立，交互式对立的是非交互式</p>
<h5 id="2-1-什么时候会启动bash："><a href="#2-1-什么时候会启动bash：" class="headerlink" title="2.1 什么时候会启动bash："></a>2.1 什么时候会启动bash：</h5><ol>
<li>登录系统时</li>
<li>执行命令时（内置命令除外）</li>
</ol>
<h5 id="2-2-bash配置文件"><a href="#2-2-bash配置文件" class="headerlink" title="2.2 bash配置文件"></a>2.2 bash配置文件</h5><ol>
<li><strong>/etc/profile</strong>（全局）</li>
<li>~/.bash_profile</li>
<li>~/.bashrc</li>
<li>/etc/bashrc</li>
<li><strong>/etc/profile.d/*.sh</strong>（全局）</li>
</ol>
<h5 id="2-3-判断交互式、登录式："><a href="#2-3-判断交互式、登录式：" class="headerlink" title="2.3 判断交互式、登录式："></a>2.3 判断交互式、登录式：</h5><ol>
<li><p>交互式：</p>
<ol>
<li><code>echo $-</code>：结果返回包含了字母 <code>i</code>，则为交互式  </li>
<li><code>echo $PS1</code>：结果返回 非空值，则为交互式，空值则为非交互式</li>
</ol>
</li>
<li><p>登录式：</p>
<p><code>shopt login_shell</code>：返回 on 则为登录式shell，返回 off 则为非登录式</p>
</li>
</ol>
<h5 id="2-4-常见的bash启动方式："><a href="#2-4-常见的bash启动方式：" class="headerlink" title="2.4 常见的bash启动方式："></a>2.4 常见的bash启动方式：</h5><ol>
<li><p>正常登录（ssh登录、虚拟终端）：交互式 &amp;&amp; 登录式</p>
</li>
<li><p><code>su</code> ：交互式  &amp;&amp; 非登录式；</p>
<p><code>su --login</code>（<code>su -</code>）：交互式 &amp;&amp; 登录式</p>
</li>
<li><p><code>bash</code> 命令（创建子bash）：交互式 &amp;&amp; 非登录式</p>
<p><code>bash --login</code> ：交互式 &amp;&amp;  登录式</p>
</li>
<li><p>ssh执行远程命令（不登录）：非交互 &amp;&amp; 非登录</p>
</li>
<li><p>shell脚本：非交互 &amp;&amp; 非登录</p>
<p>如果sh中加了<code>--login</code> ：非交互 &amp;&amp;  登录式</p>
</li>
<li><p>图形终端：（默认是）交互式 &amp;&amp; 非登录式，但是可以更改为登录式</p>
</li>
</ol>
<h5 id="2-5-bash如何读取配置文件：（不同的启动方式，读取的配置文件不同）"><a href="#2-5-bash如何读取配置文件：（不同的启动方式，读取的配置文件不同）" class="headerlink" title="2.5 bash如何读取配置文件：（不同的启动方式，读取的配置文件不同）"></a>2.5 bash如何读取配置文件：（不同的启动方式，读取的配置文件不同）</h5><ol>
<li><p>登录式（无论是否交互）：终端登录、带有–login的su、bash和shell脚本：<strong>读取全部文件</strong></p>
</li>
<li><p>交互式 &amp;&amp; 非登录式 ：仅读取 ~/.bashrc 、/etc/bashrc 、/etc/profile.d/*.sh</p>
</li>
<li><p>非交互 &amp;&amp; 非登录式 ：不带 –login 的脚本、（远程 shell 方式除外）：<strong>什么文件都不读取</strong></p>
</li>
<li><p>远程shell的非交互非登录：读取：~/.bashrc、 /etc/bashrc 、 /etc/profile.d/*.sh（这个会把结果定向到空）</p>
</li>
</ol>
<img src="https://gitee.com/lingying177/blogimage/raw/master/img/Bash-Shell/登录式-交互式.png" style="zoom:50%;" />

<img src="https://gitee.com/lingying177/blogimage/raw/master/img/Bash-Shell/交互式--非登录式.png" style="zoom:50%;" />

<h5 id="2-6-定义一个命令别名"><a href="#2-6-定义一个命令别名" class="headerlink" title="2.6 定义一个命令别名"></a>2.6 定义一个命令别名</h5><p>如果要定义一个命令别名，那应该定义到哪个配置文件中？</p>
<ol>
<li>如果是全局的（任何用户都可以使用），则应该定义到  /etc/profile  或  /etc/profile.d下的sh文件，若要定义在sh文件中，那么可以考虑创建一个alish.sh</li>
<li>如果是某个用户可用的，则建议 定义在 用户家目录下的 ~/.bash_profile和 ~/.bashrc文件中，不建议定义在 /etc/bashrc 中</li>
</ol>
<h4 id="3-进程基础"><a href="#3-进程基础" class="headerlink" title="3. 进程基础"></a>3. 进程基础</h4><p>若想深究进程，建议阅读<strong>系统编程</strong>的书籍</p>
<h5 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h5><ol>
<li>fork() 创建一个子进程，请求内核创建（内核将其信息保存在内核的进程表中）</li>
<li>子进程拷贝父进程几乎所有东西（写时复制），但共享（只读）正文段（指令）</li>
<li>fork后，将有两个进程分支，一个分支是子进程分支，另一个分支是原有的父进程分支</li>
<li>两个pid：一次调用两个返回值<ol>
<li>对子进程来说，fork()的返回值为0</li>
<li>对父进程来说，fork()的返回值为子进程的pid（进程的属性，用来标识唯一的每一个进程）</li>
</ol>
</li>
<li>在创建子进程之后，父子进程的调度是没有顺序保证的</li>
<li>子shell（子bash）与普通子进程的区别：<ol>
<li>子shell是一个子进程</li>
<li>子bash在启动时会加载配置文件完成bash环境的配置</li>
<li>shell是一个交互式的解释器进程，它可以继续创建交互式解释器进程</li>
</ol>
</li>
</ol>
<h5 id="3-2-伪代码演示说明"><a href="#3-2-伪代码演示说明" class="headerlink" title="3.2 伪代码演示说明"></a>3.2 伪代码演示说明</h5><p>伪代码：（不可执行）</p>
<pre class=" language-shell"><code class="language-shell"># she11创建子进程伪代码

#创建子进程
#现在有两个进程分支:新子进程和原有的父进程
pid=`fork`

#一次调用两个返回值
#对于父进程来说，pid变量的值为新建子进程的pid（进程的属性）
#对于子进程来说，pid变量的值为0

# 目标
# 子进程执行子进程代码
# 父进程执行父进程代码
# 显然，这个代码 没有这个效果

# pid = 0的表示子进程分支
if [[ $pid -eq 0 ]]; then
    #子进程
    echo "I'm Child Process"
fi
    #父进程/子进程都会执行
echo "I'm Parent Process"
</code></pre>
<img src="https://gitee.com/lingying177/blogimage/raw/master/img/Bash-Shell/进程.png" style="zoom:50%;" />

<pre class=" language-shell"><code class="language-shell">#上一个代码的修改版（可实现目标）
# shell 创建子进程伪代码

#创建子进程
#现在有两个进程分支:新的子进程和原有的父进程
pid=`fork`

# pid = 0的表示子进程分支
if [[ $pid -eq 0I]];then
    #子进程
    echo "I'm child Process"
else 
    #父进程
    echo "I'm Parent Process"
fi
</code></pre>
<p> shell中的内置命令exec</p>
<ol>
<li>加载指定命令替换当前shell，执行完后退出进程</li>
<li>设置重定向操作，使之生效于当前shell</li>
</ol>
<h5 id="3-3-僵尸进程"><a href="#3-3-僵尸进程" class="headerlink" title="3.3 僵尸进程"></a>3.3 僵尸进程</h5><ul>
<li>为子进程收尸（reap）：wait()/waitpid()</li>
<li>孤儿进程：对shell来说，能成为孤儿的进程将脱离终端</li>
</ul>
<p>僵尸进程：</p>
<p>(概括：子进程消失了，父进程没有对子进程进行处理(收尸)，就会出现僵尸进程)。</p>
<p>每个子进程在退出时，操作系统都会保留它们的退出状态信息（包括退出想状态码和其他一些信息），并在内核维护的进程表中保留子进程项（内核还会在子进程退出的时候发送SIGCHLD信号给父进程）。对于进程的退出状态信息，只有在父进程读走之后或者收走(reap)之后才会被清除。<strong>退出状态信息没有被父进程读走的子进程将成为僵尸进程</strong>。</p>
<p>任何子进程，在退出的那一刻，都属于僵尸进程。一瞬间也是。</p>
<p>wait()/waitpid() 处理子进程退出状态信息后，子进程才从僵尸进程完全退出。</p>
<p>如果没有通过wait()/waitpid() 处理子进程退出状态信息，那么子进程将永远成为僵尸进程，除非父进程也退出了。（pid=1的init/systemd。会定期为僵尸进程收尸）</p>
<p>shell伪代码模拟僵尸进程：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建子进程</span>
<span class="token comment" spellcheck="true"># 现在有两个进程分支:新的子进程和原有的父进程</span>
pid<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span>fork<span class="token variable">`</span></span>
<span class="token comment" spellcheck="true"># pid = 0的表示子进程分支</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$pid</span> -eq 0 <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>
    <span class="token comment" spellcheck="true">#子进程</span>
    <span class="token keyword">echo</span> "I'm Child Process
    <span class="token keyword">exit</span>
<span class="token keyword">fi</span>
<span class="token comment" spellcheck="true">#父进程</span>
<span class="token function">sleep</span> 2
<span class="token function">ps</span> -o pid, ppid, state, <span class="token function">command</span>
</code></pre>
<p>对于编程语言来说，可以使用wait()/waitpid()来收尸，他们会处理子进程的退出状态信息</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># shell伪代码</span>
<span class="token comment" spellcheck="true"># 创建子进程</span>
<span class="token comment" spellcheck="true"># 现在有两个进程分支:新的子进程和原有的父进程</span>
pid<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span>fork<span class="token variable">`</span></span>
<span class="token comment" spellcheck="true"># pid = 0的表示子进程分支</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$pid</span> -eq 0 <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>
    <span class="token comment" spellcheck="true">#子进程</span>
    <span class="token function">sleep</span> 1
    <span class="token function">exec</span> <span class="token string">'echo "'</span>m Child Process<span class="token string">"'
fi
#父进程
echo "</span>I'm Parent Process<span class="token string">"
wait
echo "</span>Chile exited or terminated"
</code></pre>
<p>对于shell来说，无需我们手动收尸，因为在shell下执行的所有命令都是shell的子进程，shell会帮我们做好收尸工作。但是对于脱离shell的或脱离终端的进程(比如daemon类进程、nohup打开的进程)， 它们会挂在pid=1的init/systemd进程下，这些脱离shell或脱离终端的进程的子进程可能会成为永久的僵尸进程（除非它们的父进程死了，就会被系统处理）。</p>
<h5 id="3-4-孤儿进程"><a href="#3-4-孤儿进程" class="headerlink" title="3.4 孤儿进程"></a>3.4 孤儿进程</h5><p>父进程死了，子进程还在：子进程成为孤儿进程， 会挂靠到pid=1的init/systemd进程下。</p>
<p>shell伪代码模拟孤儿进程：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># she11伪代码</span>
<span class="token comment" spellcheck="true">#创建子进程</span>
<span class="token comment" spellcheck="true">#现在有两个进程分支:新的子进程和原有的父进程</span>
pid<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span>fork<span class="token variable">`</span></span>
<span class="token comment" spellcheck="true"># pid = 0的表示子进程分支</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$pid</span> -eq 0 <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span> 
    <span class="token comment" spellcheck="true">#子进程</span>
    <span class="token keyword">echo</span> <span class="token string">"I'm Child Process'
    sleep 5
    echo "</span>I<span class="token string">'m orphan Process"
fi
#父进程
echo "I'</span>m Parent Process"
<span class="token function">sleep</span> 1
</code></pre>
<p>shell 中直接产生孤儿进程：在子shell 中执行后台命令 <code>(sleep 30 &amp;)</code>(注意带括号)</p>
<h4 id="4-管道"><a href="#4-管道" class="headerlink" title="4. 管道"></a>4. 管道</h4><h5 id="4-1-匿名-管道特性"><a href="#4-1-匿名-管道特性" class="headerlink" title="4.1 (匿名)管道特性"></a>4.1 (匿名)管道特性</h5><ol>
<li><p>进程间通信（FIFO）：数据一边进一边出（左写右读，左进右出）</p>
</li>
<li><p>管道是最先创建出来的，然后才fork管道两边的进程<img src="https://gitee.com/lingying177/blogimage/raw/master/img/Bash-Shell/管道.png" style="zoom:50%;" /></p>
</li>
<li><p>管道左右两边进程没有先后顺序：<code>ps aux | grep ‘ps aux’</code>测试</p>
</li>
<li><p>开启一个进程组（<code>ps -o ppid,pid,pgid,tpgid,sid,cmd/ps j</code>）</p>
</li>
<li><p>数据传递是实时读、写的</p>
</li>
<li><p>管道是一个字节流</p>
<ol>
<li>有序性</li>
<li>读写任意字节大小的数据块</li>
</ol>
</li>
<li><p>数据写端在管道buffer满时阻塞</p>
<p>数据读端在管道buffer空时阻塞</p>
<ol>
<li>pipe buffermore字节为65536 字节（64k）</li>
<li>测试：<code>dd if=/dev/zero bs=1 | sleep 3 &amp; sleep 1 &amp;&amp; pkill -INT -x dd</code></li>
</ol>
</li>
</ol>
<h5 id="4-2-管道实例"><a href="#4-2-管道实例" class="headerlink" title="4.2 管道实例"></a>4.2 管道实例</h5><ol>
<li><p><strong>陷阱</strong>（作用域）： <code>echo &quot;hello&quot; | while read line;do i=$line;done</code></p>
<ol>
<li>while是bash可以认识的语句，其他的不认识</li>
<li>上面命令，管道右边的while语句，是在当前shell进程下，创建了一个新的子shell进程。（只要使用管道，就会创建子进程）</li>
<li>子shell进程的变量不会影响父shell进程。所以变量 i 只在子shell进程中有效</li>
<li><strong><em>如果此时再执行  echo $i  ，则输出结果为空</em></strong>。</li>
</ol>
</li>
<li><p>管道buffer 示例：</p>
<ol>
<li>终端1执行：<code>while true;do echo $RANDOM &gt;&gt; /tmp/a.log;sleep 1 ;done</code></li>
<li>终端2执行：<code>tail -f /tmp/a.log | grep &quot;[0-9]&quot;</code></li>
<li>终端2第二次执行：<code>tail -f /tmp/a.log | grep &quot;[0-9]&quot; | grep &quot;[0-9]&quot;</code></li>
<li>第3步无效果，那就试第四步：<code>tail -f /tmp/a.log | stdbuf -oL  grep &quot;[0-9]&quot; | grep &quot;[0-9]&quot;</code></li>
<li>解决第三步的其他方法，就是将输出定向到标准错误，此时就是直接将数据按照行缓冲模式输出到 io buffer：<code>tail -f /tmp/a.log | grep &quot;[0-9]&quot; &gt;&amp;2 | grep &quot;[0-9]&quot;</code></li>
</ol>
</li>
</ol>
<h5 id="4-3-IO-buffer-的缓冲类型"><a href="#4-3-IO-buffer-的缓冲类型" class="headerlink" title="4.3 IO buffer 的缓冲类型"></a>4.3 IO buffer 的缓冲类型</h5><ol>
<li>行缓冲（line buffer）：<ul>
<li>io buffer，当进程向io buffer中写入了一个<strong>换行符</strong>的时候，将直接刷出io buffer中的数据</li>
<li>当<strong>进程的输出连接至交互式终端</strong>时，使用<strong>行缓冲模式</strong></li>
</ul>
</li>
<li>块缓冲（block buffer/full buffer）：<ul>
<li>进程产生的数据先积累在io buffer中，只有积累满io buffer后，才将io buffer中的数据刷出去</li>
<li><strong>默认使用块缓冲模式</strong></li>
<li>写向文件系统文件、写向管道、写向套接字</li>
</ul>
</li>
<li>无缓冲（unbuffer）：<ul>
<li>不使用io buffer，只要进程产生数据，就立即输出。</li>
<li>（stderr）：错误直接输出（标准错误输出 &amp;2）</li>
</ul>
</li>
</ol>
<h5 id="4-4-IO-buffer的层次"><a href="#4-4-IO-buffer的层次" class="headerlink" title="4.4 IO buffer的层次"></a>4.4 IO buffer的层次</h5><p>注意：文件描述符是用户空间层维护的内容，不是内核维护的，因为文件描述符仅仅是一些整数变量，不需要交给内核维护。</p>
<p><strong>对 4.2 管道示例中 终端2 第一次执行的解析：</strong></p>
<img src="https://gitee.com/lingying177/blogimage/raw/master/img/Bash-Shell/io-buffer.png" style="zoom:60%;" />

<p><strong>对 4.2 管道示例中 终端2 第二次执行的解析：</strong></p>
<img src="https://gitee.com/lingying177/blogimage/raw/master/img/Bash-Shell/io-buffer1.png" style="zoom:60%;" />

<p><strong>对 4.2 管道示例中 终端2 第三次执行的解析：</strong></p>
<img src="https://gitee.com/lingying177/blogimage/raw/master/img/Bash-Shell/io-buffer2.png" style="zoom:60%;" />

<p>注意：stdbuf是创建了一个进程，-oL参数是使io buffer按照行缓冲模式处理。它上面的grep是它的子进程，共享数据，所以可以完成工作（都是缓冲模式搞的鬼。。。）</p>
<h5 id="4-5-IO-buffer-与-kernel-buffer-的层次"><a href="#4-5-IO-buffer-与-kernel-buffer-的层次" class="headerlink" title="4.5 IO buffer 与 kernel buffer 的层次"></a>4.5 IO buffer 与 kernel buffer 的层次</h5><img src="https://gitee.com/lingying177/blogimage/raw/master/img/Bash-Shell/IO-Buffer.svg" style="zoom: 50%;" />

<h5 id="4-6-命名管道的特性和用法"><a href="#4-6-命名管道的特性和用法" class="headerlink" title="4.6 命名管道的特性和用法"></a>4.6 命名管道的特性和用法</h5><p>创建：<code>mkfifo</code>    </p>
<ol>
<li><p>有名称的管道，所以具有一部分匿名管道的特性</p>
</li>
<li><p>数据传输在内存中进行，所以完全没有磁盘 IO 的消耗，高效</p>
</li>
<li><p>能够协调任何进程间的通信，这是普通<code>|</code>所不具备的</p>
</li>
<li><p>任何进程(命令)都能向命名管道写入数据，同样，任何进程都能从命名管道中读取数据</p>
</li>
<li><p>命名管道的阻塞性：只有读写双方都打开了命名管道，才能读、写数据，否则读、写操作被阻塞</p>
</li>
<li><p>完全实现 “协程” coproc的功能</p>
</li>
<li><p>实现进程池的作用</p>
</li>
<li><p>还具有很多妙用，特别是结合tee、重定向以及 后台进程 的时候，用法更灵活</p>
</li>
<li><p>….</p>
</li>
<li><p>当你通过普通文件、匿名管道无法实现自己的需求的时候，请考虑使用命名管道，不会让你失望</p>
<p>但是，<strong>shell下绝大多数的操作都有更直观、更简便的方式来实现，所以理性使用命名管道。</strong></p>
</li>
</ol>
<h6 id="4-6-1-命名管道用法入门"><a href="#4-6-1-命名管道用法入门" class="headerlink" title="4.6.1  命名管道用法入门"></a>4.6.1  命名管道用法入门</h6><pre class=" language-bash"><code class="language-bash">mkinfo  /tmp/a.fifo    //创建

<span class="token comment" spellcheck="true">## 终端1 </span>
<span class="token keyword">echo</span> <span class="token string">"hello world"</span> <span class="token operator">></span> /tmp/a.fifo   <span class="token comment" spellcheck="true">## 因读取未打开，写被阻塞</span>

<span class="token comment" spellcheck="true">## 终端2</span>
<span class="token function">cat</span> /tmp/a.fifo              <span class="token comment" spellcheck="true">## 此时 管道的读取打开，刚才的写就会解除阻塞</span>

<span class="token comment" spellcheck="true">## 终端1</span>
<span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">do</span>
    <span class="token function">date</span> +<span class="token string">"%T"</span> <span class="token operator">></span> /tmp/a.fifo
    <span class="token function">sleep</span> 1
<span class="token keyword">done</span>

<span class="token comment" spellcheck="true">## 终端2</span>
<span class="token keyword">while</span> <span class="token function">read</span> line <span class="token operator">&lt;</span> /tmp/a.fifo<span class="token punctuation">;</span><span class="token keyword">do</span>         <span class="token comment" spellcheck="true">## 有多少读多少</span>
    <span class="token keyword">echo</span> <span class="token variable">$line</span>
<span class="token keyword">done</span>
<span class="token comment" spellcheck="true"># while read line;do echo $line;done &lt; /tmp/a.fifo  只读一行</span></code></pre>
<p>对于while的一个注意点：<strong>当需要读取源源不断的数据时，不要将数据源放在while结构的后面，而是放在读取命令（如 read）后。</strong></p>
<p>对于重定向操作的一个注意点：<strong>重定向操作是在命令行解析的阶段（fork子bash之前）进行的，如果重定向行为被阻塞（比如这里的命名管道），那么将一直不会创建进程。</strong></p>
<h6 id="4-6-2-双命名管道的妙用"><a href="#4-6-2-双命名管道的妙用" class="headerlink" title="4.6.2  双命名管道的妙用"></a>4.6.2  双命名管道的妙用</h6><p>双命名管道可以实现<code>cmd1 | cmd2 | cmd3</code> 的功能，虽然要复杂些，但是更灵活</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">mkfifo</span> /tmp/in.fifo  /tmp/out.fifo

<span class="token function">grep</span> <span class="token string">"a"</span> <span class="token operator">&lt;</span>/tmp/in.fifo  <span class="token operator">></span>/tmp/out.fifo <span class="token operator">&amp;</span>

<span class="token keyword">echo</span> <span class="token string">"abcde"</span>  <span class="token operator">></span>/tmp/in.fifo

<span class="token function">cat</span> /tmp/out.fifo

<span class="token function">rm</span> -rf /tmp/<span class="token punctuation">{</span>in,out<span class="token punctuation">}</span>.fifo</code></pre>
<pre class=" language-bash"><code class="language-bash"><span class="token function">mkfifo</span> /tmp/<span class="token punctuation">{</span>in,out<span class="token punctuation">}</span>.fifo

<span class="token comment" spellcheck="true"># 筛选处理 cmd2进程</span>
<span class="token keyword">while</span> <span class="token function">grep</span> <span class="token string">':'</span> <span class="token operator">&lt;</span>/tmp/in.fifo  <span class="token operator">></span>/tmp/out.fifo<span class="token punctuation">;</span> <span class="token keyword">do</span>
    <span class="token keyword">:</span>
<span class="token keyword">done</span>
<span class="token comment" spellcheck="true"># 上面的:代表空语句</span>
<span class="token comment" spellcheck="true"># 写</span>
<span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">do</span>
    <span class="token function">date</span> +<span class="token string">"%T"</span> <span class="token operator">></span>/tmp/in.fifo
    <span class="token function">sleep</span> 1
<span class="token keyword">done</span>

<span class="token comment" spellcheck="true"># 读</span>
<span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">do</span>
    <span class="token function">cat</span> /tmp/out.fifo
<span class="token keyword">done</span>

<span class="token function">rm</span> -rf /tmp/<span class="token punctuation">{</span>in,out<span class="token punctuation">}</span>.fifo</code></pre>
<h6 id="4-6-3-避免临时文件导致的多余IO"><a href="#4-6-3-避免临时文件导致的多余IO" class="headerlink" title="4.6.3 避免临时文件导致的多余IO"></a>4.6.3 避免临时文件导致的多余IO</h6><p>经典的示例是 MySQL 导入 <code>.gz</code>文件</p>
<p>下面直接通过匿名管道导入导出数据，避免了磁盘IO，直接使用内存，更高效</p>
<pre class=" language-bash"><code class="language-bash">    <span class="token comment" spellcheck="true"># export：</span>
mysqldump  -uXXX -pOOO db_name <span class="token operator">|</span> <span class="token function">gzip</span> <span class="token operator">></span> data.gz

    <span class="token comment" spellcheck="true"># import：</span>
<span class="token function">gzip</span> -d <span class="token operator">&lt;</span>data.gz <span class="token operator">|</span> mysql -uXXX -pOOO db_name
    <span class="token comment" spellcheck="true">##但是，如果使用load data  infile呢？</span>

<span class="token function">mkfifo</span>  /tmp/data.sql.fifo
<span class="token function">gzip</span> -d <span class="token operator">&lt;</span>data.gz <span class="token operator">></span>/tmp/data.sql.fifo <span class="token operator">&amp;</span>
mysql -uXXX -pOOO -e <span class="token string">"load data infile '/tmp/data.sql.fifo' into table table_name"</span> db_name</code></pre>
<h6 id="4-6-4-共享终端会话"><a href="#4-6-4-共享终端会话" class="headerlink" title="4.6.4 共享终端会话"></a>4.6.4 共享终端会话</h6><pre class=" language-bash"><code class="language-bash"><span class="token function">mkfifo</span>  /tmp/share.fifo

    <span class="token comment" spellcheck="true"># 终端1：分享端</span>
script -f /tmp/share.fifo

    <span class="token comment" spellcheck="true"># 终端2：接收端</span>
<span class="token function">cat</span>  /tmp/share.fifo

<span class="token keyword">exit</span> 退出</code></pre>
<h6 id="4-6-5-不知道叫什么功能的功能"><a href="#4-6-5-不知道叫什么功能的功能" class="headerlink" title="4.6.5 不知道叫什么功能的功能"></a>4.6.5 不知道叫什么功能的功能</h6><pre class=" language-bash"><code class="language-bash">f<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">mkfifo</span> p<span class="token punctuation">{</span>i,o<span class="token punctuation">}</span><span class="token punctuation">{</span>1,2,3<span class="token punctuation">}</span>
    <span class="token function">tr</span> a b <span class="token operator">&lt;</span>pi1 <span class="token operator">></span>po1 <span class="token operator">&amp;</span>
    <span class="token function">sed</span> <span class="token string">'s/./&amp;&amp;/g'</span> <span class="token operator">&lt;</span>pi2 <span class="token operator">></span>po2 <span class="token operator">&amp;</span>
    <span class="token function">cut</span> -c2- <span class="token operator">&lt;</span>pi3 <span class="token operator">></span>po3 <span class="token operator">&amp;</span>

    <span class="token function">tee</span> pi<span class="token punctuation">{</span>1,2<span class="token punctuation">}</span> <span class="token operator">></span> pi3 <span class="token operator">&amp;</span>
    <span class="token function">cat</span> po<span class="token punctuation">{</span>1,2,3<span class="token punctuation">}</span>
    <span class="token function">rm</span> -rf p<span class="token punctuation">{</span>i,o<span class="token punctuation">}</span><span class="token punctuation">{</span>1,2,3<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">printf</span> <span class="token string">'%s \n'</span> foo bar <span class="token operator">|</span> f</code></pre>
<img src="https://gitee.com/lingying177/blogimage/raw/master/img/Bash-Shell/tee.png" style="zoom:50%;" />

<h6 id="4-6-6-结合nc工具做代理功能"><a href="#4-6-6-结合nc工具做代理功能" class="headerlink" title="4.6.6 结合nc工具做代理功能"></a>4.6.6 结合nc工具做代理功能</h6><p>参考： <a href="https://en.wikipedia.org/wiki/Netcat" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Netcat</a> </p>
<pre class=" language-bash"><code class="language-bash">nc -l 12345 <span class="token operator">|</span> nc www.baidu.com 80</code></pre>
<pre class=" language-bash"><code class="language-bash"><span class="token function">mkfifo</span> backpipe
<span class="token function">mv</span> -l 12345 <span class="token operator">&lt;</span>backpipe <span class="token operator">|</span> nc www.baidu.com 80 <span class="token operator">></span>backpipe</code></pre>
<h4 id="5-shell-内置结构的陷阱"><a href="#5-shell-内置结构的陷阱" class="headerlink" title="5. shell 内置结构的陷阱"></a>5. shell 内置结构的陷阱</h4><p><strong>注意：！！！！！ 内置结构自身是属于bash的，当内置结构想要运行起来，需要有专门一个bash进程取负责执行，为他们提供运行环境。</strong></p>
<h5 id="5-1-while-使用管道后的变量作用域"><a href="#5-1-while-使用管道后的变量作用域" class="headerlink" title="5.1 while 使用管道后的变量作用域"></a>5.1 while 使用管道后的变量作用域</h5><p>部分讲解看  <strong>4.2 管道实例</strong>  陷阱。</p>
<h5 id="5-2-重定向操作是谁的？（复合命令）"><a href="#5-2-重定向操作是谁的？（复合命令）" class="headerlink" title="5.2 重定向操作是谁的？（复合命令）"></a>5.2 重定向操作是谁的？（复合命令）</h5><ol>
<li>输入：输入重定向放在整个while的后面  &amp;&amp;  输入重定向放在 read 后面</li>
</ol>
<pre class=" language-bash"><code class="language-bash"><span class="token keyword">while</span> <span class="token function">read</span> line<span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token keyword">echo</span> <span class="token variable">$line</span><span class="token punctuation">;</span> <span class="token keyword">done</span>  <span class="token operator">&lt;</span>/tmp/a.log
    <span class="token comment" spellcheck="true">## 输出结果：输出一部分就结束了，中途会停止，并不会一直等待着数据</span>
<span class="token keyword">while</span> <span class="token function">read</span> line <span class="token operator">&lt;</span>/tmp/a.log<span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token keyword">echo</span> <span class="token variable">$line</span><span class="token punctuation">;</span> <span class="token keyword">done</span>
    <span class="token comment" spellcheck="true">## 输出结果：一直会输出（按照我们想要的效果），不会中途停止</span></code></pre>
<ol start="2">
<li>输出：</li>
</ol>
<pre class=" language-bash"><code class="language-bash"><span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token function">date</span> +<span class="token string">"%T"</span><span class="token punctuation">;</span> <span class="token function">sleep</span> 1<span class="token punctuation">;</span> <span class="token keyword">done</span> <span class="token operator">></span>/tmp/x.log
    <span class="token comment" spellcheck="true">## 输出结果：</span>
    <span class="token comment" spellcheck="true">#    数据会有很多，因为在整个while的后面，重定向不在循环里，所以只打开了一次文件，后面的事情就是一直向里面写数据。没有再次打开，没有被再次清空。结果显示多条数据。</span>

<span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token function">date</span> +<span class="token string">"%T"</span> <span class="token operator">></span>/tmp/x.log<span class="token punctuation">;</span><span class="token function">sleep</span> 1<span class="token punctuation">;</span> <span class="token keyword">done</span>
    <span class="token comment" spellcheck="true">## 输出结果：</span>
    <span class="token comment" spellcheck="true">#    只会有一行，因为放在了循环里，所以每次都会重新打开文件，以覆盖的方式打开文件时，一瞬间，文件的内容就被清空了，然后写一次数据，再打开（清空），再写。所以只会有一条数据。</span>
</code></pre>
<p><strong>原因解释：放在bash内置结构后面的重定向，只打开一次文件</strong>（重定向没有放在循环里），覆盖/追加是在打开（open）文件的时候决定并进行的，那一刻决定了的文件的数据要不要清除。</p>
<h5 id="5-3-谁放入后台？"><a href="#5-3-谁放入后台？" class="headerlink" title="5.3 谁放入后台？"></a>5.3 谁放入后台？</h5><pre class=" language-bash"><code class="language-bash"><span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token function">sleep</span> 100<span class="token punctuation">;</span><span class="token keyword">done</span> <span class="token operator">&amp;</span>
<span class="token comment" spellcheck="true"># 将整个while放入后台，因为整个while放入了后台，所以while不能使用当前bash进程，因此创建了一个临时的新子bash进程，当把当前bash杀掉时，新子bash进程会成为孤儿进程独自挂载在pid=init/system（1）上，进程不停止，使用pstree -p | grep sleep 查看pid，再使用kill -9 pid杀掉。</span>
<span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token function">sleep</span> 100 <span class="token operator">&amp;</span> <span class="token function">sleep</span> 1<span class="token punctuation">;</span><span class="token keyword">done</span>
<span class="token comment" spellcheck="true">## 每秒产生一个sleep后台进程，将当前bash杀掉后，创建的sleep进程都会直接挂载到pid=init/system（1）下，并没有产生任何新子bash进程，注意与上面的将整个while放入后台区分。</span>
<span class="token punctuation">(</span>sleep 30 <span class="token operator">&amp;</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># 使用括号，也会创建一个子进程来运行当前命令，只是括号结束时，子进程会被瞬间杀掉，但sleep不会被杀掉，所以sleep成为孤儿进程。结果与第二个类似</span>
</code></pre>
<img src="https://gitee.com/lingying177/blogimage/raw/master/img/Bash-Shell/while-子进程.png" style="zoom: 67%;" />

<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#           |-bash(3847)---sleep(3893)  #第一个将整个while放入后台后杀掉的结果</span>
<span class="token comment" spellcheck="true">#           |-sleep(3894)  ## 第二个分别放入后台并杀掉的结果</span>
<span class="token comment" spellcheck="true">#           |-sleep(3896)  ## 第二种的孤儿进程最后会被系统杀掉，</span>
<span class="token comment" spellcheck="true">#           |-sleep(3898)  ## 但是第一种创建了子bash的进程不会被系统杀掉</span>
<span class="token comment" spellcheck="true">#           |-sleep(3900)</span>
<span class="token comment" spellcheck="true">#           |-sleep(3902)</span>
<span class="token comment" spellcheck="true">#           |-sleep(3904)</span>
<span class="token comment" spellcheck="true">#           |-sleep(3906)</span>
<span class="token comment" spellcheck="true">#           |-sleep(3908)</span></code></pre>
<p><strong>原因解释：当后台命令运行在 子shell  中时，子shell退出，后台命令就成为了孤儿进程，而且会脱离终端，就像nohup功能。</strong></p>
<p><strong>特别的是，如果后台命令是for/while的话，那么将不断的循环，不会退出（即第一种while不会被系统杀掉）</strong></p>
<p><strong>注意第一个整个while放入后台的解释，与第二个分别放入后台的解释。</strong></p>
<p>解决方法：<code>killall bash / killall -9 bash</code></p>
<h4 id="6-命令替换、进程替换、后台进程"><a href="#6-命令替换、进程替换、后台进程" class="headerlink" title="6 命令替换、进程替换、后台进程"></a>6 命令替换、进程替换、后台进程</h4><h5 id="6-1-命令替换"><a href="#6-1-命令替换" class="headerlink" title="6.1 命令替换"></a>6.1 命令替换</h5><p>将一个命令运行，把产生的数据插入到命令行当中的某个地方。</p>
<ol>
<li><strong>$(cmd)</strong>  ：但命令替换中包含了特殊符号时，建议使用这个括号的形式</li>
<li>反引号 <strong>``</strong></li>
<li>命令替换，默认会将产生的换行符压缩成空格，可以使用双引号还原。</li>
<li>命令替换是先执行的</li>
</ol>
<pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token keyword">echo</span> haha<span class="token variable">`</span></span>
<span class="token punctuation">$(</span>echo <span class="token string">"haha"</span><span class="token punctuation">)</span>
<span class="token keyword">echo</span> `echo <span class="token string">"\a"</span><span class="token variable"><span class="token variable">`</span>
<span class="token keyword">echo</span> <span class="token variable">`</span></span><span class="token keyword">echo</span> <span class="token string">"\\a"</span><span class="token variable"><span class="token variable">`</span>
<span class="token keyword">echo</span> <span class="token variable">`</span></span><span class="token keyword">echo</span> <span class="token string">"\\\a"</span><span class="token variable"><span class="token variable">`</span>
<span class="token keyword">echo</span> <span class="token variable">`</span></span><span class="token keyword">echo</span> <span class="token string">"\\\\a"</span>`
<span class="token keyword">echo</span> <span class="token punctuation">$(</span>echo <span class="token string">"\a"</span><span class="token punctuation">)</span>
<span class="token keyword">echo</span> <span class="token punctuation">$(</span>echo <span class="token string">"\\a"</span><span class="token punctuation">)</span>
<span class="token keyword">echo</span> <span class="token punctuation">$(</span>echo <span class="token string">"\\\a"</span><span class="token punctuation">)</span>
<span class="token keyword">echo</span> <span class="token punctuation">$(</span>echo <span class="token string">"\\\\a"</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">## 两种方式对于转义反斜线的替换不同，建议使用$()这一个。于平时对反斜线的理解一样。</span>
<span class="token keyword">echo</span> `echo -e <span class="token string">"a\nb"</span>`  <span class="token comment" spellcheck="true">## 换行符压缩成空格</span>
<span class="token keyword">echo</span> <span class="token string">"`echo -e "</span>a\nb<span class="token string">"`"</span>  <span class="token comment" spellcheck="true">## 再套一层双引号进行还原，就不会被压缩成空格了</span></code></pre>
<h5 id="6-2-后台进程-amp"><a href="#6-2-后台进程-amp" class="headerlink" title="6.2 后台进程  &amp;"></a>6.2 后台进程  &amp;</h5><p>多进程异步执行 &amp;</p>
<h5 id="6-3-进程替换"><a href="#6-3-进程替换" class="headerlink" title="6.3  进程替换"></a>6.3  进程替换</h5><ol>
<li>进程替换是<strong>通过虚拟文件</strong>来进行数据交互的，不是直接插入到某个地方。</li>
<li>进程替换也是先执行的，也是 <strong>多进程异步执行</strong>。</li>
<li>&gt;(cmd) 是输入进程替换，&lt;(cmd) 是输出进程替换</li>
</ol>
<p><code>&gt;(cmd) &lt;(cmd)</code>：使用<strong>输出重定向符号</strong>的其实是<strong>输入进程替换</strong>，使用<strong>输入重定向符号</strong>的其实是<strong>输出进程替换</strong>。<strong><em>重定向符号加上括号才是进程替换，不然就只是重定向</em></strong></p>
<p>（别人产生的数据输出给我们，从我们角度看就是输入数据，所以输出重定向符号是输入进程替换，看方向，指向我们，所以是输入给我们；</p>
<p>我们产生的数方向给别人，从我们角度看就是输出数据，所以输入重定向符号是输出进程替换，看方向，指向别人，所以是输出）注意：<strong>符号都放在命令左侧</strong>再加括号</p>
<pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">"abcde"</span> <span class="token operator">|</span> <span class="token function">tee</span> <span class="token operator">></span><span class="token punctuation">(</span>grep <span class="token string">"a"</span><span class="token punctuation">)</span> <span class="token operator">></span>/dev/null <span class="token operator">|</span> <span class="token function">cat</span> -
<span class="token comment" spellcheck="true"># 这一句同时实现了 cmd1 | cmd2 &amp; | cmd3 协程的功能：grep等价于cmd2 &amp;</span>
<span class="token keyword">echo</span> <span class="token string">"abcde"</span> <span class="token operator">|</span> <span class="token function">tee</span> <span class="token operator">></span><span class="token punctuation">(</span>grep <span class="token string">"a"</span><span class="token punctuation">)</span> <span class="token operator">></span>/dev/null <span class="token comment" spellcheck="true">#去掉后面的内容可以证明是异步执行</span>
<span class="token keyword">echo</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span>cat /etc/fstab<span class="token punctuation">)</span>
<span class="token function">cat</span>  <span class="token operator">&lt;</span><span class="token punctuation">(</span>cat /etc/fstab<span class="token punctuation">)</span>
<span class="token function">cat</span>  /etc/fstab <span class="token operator">|</span> <span class="token function">tee</span> <span class="token operator">></span><span class="token punctuation">(</span>grep -i <span class="token string">"UUID"</span><span class="token punctuation">)</span> <span class="token operator">></span>/dev/null</code></pre>
<h5 id="6-4-协程（coproc）"><a href="#6-4-协程（coproc）" class="headerlink" title="6.4 协程（coproc）"></a>6.4 协程（coproc）</h5><p>协程（coproc）和协同子程序（coroutine），协同函数</p>
<p>作用：<code>cmd(-&gt;) | cmd &amp; | (-&gt;)cmd</code></p>
<p>取代协程：1.命名管道、2.tee + 进程替换</p>
<h4 id="7-命令组合"><a href="#7-命令组合" class="headerlink" title="7. 命令组合"></a>7. 命令组合</h4><ol>
<li><p>命令组合都是bash的内置结构，需要专门的bash提供运行环境</p>
</li>
<li><p>其他的组合：<code>for、if、while、until、case、select、[[]]、(())、{}</code></p>
</li>
<li><p><code>()</code>：在<strong>子shell</strong>中执行命令组合，括号被当前bash解析，结果就是创建子bash，但是如果命令组合中，只有一个命令，那么这个命令就会直接覆盖子shell进程。</p>
</li>
<li><p><code>{}</code>：在  <strong>当前shell</strong>  中执行命令组合</p>
<p>注意：</p>
<ol>
<li>大括号左右两边留有空格</li>
<li>所有命令以分号结尾，除非换行</li>
</ol>
</li>
</ol>
<pre class=" language-bash"><code class="language-bash"><span class="token punctuation">(</span>echo <span class="token variable">$BASEPID</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">## BASHPID 的结果返回执行该语句的bash进程的pid</span>
<span class="token punctuation">(</span>sleep 2 <span class="token operator">|</span> <span class="token function">ps</span> -H<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">## ps -H 可以显示出进程的继承关系</span>
<span class="token punctuation">{</span>sleep 2 <span class="token operator">|</span> <span class="token function">ps</span> -H<span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">## 对比来看，一目了然</span></code></pre>
<img src="https://gitee.com/lingying177/blogimage/raw/master/img/Bash-Shell/命令组合.png" style="zoom: 67%;" />

<h4 id="8-shell-read读取文件和read替换管道"><a href="#8-shell-read读取文件和read替换管道" class="headerlink" title="8. shell  read读取文件和read替换管道"></a>8. shell  read读取文件和read替换管道</h4><h5 id="8-1-read-基本用法"><a href="#8-1-read-基本用法" class="headerlink" title="8.1 read 基本用法"></a>8.1 read 基本用法</h5><ol>
<li><p>read  -p  ：从终端中读取数据（交互式），读取的数据可以保存到多个变量中</p>
<ol>
<li><code>read -p &quot;输入你的名字：&quot; name</code>：提示你输入名字，保存在 $name变量中</li>
<li><code>read -p &quot;输入你的名字：&quot;</code>：不指定name变量，那么默认保存在 $REPLY变量中</li>
</ol>
</li>
<li><p>read  &lt;/etc/hosts   ：可以从<strong>标准输入</strong>中（管道、输入重定向）读取数据，默认读取一行。结果保存在$REPLY 中。如果后面写了多个变量，则会默认按空格分隔每个变量的赋值.</p>
<ol>
<li><code>read  -d  ‘a’  &lt;/etc/hosts</code>   ：指定a作为行分隔符，读取一行（a前面的）</li>
<li><code>read -a  arr  &lt;/etc/hosts</code>    ：读取数据，并将结果保存在名为arr的数组中</li>
</ol>
</li>
<li><p><strong>read 在读取完一次数据之后，会在读取到的位置打上标记（文件指针），表示这次已经读取到了这里，下次将继续从这里开始向下读取。</strong></p>
<ol>
<li>如果多次执行<code>read   &lt;/etc/hosts</code>  ，会发现与我们说的不同，这是因为每执行一次重定向，就相当于重新打开一次文件，文件指针就会被初始化到一开始的位置。</li>
<li>解决重定向导致的问题：（一次重定向，多次读取）<code>{read;echo $REPLY; read ; echo $REPLY;} &lt;/etc/hosts</code></li>
<li><a href="https://www.cnblogs.com/f-ck-need-u/p/7402149.html" target="_blank" rel="noopener">https://www.cnblogs.com/f-ck-need-u/p/7402149.html</a> </li>
</ol>
</li>
</ol>
<pre class=" language-bash"><code class="language-bash"><span class="token function">read</span>  var1 var2 var3 <span class="token operator">&lt;</span>/etc/hosts  
<span class="token comment" spellcheck="true"># var1 ：127.0.0.1</span>
<span class="token comment" spellcheck="true"># var2 ：localhost</span>
<span class="token comment" spellcheck="true"># var3 ：localhost.localdomain localhost4 localhost4.localdomain4</span>
<span class="token function">read</span> -a  arr  <span class="token operator">&lt;</span>/etc/hosts 
<span class="token keyword">echo</span> <span class="token variable">${arr[@]}</span>  <span class="token comment" spellcheck="true"># 查看数组全部数据</span>
<span class="token keyword">echo</span> <span class="token variable">${arr[0]}</span>  <span class="token comment" spellcheck="true"># 查看第一个数据</span>
<span class="token keyword">echo</span> <span class="token variable">${arr[1]}</span>
<span class="token keyword">echo</span> <span class="token variable">${arr[2]}</span>
<span class="token keyword">echo</span> <span class="token variable">${arr[3]}</span></code></pre>
<h5 id="8-2-在shell中指定输入（数据）源的方式"><a href="#8-2-在shell中指定输入（数据）源的方式" class="headerlink" title="8.2 在shell中指定输入（数据）源的方式"></a>8.2 在shell中指定输入（数据）源的方式</h5><ol>
<li><p>直接给文件：命令后直接加文件</p>
</li>
<li><p>管道：管道很牛，但有缺点</p>
</li>
<li><p>输入重定向：通过输入重定向，就代表着使用了标准输入。</p>
<ul>
<li>常见：&lt;filename  、 &lt;(cmd)：第二个是进程替换 </li>
</ul>
</li>
<li><p>here string  ：三个<code>&lt;</code></p>
<ul>
<li><code>cat  &lt;&lt;&lt;  “hello”</code>：将hello做为cat的输入</li>
</ul>
</li>
<li><p>here  doc ：<code>&lt;&lt;eof</code>：eof就代表文件开始的头位置，再次输入eof代表文件结束</p>
</li>
</ol>
<pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span>eof
<span class="token operator">></span>hello
<span class="token operator">></span>world<span class="token operator">!</span>
<span class="token operator">></span>eof   <span class="token comment" spellcheck="true">## 文件结束</span></code></pre>
<h5 id="8-3-读取数据的方式"><a href="#8-3-读取数据的方式" class="headerlink" title="8.3 读取数据的方式"></a>8.3 读取数据的方式</h5><ol>
<li><p>程序自身读取文件或标准输入的逻辑，程序员控制的，我们shell用户没法控制</p>
</li>
<li><p>shell下的read ，用户可控</p>
<ol>
<li><p>while read line：不建议使用管道+while read line（管道会创建子进程来执行while语句）</p>
</li>
<li><p>按字符读取</p>
</li>
<li><p>按行读取</p>
<p>注意区分：<strong>read是读取数据的，管道是传递数据的</strong></p>
</li>
</ol>
</li>
</ol>
<h5 id="8-4-while-read-line-如何替换管道"><a href="#8-4-while-read-line-如何替换管道" class="headerlink" title="8.4 while read line 如何替换管道"></a>8.4 while read line 如何替换管道</h5><pre class=" language-bash"><code class="language-bash"><span class="token keyword">while</span> <span class="token function">read</span> line<span class="token punctuation">;</span><span class="token keyword">do</span>
    <span class="token comment" spellcheck="true">#...</span>
    <span class="token comment" spellcheck="true">#...  多次操作</span>
    <span class="token comment" spellcheck="true">#...</span>
<span class="token keyword">done</span> <span class="token operator">&lt;</span>/etc/passwd</code></pre>
<h4 id="9-重定向"><a href="#9-重定向" class="headerlink" title="9. 重定向"></a>9. 重定向</h4><h5 id="9-1-基础（背景知识）"><a href="#9-1-基础（背景知识）" class="headerlink" title="9.1 基础（背景知识）"></a>9.1 基础（背景知识）</h5><p>重定向的作用：</p>
<ol>
<li>为程序指定数据输入源</li>
<li>为程序指定数据输出目标</li>
</ol>
<p>重定向基础内容：</p>
<ol>
<li><p>文件和文件描述符：</p>
<p><code>/proc/self/fd/</code>：文件描述符表的位置，对应于文件描述符，所以 <code>/proc/</code>目录是用户查看内核和改变内核的入口，注意文件描述符在用户空间层。</p>
</li>
<li><p>/dev/stdin(0)</p>
</li>
<li><p>/dev/stdout(1)</p>
</li>
<li><p>/dev/stderr(2)   ：注意：每个程序运行时都打开了上面三个文件描述符（0、1、2）</p>
</li>
<li><p>/proc/self/fd ：这是<strong>本进程</strong>打开的文件描述符</p>
</li>
<li><p>软连接指向关系：</p>
<ol>
<li>目录：<code>/dev/fd  -&gt;  /proc/self/fd</code></li>
<li><code>/dev/std(in,out,err) -&gt; /proc/self/fd/{0,1,2}</code></li>
<li><code>/proc/self/fd/{0,1,2}  -&gt; /dev/pts/N</code>（N是终端号，最终连接到了当前终端）</li>
</ol>
</li>
<li><p>特殊文件：短横线（<code>-</code>），代表了读取标准输入，需要程序内部代码去解析短横线特殊文件，如果没有相关解析代码，会报错。</p>
</li>
<li><p>重定向操作是在shell解析命令行的时候执行的，在命令执行之前，就已经确定了（即完成数据处理操作）</p>
</li>
<li><p>注意：重定向操作可以放在命令行的任意位置。</p>
</li>
</ol>
<pre class=" language-bash"><code class="language-bash"><span class="token function">ls</span> -l /dev/std*
<span class="token comment" spellcheck="true"># /dev/stdin   ->   /proc/self/fd/0</span>
<span class="token comment" spellcheck="true"># /dev/stdout  ->   /proc/self/fd/1</span>
<span class="token comment" spellcheck="true"># /dev/stderr  ->   /proc/self/fd/2</span>

<span class="token function">ls</span> -l /proc/self/fd    <span class="token comment" spellcheck="true">##当我们输入了这些命令行，还没敲回车时，这个目录是不存在的。敲下回车之后，就记录了本进程（ls）所打开的文件描述符</span>
<span class="token comment" spellcheck="true"># 0 -> /dev/pts/0     ## 这个/dev/pts/0  就是当前的终端 ，意思就是数据的输入输出读取都</span>
<span class="token comment" spellcheck="true"># 1 -> /dev/pts/0     ## 传输到这个终端</span>
<span class="token comment" spellcheck="true"># 2 -> /dev/pts/0</span>
<span class="token comment" spellcheck="true"># 3 -> /proc/2666/fd</span>

<span class="token function">ls</span> -l /proc/self/fd   <span class="token comment" spellcheck="true">## 新开一个终端，再次使用次命令</span>
<span class="token comment" spellcheck="true"># 0 -> /dev/pts/1     ## 都连接/dev/pts/1 这个终端（当前终端）</span>
<span class="token comment" spellcheck="true"># 1 -> /dev/pts/1</span>
<span class="token comment" spellcheck="true"># 2 -> /dev/pts/1</span>
<span class="token comment" spellcheck="true"># 3 -> /proc/2736/fd</span></code></pre>
<h5 id="9-2-基本重定向"><a href="#9-2-基本重定向" class="headerlink" title="9.2 基本重定向"></a>9.2 基本重定向</h5><ol>
<li>输入重定向 <code>&lt;</code>：（使用输入重定向之后，数据就变成了标准输入）</li>
<li>覆盖（截断）输出重定向 <code>&gt;</code>：</li>
<li>追加输出重定向 <code>&gt;&gt;</code></li>
<li>标准错误<code>2&gt;</code></li>
<li>重定向可以放在命令行的任意位置，因为是执行之前就解析</li>
</ol>
<h5 id="9-3-exec的作用"><a href="#9-3-exec的作用" class="headerlink" title="9.3 exec的作用"></a>9.3 exec的作用</h5><ol>
<li>替换当前shell进程</li>
<li>让重定向操作在当前shell下生效</li>
<li>exec只能让输出重定向在当前shell下生效</li>
</ol>
<pre class=" language-bash"><code class="language-bash"><span class="token function">exec</span> <span class="token operator">></span>/tmp/a.log
<span class="token function">ls</span>                        <span class="token comment" spellcheck="true"># 结果不会在屏幕输出，而是进入/tmp/a.log</span>
<span class="token function">cat</span> /etc/passwd           <span class="token comment" spellcheck="true"># 同理不会再屏幕输出</span></code></pre>
<h5 id="9-4-高级重定向"><a href="#9-4-高级重定向" class="headerlink" title="9.4 高级重定向"></a>9.4 高级重定向</h5><h6 id="9-4-1-复制（duplicate）："><a href="#9-4-1-复制（duplicate）：" class="headerlink" title="9.4.1  复制（duplicate）："></a>9.4.1  复制（duplicate）：</h6><ol>
<li><p><code>[n]&gt;&amp;N</code> （省略n时，默认n=1）</p>
</li>
<li><p><code>[n]&lt;&amp;N</code> （省略n时，默认n=0）</p>
</li>
<li><p><strong>含义解析：让 n 指向 N 所指的 文件（不严谨）</strong>。指向的是文件或设备！！！</p>
</li>
<li><p>方便理解：</p>
<p><code>&gt;/dev/null 2&gt;&amp;1</code>：先把1定义到空，再把2定义到1所指的文件（空）。结果2和1都定义到了空，没有任何输出 ===（<code>&amp;&gt;/dev/null</code>）</p>
</li>
<li><p>重定向的顺序很重要：</p>
<p>第四步如果这样写：<code>2&gt;&amp;1 &gt;/dev/null</code>：会导致 2 先定义到1所指的输出（屏幕），再把1指向空。结果：错误输出定向到了屏幕，标准输出定向到了空文件</p>
</li>
<li><p>通过exec将文件描述符绑定到文件：</p>
</li>
</ol>
<pre class=" language-bash"><code class="language-bash"><span class="token function">exec</span> 5<span class="token operator">&lt;</span>/etc/hosts    <span class="token comment" spellcheck="true"># 把文件描述符5 绑定到文件/etc/hosts</span>
<span class="token function">read</span> <span class="token operator">&lt;</span><span class="token operator">&amp;</span>5      <span class="token comment" spellcheck="true"># 再把标准输入（0）绑定到文件描述符为5的文件上（/etc/hosts）</span></code></pre>
<p><strong>注意</strong>：之所以说上面的含义不严谨，是因为 fd table 中文件描述符都指向了open file table中的一条记录。他们两个描述符<strong>共享同一个文件偏移量指针</strong>，都互相影响（因为指针共享）。例：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">exec</span>  3<span class="token operator">></span>/tmp/a.log
<span class="token keyword">echo</span> <span class="token string">"haha1"</span> <span class="token operator">></span><span class="token operator">&amp;</span>3
<span class="token keyword">echo</span> <span class="token string">"haha2"</span> <span class="token operator">></span><span class="token operator">&amp;</span>3
<span class="token keyword">echo</span> <span class="token string">"haha3"</span> <span class="token operator">></span><span class="token operator">&amp;</span>3
<span class="token comment" spellcheck="true"># 结果：</span>
<span class="token comment" spellcheck="true"># haha1  </span>
<span class="token comment" spellcheck="true"># haha2</span>
<span class="token comment" spellcheck="true"># haha3 </span>
<span class="token comment" spellcheck="true"># 结果三行都存在，我们明明使用了一个'>',本来表示覆盖重定向，但是并没有覆盖，同理绑定4到3</span>
<span class="token function">exec</span>  4<span class="token operator">></span><span class="token operator">&amp;</span>3
<span class="token keyword">echo</span> <span class="token string">"haha4"</span> <span class="token operator">></span><span class="token operator">&amp;</span>4
<span class="token keyword">echo</span> <span class="token string">"haha5"</span> <span class="token operator">></span><span class="token operator">&amp;</span>4
<span class="token keyword">echo</span> <span class="token string">"haha6"</span> <span class="token operator">></span><span class="token operator">&amp;</span>4
<span class="token comment" spellcheck="true"># 结果也是 haha1 到 haha6 都有。</span>
<span class="token comment" spellcheck="true"># 原因解释：文件描述符共享文件偏移指针。虽然执行多次echo操作，但文件仅打开了一次。第一次输出haha1之后，文件偏移指针指向了haha1的后面，由于偏移指针共享，所以再次输出haha2时，会接着上一次的指针位置去写数据（上一次指针位置是haha1后面）。同理后面绑定4到3，均不会再次打开文件，而是接着上一次的指针位置去写数据。</span>
<span class="token comment" spellcheck="true"># 虽然只是用了一个“>”，但是并不表示覆盖重定向。他是 "n>&amp;N" ，文件描述符复制。</span></code></pre>
<h6 id="9-4-2-关闭（close）文件描述符"><a href="#9-4-2-关闭（close）文件描述符" class="headerlink" title="9.4.2  关闭（close）文件描述符"></a>9.4.2  关闭（close）文件描述符</h6><ol>
<li><code>[n]&gt;&amp;-</code></li>
<li><code>[n]&lt;&amp;-</code></li>
</ol>
<h6 id="9-4-3-打开（open）文件描述符"><a href="#9-4-3-打开（open）文件描述符" class="headerlink" title="9.4.3  打开（open）文件描述符"></a>9.4.3  打开（open）文件描述符</h6><ol>
<li><code>exec  6&lt;&gt;  /etc/fstab</code>：可读可写的方式绑定6到文件上（默认不用，因为指针从头开始，会覆盖数据）</li>
<li>文件描述符的复制，也会打开文件描述符</li>
</ol>
<h6 id="9-4-6-移动（move）文件描述符"><a href="#9-4-6-移动（move）文件描述符" class="headerlink" title="9.4.6  移动（move）文件描述符"></a>9.4.6  移动（move）文件描述符</h6><ol>
<li><code>[n]&gt;&amp;N-</code></li>
<li><code>[n]&lt;&amp;N-</code> </li>
<li><strong>含义解析：移动的意思就是先复制一份文件，然后把源文件删除。即 先复制一份文件描述符n，然后关闭原来的 N 文件描述符</strong></li>
</ol>
<h5 id="9-5-高级重定向用法示例"><a href="#9-5-高级重定向用法示例" class="headerlink" title="9.5 高级重定向用法示例"></a>9.5 高级重定向用法示例</h5><ol>
<li>文件描述符的备份和还原（w命令可以查看用户及终端）</li>
</ol>
<pre class=" language-bash"><code class="language-bash"><span class="token function">exec</span> 6<span class="token operator">></span><span class="token operator">&amp;</span>1                            <span class="token comment" spellcheck="true"># 6 指向 1（把1备份为6）</span>
<span class="token function">exec</span> <span class="token operator">></span> /tmp/file.txt                 <span class="token comment" spellcheck="true"># 1定向到文件，完成操作</span>
<span class="token keyword">echo</span> <span class="token string">"---------------"</span>
<span class="token function">exec</span> 1<span class="token operator">></span><span class="token operator">&amp;</span>6 6<span class="token operator">></span><span class="token operator">&amp;</span>-                       <span class="token comment" spellcheck="true"># 操作完，再把 1 还原，删除6</span>
<span class="token keyword">echo</span> <span class="token string">"==============="</span>               <span class="token comment" spellcheck="true"># 完成工作</span>

<span class="token comment" spellcheck="true">##  （推荐使用第一种  备份和还原操作）</span>
<span class="token comment" spellcheck="true"># 第二种直接还原的方法：先在另一个终端种执行 w 命令，查看终端pts/[n]，然后执行下面的语句即可</span>
<span class="token function">exec</span> 1<span class="token operator">></span>/dev/pts/<span class="token punctuation">[</span>n<span class="token punctuation">]</span>
<span class="token comment" spellcheck="true">## Linux一切皆文件，文件描述符指向哪个文件（设备、终端），就会向哪个文件（终端、设备）输出</span>
<span class="token comment" spellcheck="true">## 如果在pts/1下执行这些命令，就会将数据输出到另一个终端：</span>
<span class="token function">exec</span> 1<span class="token operator">></span>/dev/pts/0
<span class="token keyword">echo</span> <span class="token string">"我是终端1"</span>
<span class="token comment" spellcheck="true">## 此时，pts/0 终端就会输出  我是终端1</span>
<span class="token comment" spellcheck="true">## 注意：一切皆文件</span></code></pre>
<ol start="2">
<li>实现临时文件（一切皆文件）</li>
</ol>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># open fd=3 and remove file    # 创建文件，然后删除</span>
<span class="token function">exec</span> 3<span class="token operator">&lt;</span><span class="token operator">></span> /tmp/<span class="token variable">${0}</span><span class="token variable">${$}</span>.temp
<span class="token function">rm</span> -rf /tmp/<span class="token variable">${0}</span><span class="token variable">${$}</span>.temp

<span class="token comment" spellcheck="true"># file deleted          </span>
<span class="token function">ls</span> /proc/self/fd              <span class="token comment" spellcheck="true"># 通过查看，描述符还在，说明重定向的文件还能用</span>
<span class="token function">lsof</span> -n <span class="token operator">|</span> <span class="token function">grep</span> -E <span class="token string">'temp.*delete[d]'</span>          <span class="token comment" spellcheck="true"># 发现被删除了，但是文件描述符依然能用</span>

<span class="token comment" spellcheck="true">#write to fd</span>
<span class="token keyword">echo</span> <span class="token string">"hello world"</span> <span class="token operator">></span><span class="token operator">&amp;</span>3             <span class="token comment" spellcheck="true"># 向3中输入数据</span>

<span class="token comment" spellcheck="true"># read from fd</span>
<span class="token comment" spellcheck="true"># cat &lt;&amp;3                     # 此处不用 cat直接从3中读取，是因为只打开了一次文件，刚才写入数据之后，</span>
<span class="token function">cat</span> /proc/self/fd/3           <span class="token comment" spellcheck="true"># 偏移指针就指向了world的末尾，直接用cat读取会直接向后读，没有数据的，必须使用cat 读取那个文件（Linux一切皆文件！！！），才是重新打开描述符3</span>

<span class="token comment" spellcheck="true"># close fd              # 关闭</span>
<span class="token function">exec</span> 3<span class="token operator">&lt;</span><span class="token operator">&amp;</span>-
<span class="token function">lsof</span> -n <span class="token operator">|</span> <span class="token function">grep</span> -E <span class="token string">'temp.*delete[d]'</span></code></pre>
<ol start="3">
<li>多进程控制（进程池）<ul>
<li>后台进程</li>
<li>进程替换</li>
<li>coproc</li>
<li>xargs -P N  ：<ul>
<li>指定最多多少进程同时运行，只适用于没有大量IO操作的场景</li>
<li>split/csplit</li>
</ul>
</li>
<li>parallel ：解决xargs的缺点，但  复杂</li>
</ul>
</li>
</ol>
<h4 id="10-shell-解析命令行"><a href="#10-shell-解析命令行" class="headerlink" title="10. shell 解析命令行"></a>10. shell 解析命令行</h4><h5 id="10-1-引号解析示例"><a href="#10-1-引号解析示例" class="headerlink" title="10.1 引号解析示例"></a>10.1 引号解析示例</h5><ol>
<li>单引号中的双引号，以及双引号中的单引号，都会被保留不被 shell 解析（只解析配对的引号）</li>
<li>引号配对，从左至右进行配对</li>
<li>可以将一个参数通过引号配对的方式分隔开，分隔开，只要分隔的时候不要使用空白符号断开。（分隔开了就会被当成两个参数）</li>
<li>单引号是强引用，双引号是弱引用</li>
</ol>
<p>解析问题：</p>
<ol>
<li>如果在单引号中使用单引号，双引号中使用双引号，必须配对再输入一个单（双）引号</li>
<li>如果在不想让双引号中的特殊字符解析，必须转义。例如：<code>echo “\$name”</code></li>
<li>单引号（强引用）中使用反斜线转义没有意义。</li>
</ol>
<pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">'hello"world'</span>
<span class="token keyword">echo</span> <span class="token string">"hello'world"</span></code></pre>
<p><strong>sed 程序示例</strong>：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">sed</span> -n <span class="token string">"<span class="token variable">$p</span>"</span> filename  <span class="token comment" spellcheck="true">## 如果想输出文件的最后一行，这是错误的。应该用单引号</span>
<span class="token function">sed</span> -n <span class="token string">'<span class="token variable">$p</span>'</span> filename  <span class="token comment" spellcheck="true">## 正确的使用</span>
<span class="token function">sed</span> -n \<span class="token variable">$p</span>  filename  <span class="token comment" spellcheck="true">## 正确</span>

<span class="token function">sed</span> -n <span class="token string">'$-2p'</span> /etc/passwd  <span class="token comment" spellcheck="true">## 想输出倒数第三行,使用错误,因为sed中的行号计数器只有在全部读取完文件后才给$赋值</span>
<span class="token function">wc</span> -l /etc/passwd<span class="token punctuation">;</span>line<span class="token operator">=</span>27<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">## 先把行号赋值给line变量</span>
<span class="token function">sed</span> -n <span class="token string">"<span class="token variable">${line}</span>p"</span> /etc/passwd  <span class="token comment" spellcheck="true">## 正确</span>

<span class="token function">sed</span> -n <span class="token string">"<span class="token variable">${line}</span>p;<span class="token variable">$p</span>"</span> /etc/passwd  <span class="token comment" spellcheck="true">## 想输出倒数第三行和最后一行,错误</span>
<span class="token function">sed</span> -n <span class="token string">"<span class="token variable">${line}</span>p;"</span><span class="token string">'<span class="token variable">$p</span>'</span> /etc/passwd  <span class="token comment" spellcheck="true">## 正确.使用单引号,不让shell 解析$p,而是交给sed处理</span>
<span class="token function">sed</span> -n <span class="token string">"<span class="token variable">${line}</span>p;\<span class="token variable">$p</span>"</span> /etc/passwd  <span class="token comment" spellcheck="true">## 正确.使用反斜线转义,也可实现</span>
<span class="token function">sed</span> -n <span class="token variable">${line}</span><span class="token string">"p;\<span class="token variable">$p</span>"</span> /etc/passwd  <span class="token comment" spellcheck="true">## 也可以</span></code></pre>
<p><strong>awk 程序示例</strong>：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">## 想输出  hello'world  (带单引号)</span>
<span class="token function">awk</span> <span class="token string">'BEGIN{print "hello world"}'</span>  <span class="token comment" spellcheck="true">## 输出不带单引号的hello world 成功</span>
<span class="token function">awk</span> <span class="token string">'BEGIN{print "hello'</span>world<span class="token string">"}'  ## 输出带单引号的hello'world 失败 (看颜色也可以知道),因为前两个双引号配对了,shell就解析了,后面就剩了一个双引号,一个单引号

awk 'BEGIN{print "</span>hello<span class="token string">' "'</span><span class="token string">" 'world"</span><span class="token punctuation">}</span><span class="token string">' ## 用双引号把那个单独的单引号包围,前后再加上单引号配对一开始的和最后的单引号,注意:引号引号之间没有空白符,我是为了理解才加上的
awk " BEGIN{print \"hello'</span>world\<span class="token string">" }"</span>  <span class="token comment" spellcheck="true">## 正确,将一开始单引号换成双引号,里面的双引号进行转义(交给awk程序处理,单引号因没有配对,而被解析成单个字符)</span>
<span class="token function">awk</span> <span class="token string">'BEGIN{print "hello\047 world"}'</span> <span class="token comment" spellcheck="true">## 正确,用八进制ASCII代表单引号(shell不认识但awk认识ASCII)</span>
<span class="token function">awk</span> -v q<span class="token operator">=</span><span class="token string">"'"</span> <span class="token string">'BEGIN{print "hello"q"world"}'</span> <span class="token comment" spellcheck="true">## 把变量q定义为单引号,然后应用</span>
<span class="token comment" spellcheck="true">## 直接使用awk脚本文件a.awk,内容为:</span>
BEGIN <span class="token punctuation">{</span>print <span class="token string">"hello'world"</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">## 不需要考虑与shell冲突的问题了</span></code></pre>
<h5 id="10-2-命令行解析"><a href="#10-2-命令行解析" class="headerlink" title="10.2 命令行解析"></a>10.2 命令行解析</h5><ol>
<li>shell 解析的过程：<ul>
<li>暴露给shell解析，使用双引号或不使用引号</li>
<li>避免给shell 解析到，就一定要放到单引号当红，或使用反斜线转义</li>
<li>用来解析shell的特殊符号：引号、管道符号、重定向符号、变量替换符号、进程替换、命令替换、&amp;、大小括号、空白符号（IFS） 等等<ul>
<li>IFS：将命令行划分成一个个的word</li>
</ul>
</li>
<li>shell 解析完成之后，命令行就变了。 通过 <code>cat /proc/self/cmdline</code>查看，可知空白符被替换成了<strong>NUL（\0）</strong></li>
</ul>
</li>
<li>命令（程序自身解析）：<ul>
<li>这个解析过程，在命令行中是我们无法控制的，由编写程序的程序员决定解析什么选项、什么参数、以及如何解析</li>
</ul>
</li>
<li>为什么要避免shell解析：<ul>
<li>因为某些命令中的特殊符号，和shell的特殊符号冲突了</li>
<li>如果，想要把这个特殊符号，留给命令自身，就不能被shell解析</li>
<li>如果想要把特殊符号留给shell解析，就需要将特殊符号暴露给shell去解析</li>
</ul>
</li>
</ol>
<h5 id="10-3-shell-解析命令行的细节（核心）"><a href="#10-3-shell-解析命令行的细节（核心）" class="headerlink" title="10.3  shell 解析命令行的细节（核心）"></a>10.3  <strong>shell 解析命令行的细节（核心）</strong></h5><ol>
<li>读取命令行</li>
</ol>
<ul>
<li>命令组合的特殊符号，管道、&amp;、()、；等等</li>
</ul>
<ol start="2">
<li><p>划分token</p>
<ul>
<li><p>单词（word）拆分：按照$IFS拆分（默认“SPACE\t\n”）</p>
</li>
<li><p>引号和反斜线的作用：引号配对</p>
</li>
</ul>
</li>
<li><p>确定重定向的位置（&gt;截断）</p>
</li>
<li><p>命令检查（是否是某些特殊结构的命令）</p>
<ul>
<li>if、for、while、until、select、case</li>
</ul>
</li>
<li><p>检查是否是<strong>别名</strong></p>
</li>
<li><p>各种扩展</p>
<ol>
<li><p>大括号扩展： <code>echo {1..10};echo {a..d}、touch /tmp/{a..d}.log</code></p>
</li>
<li><p>波浪号扩展：</p>
<ul>
<li><code>~</code>：表示家目录</li>
<li><code>~+</code>：表示当前目录 == $PWD</li>
<li><code>~-</code>：表示上一次所处的路径（目录）  == $OLDPWD</li>
</ul>
</li>
<li><p>参数、变量替换：</p>
<ul>
<li><code>echo $name;echo $(name%%s*)</code>：<strong>变量替换是在echo进程出现前进行的</strong>，后面 name%%s* 意思是贪婪删除，知道出现s为止的所有字符，如果name=longshuai，会删除最后到s（逆向）输出long</li>
</ul>
</li>
<li><p>算术扩展：</p>
<p><code>a=44;echo $((a+6))</code></p>
</li>
<li><p>命令替换、进程替换</p>
<ol>
<li>命令替换：<code>$()</code>以及两个反引号：<code>echo $(echo hello)</code>== <code>echo haha</code></li>
<li>进程替换：<code>&lt;()、&gt;()</code></li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>注意：如果进行了一个或两个 第3、4、5步中的扩展，会再次进行单词拆分（只有未在引号中进行扩展，才会进行这一单词拆分的过程，被包含在引号中就不会拆分了）</strong></p>
<ol start="6">
<li><p>文件名通配符扩展</p>
<ul>
<li><code>*</code>不能匹配以点开头的隐藏文件，除非开启匹配选项（shopt -s dotglob）</li>
<li><code>*</code>默认不能递归到子目录去匹配，除非开启（shopt -s globstar），使用<code>**/*.c</code>即可到子目录的.c文件下搜索</li>
<li>shopt -s extglob ：扩展shell下的通配功能，使用正则。</li>
</ul>
</li>
</ol>
<ol start="7">
<li><p>引号去除：</p>
<ul>
<li>命令自身是不需要引号的</li>
</ul>
</li>
<li><p>搜索命令</p>
<ol>
<li>判断相对路径、绝对路径：斜杠</li>
<li>检查是否有同名函数</li>
<li>是否是bash内置命令</li>
<li>$PATH</li>
</ol>
</li>
<li><p>fork+exec</p>
</li>
<li><p>执行命令</p>
<ol>
<li>解析选项、参数</li>
<li>执行主代码逻辑</li>
<li>退出；返回退出状态码</li>
<li>父bash进程收到退出状态码后为子进程收尸</li>
</ol>
</li>
<li><p>触发信号捕获功能 </p>
</li>
</ol>
<img src="https://gitee.com/lingying177/blogimage/raw/master/img/Bash-Shell/shell解析核心.png" style="zoom:50%;" />

<p>图为  <a href="https://www.cnblogs.com/f-ck-need-u/p/7426371.html" target="_blank" rel="noopener">https://www.cnblogs.com/f-ck-need-u/p/7426371.html</a>  中的图，注意双引号扩展不包括单词拆分和文件名扩展功能，图中未标注</p>
<p>示例：</p>
<pre class=" language-bash"><code class="language-bash">name<span class="token operator">=</span>longshuai
a<span class="token operator">=</span>24
<span class="token keyword">echo</span> -e <span class="token string">"some files:"</span> ~/i* <span class="token string">"\nThe date:<span class="token variable"><span class="token variable">$(</span><span class="token function">date</span> +%F<span class="token variable">)</span></span>\n<span class="token variable">$name</span>'s age is <span class="token variable"><span class="token variable">$((</span>a<span class="token operator">+</span><span class="token number">4</span><span class="token variable">))</span></span>"</span> <span class="token operator">></span>/tmp/a.log</code></pre>
<p>图解上面命令：</p>
<img src="https://gitee.com/lingying177/blogimage/raw/master/img/Bash-Shell/shell解析.png" style="zoom:67%;" />

<h5 id="10-4-eval-二次解析"><a href="#10-4-eval-二次解析" class="headerlink" title="10.4 eval 二次解析"></a>10.4 eval 二次解析</h5><pre class=" language-bash"><code class="language-bash">a<span class="token operator">=</span>hello
hello<span class="token operator">=</span>xiaomage
<span class="token function">eval</span> <span class="token keyword">echo</span> \$<span class="token variable">$a</span>
<span class="token comment" spellcheck="true"># 解析1：eval echo $hello</span>
<span class="token comment" spellcheck="true"># 解析2：echo $hello</span>
<span class="token comment" spellcheck="true">## 结果：输出xiaomage</span></code></pre>
<p>类似可以二次解析的命令还有time、xargs等</p>
<h4 id="11-作用域"><a href="#11-作用域" class="headerlink" title="11 作用域"></a>11 作用域</h4><ol>
<li>函数自动全局和局部修饰local<ul>
<li>shell中自定义函数也是默认全局作用域，除非使用local 修饰该变量</li>
</ul>
</li>
<li>子shell 不影响父shell 环境<ul>
<li>通过子shell 也可以实现局部作用域</li>
</ul>
</li>
<li>词法作用域<ul>
<li>文本定义（函数定义）位置决定了作用域的课件范围，在哪定义就属于哪个作用域</li>
</ul>
</li>
<li>动态作用域<ul>
<li>文本调用位置决定作用域可见范围，在哪调用就属于哪个作用域</li>
</ul>
</li>
<li>bash 采取动态作用域</li>
</ol>
<pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token comment" spellcheck="true"># 1.动态作用域规则：文本调用位置决定作用域范围，</span>
<span class="token comment" spellcheck="true">#        因为f()是在g()函数内部调用的，而且g()函数内部定义了局部变量x</span>
<span class="token comment" spellcheck="true">#        所以，调用f()函数的时候，f()内部访问的变量x是g()内部的局部变量</span>
<span class="token comment" spellcheck="true">#        所以，f()中输出的是   f: 3</span>
<span class="token comment" spellcheck="true">#        而且，f()修改的变量x也是g()中的局部变量x</span>
<span class="token comment" spellcheck="true">#        于是，在g()中的echo输出的是  g: 2</span>
<span class="token comment" spellcheck="true"># 整个输出结果：</span>
<span class="token comment" spellcheck="true"># f: 3</span>
<span class="token comment" spellcheck="true"># g: 2</span>
<span class="token comment" spellcheck="true"># 1</span>
<span class="token comment" spellcheck="true"># shell 使用动态作用域，所以会显示这个</span>

<span class="token comment" spellcheck="true">#2.词法作用域规则：文本定义位置决定作用域范围</span>
<span class="token comment" spellcheck="true">#        因为f()和g()是定义在全局范围内的，所以，f()和g()内部访问的变量x都是全局变量x</span>
<span class="token comment" spellcheck="true">#        但是g()函数内部使用local修改了局部变量x，使得local语句之后的所有访问变量x的语句都只能访问到局部变量x</span>
<span class="token comment" spellcheck="true">#        所以，f()中访问的变量x是全局变量x=1，修改的也是全局变量x</span>
<span class="token comment" spellcheck="true">#        g()访问的变量x是局部变量x=3</span>
<span class="token comment" spellcheck="true">#        注意：f()和g()访问的变量不一样</span>
<span class="token comment" spellcheck="true"># 输出结果：</span>
<span class="token comment" spellcheck="true"># f: 1</span>
<span class="token comment" spellcheck="true"># g: 3</span>
<span class="token comment" spellcheck="true"># 2</span>


x<span class="token operator">=</span>1

<span class="token keyword">function</span> f<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">echo</span> <span class="token string">"f: <span class="token variable">$x</span>"</span><span class="token punctuation">;</span>
    x<span class="token operator">=</span>2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> g<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    local x<span class="token operator">=</span>3<span class="token punctuation">;</span>
    f<span class="token punctuation">;</span>
    <span class="token keyword">echo</span> <span class="token string">"g: <span class="token variable">$x</span>"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
g
<span class="token keyword">echo</span> <span class="token variable">$x</span></code></pre>
<h4 id="12-信号和信号捕捉"><a href="#12-信号和信号捕捉" class="headerlink" title="12 信号和信号捕捉"></a>12 信号和信号捕捉</h4><h5 id="12-1-操作系统中的信号"><a href="#12-1-操作系统中的信号" class="headerlink" title="12.1 操作系统中的信号"></a>12.1 操作系统中的信号</h5><ol>
<li>软中断：从软件的角度上去打断进程的正常执行流程</li>
<li>异步<ul>
<li>信号是随时可能产生的</li>
<li>信号产生后，可能会等待一段时间才会发送给进程</li>
<li>进程接收到信号后，仍然可能会等待一段时间才会去处理信号</li>
</ul>
</li>
<li>注册信号处理程序，自定义处理逻辑</li>
<li>谁发送信号<ul>
<li>内核</li>
<li>进程自身发送信号给自己</li>
<li>进程1发送信号给进程2</li>
</ul>
</li>
<li>每个信号都有一个自己的数值编号<ul>
<li>HUP</li>
<li>SIGHUP</li>
</ul>
</li>
<li>信号的分类：<ul>
<li>标准信号（1-31）</li>
<li>实时信号（34-64）</li>
</ul>
</li>
<li>不同操作系统类型对有些信号的实现是不一样的，编号也可能不一样</li>
</ol>
<h5 id="12-2-常见信号"><a href="#12-2-常见信号" class="headerlink" title="12.2 常见信号"></a>12.2 常见信号</h5><p><code>kill -l</code>：查看所有信号。标准信号（1-31）、实时信号（34-64）</p>
<ul>
<li>HUP(1)：hang up<ul>
<li>终止“普通”进程。只要进程没有脱离终端，就是“普通”进程</li>
<li>当终端断开连接的时候，内核会发送HUP信号给控制进程（产生链式反应）。控制进程会将HUP信号继续发送给终端内的所有进程</li>
<li>发送HUP信号给daemon（守护进程）类进程时，不会终止进程，而是让这类进程重读配置文件，实现 graceful restart的功能c</li>
</ul>
</li>
<li>INT(2)：<strong>Ctrl + C</strong> <ul>
<li>Ctrl + C 和 INT 信号是有区别的：前者是发送给整个进程组，会影响进程组内的所有进程；后者是发送给进程组的leader进程，不会影响进程组内的其他进程。<strong>kill -INT -PGID</strong></li>
</ul>
</li>
<li>KILL(9)：必杀信号（实在没有办法采用，一般不用）</li>
<li>TERM(15)：终止进程的标准信号，比kill(9)好多了</li>
</ul>
<p><strong>注意：上面四个信号以及 0信号 必须掌握</strong></p>
<ul>
<li>TSTP：<strong>Ctrl + Z</strong> <ul>
<li>让前台的进程进入后台，并进入stop状态（注意这不是终止进程，仅仅是停止，可恢复）</li>
</ul>
</li>
<li>CONT：让stop状态的进程提到前台，继续运行 runing <code>fg命令</code></li>
<li>QUIT：<strong>Ctrl + \</strong><ul>
<li>比term信号好一点，会产生coredump文件 </li>
</ul>
</li>
<li>CHLD：<ul>
<li>内核发送CHLD信号给父进程，<strong>通知</strong>父进程它有子进程已经终止了，仅仅是通知（收尸是父进程使用wait/waitpid）</li>
</ul>
</li>
<li>WINCH：<ul>
<li>当一个窗口尺寸发生改变时，就会发送此信号。</li>
<li>对后台进程而言，他们没有窗口，所以默认情况下 WINCH 是不起作用的，所以，程序员就可以去对后台进程注册 WINCH 信号的处理程序，实现自定义的处理逻辑</li>
</ul>
</li>
<li>STOP、USR1、USR2、TTIN、TTOU……</li>
<li>特殊信号（0）：检查进程是否存在</li>
</ul>
<h5 id="12-3-shell中发送信号的方式"><a href="#12-3-shell中发送信号的方式" class="headerlink" title="12.3 shell中发送信号的方式"></a>12.3 shell中发送信号的方式</h5><ol>
<li>kill 类命令 <code>kill -CONT %1</code>：给后台进程id为1 的进程发送CONT信号</li>
<li>快捷键：Ctrl + （C、Z、\）：<strong>对于脱离了终端的后台进程无效</strong></li>
</ol>
<h5 id="12-4-shell-中-trap-捕获信号"><a href="#12-4-shell-中-trap-捕获信号" class="headerlink" title="12.4 shell 中 trap 捕获信号"></a>12.4 shell 中 trap 捕获信号</h5><ol>
<li>trap：shell中用来注册信号处理程序</li>
<li>执行命令列表：<code>trap &#39;cmdlist&#39; sig_list</code></li>
<li>忽略信号：<code>trap &#39;&#39; sig_list</code></li>
<li>重置信号：<code>trap  - sig_list</code>：重置为刚登陆时的那种状态  </li>
</ol>
<pre class=" language-bash"><code class="language-bash"><span class="token function">trap</span> <span class="token string">"echo trapped"</span> INT  <span class="token comment" spellcheck="true">## 定义：当捕获到INT信号时（按CTRL + c），就输出trapped</span>
<span class="token function">trap</span> <span class="token string">"echo trapped;echo haha;echo hehe;"</span> INT QUIT TERM <span class="token comment" spellcheck="true">##可以给多个信号同时定义多个命令</span>
<span class="token function">trap</span> <span class="token string">''</span> INT <span class="token comment" spellcheck="true">## 定义为忽略信号，按ctrl + C 没有任何反应</span>
<span class="token function">trap</span> - SIGHUP INT QUIT TERM  <span class="token comment" spellcheck="true">## 全部重置掉</span></code></pre>
<ol start="5">
<li>在shell脚本中使用trap<ul>
<li>清理临时文件</li>
<li>清理脚本中的后台进程</li>
<li>使用<code>kill 0</code> 杀掉整个进程组</li>
</ul>
</li>
</ol>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 清理临时文件</span>
<span class="token comment" spellcheck="true">#!/bin/bash</span>

<span class="token function">trap</span> <span class="token string">"echo trapped;rm -rf <span class="token variable">$tmp_dir</span>;exit 1 "</span> INT HUP QUIT TERM
<span class="token comment" spellcheck="true"># trap 'echo trapped;rm -rf $tmp_file;exit 1' EXIT</span>
tmp_dir<span class="token operator">=</span>/tmp/<span class="token variable">$BASHPID</span>
<span class="token function">mkdir</span> <span class="token variable">$tmp_dir</span>
<span class="token function">touch</span> <span class="token variable">$tmp_dir</span>/<span class="token punctuation">{</span>a<span class="token punctuation">..</span>d<span class="token punctuation">}</span>.tmp
<span class="token function">ls</span> <span class="token variable">$tmp_dir</span>

<span class="token function">sleep</span> 5
<span class="token comment" spellcheck="true">## 前台进入睡眠时，按ctrl + c 停止，即可看见清理文件的作用，查看一下临时文件是否还在</span>


<span class="token function">rm</span> -rf <span class="token variable">$tmp_dir</span>
<span class="token keyword">echo</span> <span class="token string">'over'</span></code></pre>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 清理脚本中的后台进程</span>
<span class="token keyword">function</span> signal_handle<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">echo</span> trapped
    <span class="token function">kill</span> <span class="token variable">$pid</span>
    <span class="token keyword">exit</span> 1
<span class="token punctuation">}</span>
<span class="token function">trap</span> <span class="token string">'signal_handle'</span> INT HUP QUIT TERM 
<span class="token comment" spellcheck="true"># trap 'signal_handle' EXIT </span>
<span class="token function">sleep</span> 20 <span class="token operator">&amp;</span>
pid <span class="token operator">=</span> <span class="token variable">$!</span>

<span class="token function">sleep</span> 20 <span class="token operator">&amp;</span>
pid<span class="token operator">=</span><span class="token string">"<span class="token variable">$!</span>  <span class="token variable">$pid</span>"</span>

<span class="token function">sleep</span> 5</code></pre>
<pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>                 
<span class="token comment" spellcheck="true"># 使用kill 0 杀当前进程</span>

<span class="token keyword">function</span> signal_handle<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">echo</span> trapped
    <span class="token function">kill</span> -TERM 0   <span class="token comment" spellcheck="true">## 通过发送TERM信号杀掉整个进程组，因为脚本运行时，脚本进程就是当前进程组的leader进程</span>
                   <span class="token comment" spellcheck="true">## 不推荐使用 QUIT INT ，快捷键发送的信号对后台进程没有效果的</span>
    <span class="token keyword">exit</span> 1
<span class="token punctuation">}</span>

<span class="token function">trap</span> <span class="token string">'signal_handle'</span> EXIT

<span class="token function">sleep</span> 10 <span class="token operator">&amp;</span>
<span class="token function">sleep</span> 20 <span class="token operator">&amp;</span>


<span class="token function">sleep</span> 5</code></pre>
<h5 id="12-5-shell中信号和trap-的注意事项"><a href="#12-5-shell中信号和trap-的注意事项" class="headerlink" title="12.5  shell中信号和trap 的注意事项"></a>12.5  shell中信号和trap 的注意事项</h5><ol>
<li><p>trap 是bash内置命令，它守护的是bash环境</p>
</li>
<li><p>接收到信号后，会等待正在执行的前台任务完成后才去触发信号处理程序。原因：shell认为前台进程都是重要任务</p>
</li>
<li><p>trap 设置的信号守护 是对bash 运行环境的设置，可能会被子shell继承：只有忽略类型的信号会被子shell继承</p>
</li>
<li><p>信号守护是有范围的</p>
</li>
<li><p>交互式shell 会忽略 TERM 信号（<code>killall bash</code>发送的就是TERM 信号）；在任何情况下，bash都会忽略 QUIT 信号</p>
</li>
<li><p>特殊信号：</p>
<ul>
<li>ERR 信号：bash 出错的时候，set -e</li>
<li>EXIT 信号：bash 退出的时候（KILL信号例外）</li>
</ul>
</li>
</ol>
<h4 id="13-子shell"><a href="#13-子shell" class="headerlink" title="13  子shell"></a>13  子shell</h4><h5 id="13-1-什么是子shell"><a href="#13-1-什么是子shell" class="headerlink" title="13.1  什么是子shell"></a>13.1  什么是子shell</h5><ol>
<li>是子进程？（不一定）</li>
<li>子shell（bash 进程）</li>
<li>不考虑进程，只考虑shell环境</li>
</ol>
<h5 id="13-2-子shell为什么这么重要"><a href="#13-2-子shell为什么这么重要" class="headerlink" title="13.2  子shell为什么这么重要"></a>13.2  子shell为什么这么重要</h5><ul>
<li>不考虑进程，只考虑shell环境</li>
</ul>
<h5 id="13-3-bash内置命令和函数的特殊性"><a href="#13-3-bash内置命令和函数的特殊性" class="headerlink" title="13.3  bash内置命令和函数的特殊性"></a>13.3  bash内置命令和函数的特殊性</h5><ol>
<li>不需要开启新的进程</li>
<li>它们依赖于shell环境，没有shell环境，就没法执行</li>
</ol>
<h5 id="13-4-子shell的特点"><a href="#13-4-子shell的特点" class="headerlink" title="13.4  子shell的特点"></a>13.4  子shell的特点</h5><ol>
<li>按需继承父shell 环境、不影响父shell</li>
<li>当前shell中执行：<code>source</code>（return语句）（仅影响当前shell）、<code>{}</code>（仅影响当前shell）</li>
<li>子shell中执行：<code>()</code>（仅在子shell中生效）</li>
</ol>
<h5 id="13-5-什么时候进入新的shell环境"><a href="#13-5-什么时候进入新的shell环境" class="headerlink" title="13.5  什么时候进入新的shell环境"></a>13.5  什么时候进入新的shell环境</h5><ul>
<li><p>两个特殊的变量</p>
<ul>
<li><code>$BASHPID</code>：常用，查看bash PID</li>
<li><code>$BASH_SUBSHELL</code>：查看当前所处的是第几层嵌套环境</li>
</ul>
</li>
<li><p>普通命令：<code>?(N)</code></p>
</li>
<li><p>bash 内置命令 <code>?(N)</code>，但放管道后<code>?(Y)</code></p>
</li>
<li><p>管道<code>?(Y)</code>：开启进程组，两个子shell环境</p>
</li>
<li><p>bash 命令自身 <code>bash</code>，<code>?(Y)</code></p>
</li>
<li><p><code>(cmd1;cmd2;cmd3…)</code>，<code>?(Y)</code></p>
</li>
<li><p><code>{cmd1;cmd2;cmd3;…;}</code>，<code>?(N)</code></p>
</li>
<li><p>命令替换<code>?(Y)</code></p>
</li>
<li><p>进程替换<code>?(Y)</code></p>
</li>
<li><p>后台任务<code>?(Y)</code></p>
</li>
<li><p>直接执行shell脚本<code>?(Y)</code>，但source脚本除外<code>?(N)</code></p>
</li>
</ul>
<p><strong>注意：进入新shell环境的共同点：fork 进程时，需要shell解析（比如特殊符号）特殊：source 是bash 内置命令，所以不会进入子shell</strong></p>
<h4 id="14-wait-命令"><a href="#14-wait-命令" class="headerlink" title="14  wait 命令"></a>14  wait 命令</h4><ol>
<li>子进程需要等待 收尸</li>
<li>wait()、waitpid()</li>
<li>再看命令生命周期：shell前台进程<ul>
<li>fork之后两个进程分支</li>
<li>子进程exec加载新程序</li>
<li>父进程wait()，进入阻塞，等待给子进程收尸</li>
</ul>
</li>
<li>bash的wait()：<ul>
<li>wait pid1 pid2 pid3 …</li>
<li>wait job1 job2 job3 …</li>
<li>wait pid jobid</li>
<li>无参数wait()：<strong>等待所有子进程</strong>(特别实用)</li>
<li>wait的好处：<strong>解决前后有依赖性的命令</strong>：例如软件安装配置脚本，需要等待软件包安装完以后，再执行自动配置操作</li>
</ul>
</li>
</ol>
<h4 id="15-终端、进程组、会话、shell"><a href="#15-终端、进程组、会话、shell" class="headerlink" title="15  终端、进程组、会话、shell"></a>15  终端、进程组、会话、shell</h4><h5 id="15-1-登录终端"><a href="#15-1-登录终端" class="headerlink" title="15.1  登录终端"></a>15.1  登录终端</h5><ol>
<li>登录控制台终端的过程：<ol>
<li>init 加载 getty 程序：根据/etc/inittab 决定加载的终端</li>
<li>getty进程open终端设备（文件）（虚拟终端）<ul>
<li>打开文件描述符 0、1、2</li>
<li>显示login 提示输入用户名</li>
</ul>
</li>
<li>getty 加载login进程</li>
<li>login 进程提示输入密码、验证、加载shell</li>
</ol>
</li>
<li>网络登录终端（如ssh）<ol>
<li>sshd 等待客户端连接</li>
<li>sshd 打开<strong>伪终端</strong><ol>
<li>打开文件描述符0、1、2</li>
<li>显示login 提示输入用户名</li>
</ol>
</li>
<li>fork 子进程：子进程加载login程序，父进程sshd继续监听</li>
<li>login验证用户登录，加载shell</li>
</ol>
</li>
</ol>
<h5 id="15-2-进程组"><a href="#15-2-进程组" class="headerlink" title="15.2  进程组"></a>15.2  进程组</h5><ol>
<li><p>标识：PGID</p>
</li>
<li><p>是进程的集合，每个进程都有所属进程组</p>
</li>
<li><p>每个进程组都有leader进程 <strong>leader的pid==进程组的pgid</strong></p>
</li>
<li><p>子进程创建出来时会继承父进程所属进程组的ID</p>
</li>
<li><p>脱离组忽略组信号：例如独自成组（<code>setpgid()</code>）</p>
</li>
<li><p>进程组的好处：</p>
<ul>
<li>为实现shell提供支持</li>
<li>使得waitpid()可以等待整个进程组</li>
<li>可以发送信号给整个进程组</li>
</ul>
<hr>
</li>
<li><p>shell（如bash）登录后，shell是一个进程组</p>
</li>
<li><p>shell中通过管道成立进程组</p>
</li>
<li><p>支持作业系统的bash，执行每个命令都独自成组</p>
</li>
</ol>
<h5 id="15-3-会话"><a href="#15-3-会话" class="headerlink" title="15.3  会话"></a>15.3  会话</h5><ol>
<li><p>标识：SESSION ID/SID</p>
</li>
<li><p>是进程组的集合，包含一个或多个进程组</p>
</li>
<li><p>每个session有leader：session创建者进程</p>
</li>
<li><p>子进程创建出来时会继承父进程所属session id</p>
</li>
<li><p>setsid()函数</p>
<ol>
<li>创建session和第一个process group</li>
<li>进程自己成为session leader和group leader</li>
<li>setsid设置的会话是没有控制终端的，如果之前有，将会切断会脱离终端</li>
<li>daemon类进程，会调用setsid()来脱离终端，成立独自的session</li>
</ol>
</li>
<li><p>存在一个setsid 命令（不是函数）：将进程放入一个新session中，脱离终端</p>
</li>
<li><p>存在一个daemon/daemonize令：将某个进程运行成daemon进程（脱离终端，新session）</p>
</li>
</ol>
<h5 id="15-4-终端、会话、进程组、shell、普通进程-的关系"><a href="#15-4-终端、会话、进程组、shell、普通进程-的关系" class="headerlink" title="15.4 终端、会话、进程组、shell、普通进程 的关系"></a>15.4 终端、会话、进程组、shell、普通进程 的关系</h5><p>关系：（军营、军队、小分队、将军、小兵）</p>
<h6 id="15-4-1"><a href="#15-4-1" class="headerlink" title="15.4.1"></a>15.4.1</h6><ol>
<li><p>类比：</p>
<ul>
<li>终端–&gt; 军营</li>
<li>会话–&gt; 军队</li>
<li>进程组–&gt; 小分队</li>
<li>登录终端时的shell 进程 –&gt; 将军</li>
<li>普通的进程–&gt; 小兵</li>
</ul>
</li>
<li><p>session 可以用于0或1个终端</p>
</li>
<li><p>控制终端是谁创建的</p>
<ul>
<li><p>终端由getty 或sshd 创建</p>
</li>
<li><p>user login之后将创建一个session，此时session还没有绑定终端</p>
</li>
<li><p>session leader 绑定一个终端，该终端将成为session的<strong>控制终端</strong></p>
</li>
</ul>
</li>
<li><p>终端的控制进程：</p>
<ul>
<li>该session leader将成为终端的控制进程：shell 进程</li>
<li>是控制进程的标志：当该进程与终端断开时，内核发送SIGHUP信号给该控制进程（session leader），从而引起链式反应</li>
<li><strong>结果是：该终端上的所有任务都被终止，或者直接脱离终端</strong></li>
<li>另一角度看，控制进程断开连接后，终端和会话就断开了，需要和会话中的其他进程也断开关系</li>
</ul>
</li>
<li><p>在有终端的会话中</p>
<ul>
<li>只有一个前台进程组，n(n&gt;0)个后台进程组</li>
<li><strong>键盘发送的信号都发送给前台进程组：Ctrl + c/z</strong></li>
<li>tcsetpgrp()可将某进程组设置为终端的前台进程组（fg）</li>
</ul>
</li>
<li><p>在没有终端的会话中</p>
<ul>
<li>setsid()设置的会话是没有终端的</li>
<li>没有终端的会话是脱离终端的，父进程死掉后会被pid=1的init/systemd收养</li>
</ul>
</li>
</ol>
<h6 id="15-4-2-一些命令"><a href="#15-4-2-一些命令" class="headerlink" title="15.4.2 一些命令"></a>15.4.2 一些命令</h6><ul>
<li><code>ps -o  pid,ppid,pgid,tpgid,sid,tty,comm</code>===  <code>ps j</code><ul>
<li>pid：  进程id、ppid：父进程ID</li>
<li>pgid：进程组ID、sid：会话ID</li>
<li>tpgid： 这个进程所属会话对应的终端的前台进程组ID</li>
</ul>
</li>
</ul>
<pre class=" language-bash"><code class="language-bash"><span class="token function">ps</span> j
<span class="token function">ps</span> j <span class="token operator">&amp;</span>
<span class="token function">ps</span> j <span class="token operator">&amp;</span> <span class="token operator">|</span> <span class="token function">cat</span>
<span class="token function">ps</span> j <span class="token operator">|</span> <span class="token function">cat</span> <span class="token operator">&amp;</span> </code></pre>
<h6 id="15-4-3-进程脱离终端的几种方法"><a href="#15-4-3-进程脱离终端的几种方法" class="headerlink" title="15.4.3 进程脱离终端的几种方法"></a>15.4.3 进程脱离终端的几种方法</h6><ol>
<li>脱离终端方法论：从当前shell中脱离，成为孤儿进程或孤儿进程组</li>
<li>nohup、screen、tmux</li>
<li>((cmd)&amp;) 、(cmd&amp;)</li>
<li>子shell中忽略SIGHUP信号：<code>trap  ‘’  SIGHUP</code></li>
<li>disown</li>
<li>setsid</li>
<li>daemon或daemonize  创建daemon类进程<ol>
<li>父进程pid = 1</li>
<li>没有（脱离）终端</li>
<li>自己成立session、 process group</li>
<li>关闭std{in/out/err}</li>
<li>chdir到/，防止文件系统卸载导致进程错误</li>
<li>清空umask，使得进程可以按权限需求创建文件</li>
</ol>
</li>
<li><strong>脱离终端注意事项：重定向需要关闭否？</strong></li>
</ol>
<h4 id="16-作业-job"><a href="#16-作业-job" class="headerlink" title="16 作业 job"></a>16 作业 job</h4><ol>
<li><p>没有脱离 shell 的进程组就是作业</p>
<ol>
<li>作业中可以有一个或多个进程</li>
<li>一个作业称之为一个pipeline</li>
<li>作业中的多个进程通过管道组合</li>
</ol>
</li>
<li><p>作业和shell的关系</p>
<ol>
<li>作业控制是shell的一个特性</li>
<li>一个shell可以执行多个作业，一个前台，多个后台</li>
<li>作业是属于shell的，当前shell下只能查看自己的作业信息</li>
</ol>
</li>
<li><p>作业状态</p>
<ol>
<li><p>running（包含两种进程状态的进程：）</p>
<ul>
<li>正在被调度执行的进程</li>
<li>正处于就绪队列的进程</li>
</ul>
</li>
<li><p>stopped：它并<strong>不</strong>代表进程真的完全停止不运行了</p>
</li>
<li><p>done</p>
</li>
<li><p>JOBID 标识每个作业：%jobid 查看进程</p>
</li>
<li><p><code>+符号</code>代表CPU当前正在执行的作业</p>
<p><code>-符号</code>代表操作系统下次调度的进程</p>
</li>
</ol>
</li>
<li><p>作业控制</p>
<ul>
<li>通过Ctrl + Z （ sigtstp 信号）、fg(CONT)前台运行、bg(CONT)后台运行</li>
<li>每个 shell 都维护属于自己的作业表</li>
<li>通过一张作业表记录当前的作业</li>
<li>disown可将作业（进程组）移出作业表，<strong>使之脱离终端</strong><ul>
<li>disown [-a|-r] [-h] [JOBID]</li>
<li>不加-h表示将任务从表中移出，加-h表示不移除，但设置忽略SIGHUP 信号</li>
<li>-a 表示对所有任务失效</li>
<li>-r 表示对当前running状态任务生效</li>
<li>如果既没有给-a、-r也没有jobid，那么操作的是+符号的作用</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="17-shell-的一些技巧或脚本规范"><a href="#17-shell-的一些技巧或脚本规范" class="headerlink" title="17 shell 的一些技巧或脚本规范"></a>17 shell 的一些技巧或脚本规范</h4><h5 id="17-1-文件锁"><a href="#17-1-文件锁" class="headerlink" title="17.1  文件锁"></a>17.1  文件锁</h5><p>劝告锁：要求双方或多方都同时使用同样的锁机制，否则文件锁就失去意义</p>
<ol>
<li>通过文件存在性判断</li>
</ol>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#!/usr/bin/bash</span>

<span class="token function">trap</span> <span class="token string">'echo "trapped";rm -rf <span class="token variable">${lock_file}</span>;exit'</span> EXIT
lock_file<span class="token operator">=</span>/var/lock/mylock
<span class="token keyword">while</span> <span class="token punctuation">[</span>-f <span class="token string">"<span class="token variable">${lock_file}</span>"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">do</span>
    <span class="token keyword">echo</span> <span class="token string">"locked..."</span>
    <span class="token function">sleep</span> 1
<span class="token keyword">done</span>
<span class="token function">touch</span> <span class="token variable">${lock_file}</span>
<span class="token comment" spellcheck="true">##  上面就是用文件存在性来判断文件锁；其他文件也需要这样判断</span>
<span class="token function">timeout</span> 5 <span class="token function">bash</span> -c <span class="token string">'while true;do
    echo "lock1.sh:`date +'</span>%T<span class="token string">'`" >> /tmp/a.log
    sleep 1
done'</span>


<span class="token comment" spellcheck="true">##  同理可以将上面的语句写成一个头文件（API）函数</span>
<span class="token comment" spellcheck="true">##  注意需要在引用它的文件中使用source加载进shell环境。</span>
<span class="token comment" spellcheck="true"># API 文件：</span>
<span class="token comment" spellcheck="true">#!/bin/bash</span>
<span class="token keyword">function</span> lockfile<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">trap</span> <span class="token string">'echo "trapped";rm -rf <span class="token variable">${lock_file}</span>;exit'</span> EXIT
    lock_file<span class="token operator">=</span><span class="token variable">$1</span>
    <span class="token keyword">while</span> <span class="token punctuation">[</span>-f <span class="token string">"<span class="token variable">${lock_file}</span>"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">do</span>
        <span class="token keyword">echo</span> <span class="token string">"locked..."</span>
        <span class="token function">sleep</span> 1
    <span class="token keyword">done</span>
    <span class="token function">touch</span> <span class="token variable">${lock_file}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">## lock333.sh</span>
<span class="token comment" spellcheck="true">#!/bin/bash</span>
<span class="token punctuation">[</span>-f <span class="token string">"lockfile.sh"</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token function">source</span> lockfile.sh <span class="token operator">||</span> <span class="token punctuation">{</span>echo <span class="token string">"lockfile.sh not exit"</span><span class="token punctuation">;</span><span class="token keyword">exit</span> 1<span class="token punctuation">;</span><span class="token punctuation">}</span>
lock_file<span class="token operator">=</span>/var/lock/mylock
lockfile <span class="token variable">${lock_file}</span>
<span class="token function">timeout</span> 5 <span class="token function">bash</span> -c <span class="token string">'while true;do
    echo "lock1.sh:`date +'</span>%T<span class="token string">'`" >> /tmp/a.log
    sleep 1
done'</span></code></pre>
<ol start="2">
<li>flock 文件锁 <code>lslocks</code>查看锁、<code>man flock</code>查看手册<ul>
<li>排他锁（独占锁、互斥锁、写锁，X）（仅有一个能申请排他锁）</li>
<li>共享锁（读锁，S）（可存在多个）（共享锁与排他锁不可共存）</li>
</ul>
</li>
</ol>
<pre class=" language-bash"><code class="language-bash">flock -s a.lock <span class="token keyword">echo</span> haha
flock -x a.lock <span class="token keyword">echo</span> haha
flock -w 5 -s a.lock -c <span class="token function">cat</span></code></pre>
<h5 id="17-2-设计脚本的选项：getopt"><a href="#17-2-设计脚本的选项：getopt" class="headerlink" title="17.2 设计脚本的选项：getopt"></a>17.2 设计脚本的选项：getopt</h5><p> <a href="https://www.cnblogs.com/f-ck-need-u/p/9757959.html" target="_blank" rel="noopener">https://www.cnblogs.com/f-ck-need-u/p/9757959.html</a> </p>
<p> <a href="https://www.cnblogs.com/f-ck-need-u/p/9758075.html#blog1" target="_blank" rel="noopener">https://www.cnblogs.com/f-ck-need-u/p/9758075.html#blog1</a> </p>
<ol>
<li><p>bash内置命令getopts</p>
</li>
<li><p>getopt设计的选项的共性</p>
<ul>
<li><p>短选项可以连在一起</p>
</li>
<li><p>参数可以给多个，而且放置的位置任意</p>
</li>
<li><p>选项型参数可以和选项连在一起，也可以空格分开</p>
</li>
</ul>
</li>
<li><p>getopt的功能：解析选项并将解析的结果分类整理</p>
</li>
<li><p>选项：短选项、长选项</p>
</li>
<li><p>参数</p>
<ul>
<li>选项型参数：必须跟在选项后（选项型参数可以和选项连在一起）</li>
<li>非选项型参数：可任意放置位置</li>
</ul>
</li>
<li><p>自己设计脚本–功能</p>
<ul>
<li>把sleep 当成守护进程去运行</li>
<li>可以去启动、可以去终止这个守护进程</li>
<li>指定sleep 睡眠时长的参数，也可以以配置文件的方式提供</li>
<li>指定pid文件</li>
<li>选项以及参数<ul>
<li>非选项型参数：睡眠时长</li>
<li><code>-c/--config</code>：睡眠时长</li>
<li><code>-s/--start</code>：启动模式</li>
<li><code>-k/--kill</code>：终止进程</li>
<li><code>-p/--pidfile</code>：指定守护进程的pid文件</li>
<li><code>-v/--version</code></li>
<li><code>-h/--help</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token comment" spellcheck="true">## 注意:1. [  ]  里面和两边都需要有空格分开</span>
<span class="token comment" spellcheck="true">##      2. 判断使用 == ，而不是=  </span>
VERSION<span class="token operator">=</span>1.0
<span class="token keyword">function</span> usage<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF
    usage: <span class="token variable">$0</span> [OPTIONS] [TIME] 
    options:
        -s,--start   start mode
        -k,--kill    kill mode 
        -c,--config  config
        -p,--pidfile pidfile
        -h,--help    print help info
        -v,--version print VERSION
EOF</span>
<span class="token punctuation">}</span>
args<span class="token operator">=</span>`getopt -n <span class="token string">"<span class="token variable">$0</span>"</span> -o skc:p:vh -l start,kill,config:,pidfile:,version,help -- <span class="token string">"<span class="token variable">$@</span>"</span> `

<span class="token keyword">echo</span> <span class="token string">"args:<span class="token variable">$args</span>"</span>

<span class="token comment" spellcheck="true">#通过 set -- args  将args变量当中的选项和参数设置成bash的位置变量</span>
<span class="token comment" spellcheck="true"># $1,$2</span>
<span class="token function">eval</span> <span class="token keyword">set</span> -- <span class="token string">"<span class="token variable">$args</span>"</span>

<span class="token keyword">while</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">do</span> 
    <span class="token keyword">case</span> <span class="token string">"<span class="token variable">$1</span>"</span> <span class="token keyword">in</span> 
        -s<span class="token operator">|</span>--start<span class="token punctuation">)</span>
            <span class="token punctuation">[</span> -n <span class="token string">"<span class="token variable">$mode</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">{</span> <span class="token keyword">echo</span> <span class="token string">"-s/-c/-k  can't use together"</span><span class="token punctuation">;</span><span class="token keyword">exit</span> 1<span class="token punctuation">;</span> <span class="token punctuation">}</span>
            mode<span class="token operator">=</span><span class="token string">"start"</span>
            <span class="token function">shift</span>
            <span class="token punctuation">;</span><span class="token punctuation">;</span>
        -k<span class="token operator">|</span>--kill<span class="token punctuation">)</span>
            <span class="token punctuation">[</span> -n <span class="token string">"<span class="token variable">$mode</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">{</span> <span class="token keyword">echo</span> <span class="token string">"-s/-c/-k  can't use together"</span><span class="token punctuation">;</span><span class="token keyword">exit</span> 1<span class="token punctuation">;</span> <span class="token punctuation">}</span>
            mode<span class="token operator">=</span><span class="token string">"kill"</span>
            <span class="token function">shift</span> <span class="token comment" spellcheck="true">## 把当前第一个位置参数给踢掉，那么第二个就变成了第一个</span>
            <span class="token punctuation">;</span><span class="token punctuation">;</span>
        -c<span class="token operator">|</span>--config<span class="token punctuation">)</span>
            config<span class="token operator">=</span><span class="token variable">$2</span>
            <span class="token function">shift</span> 2 <span class="token comment" spellcheck="true">## 有选项存在，所以shift 两次</span>
            <span class="token punctuation">;</span><span class="token punctuation">;</span>
        -p<span class="token operator">|</span>--pidfile<span class="token punctuation">)</span>
            pidfile<span class="token operator">=</span><span class="token variable">$2</span>
            <span class="token function">shift</span> 2
            <span class="token punctuation">;</span><span class="token punctuation">;</span>
        -h<span class="token operator">|</span>--help<span class="token punctuation">)</span>
            usage<span class="token punctuation">;</span><span class="token keyword">exit</span> 1
            <span class="token punctuation">;</span><span class="token punctuation">;</span>
        -v<span class="token operator">|</span>--version<span class="token punctuation">)</span>
            <span class="token keyword">echo</span> <span class="token variable">$VERSION</span>
            <span class="token keyword">exit</span> 1
            <span class="token punctuation">;</span><span class="token punctuation">;</span>
        --<span class="token punctuation">)</span>
            time<span class="token operator">=</span><span class="token variable">$2</span>
            <span class="token function">shift</span> 
            <span class="token keyword">break</span> 
            <span class="token punctuation">;</span><span class="token punctuation">;</span>
        *<span class="token punctuation">)</span>
            usage
            <span class="token keyword">exit</span> 1
    esac

<span class="token keyword">done</span>
<span class="token comment" spellcheck="true">## 必须要给模式，如果不给，就是用默认start</span>
<span class="token punctuation">[</span> -z <span class="token string">"<span class="token variable">$mode</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> mode<span class="token operator">=</span><span class="token string">"start"</span>

<span class="token comment" spellcheck="true">## 如果没有给定pidfile，就使用默认的pidfile=/tmp/mysleep.pid</span>
<span class="token punctuation">[</span> -z <span class="token string">"<span class="token variable">$pidfile</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> pidfile<span class="token operator">=</span>/tmp/mysleep.pid
<span class="token comment" spellcheck="true">#  在启动模式下，必须要给一个且只能给一个time</span>
<span class="token comment" spellcheck="true"># 在终止模式下，可以给可以不给</span>

<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$mode</span>"</span> <span class="token operator">==</span> <span class="token string">"start"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>
<span class="token comment" spellcheck="true"># start mode </span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> -n <span class="token string">"<span class="token variable">$config</span>"</span> -a -n <span class="token string">"<span class="token variable">$time</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>
        <span class="token keyword">echo</span> <span class="token string">"config and time can 't use together"</span>
        <span class="token keyword">exit</span> 1<span class="token punctuation">;</span>

    <span class="token keyword">elif</span> <span class="token punctuation">[</span> -n <span class="token string">"<span class="token variable">$config</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>
        <span class="token keyword">if</span> <span class="token punctuation">[</span> -r <span class="token string">"<span class="token variable">$config</span>"</span> <span class="token punctuation">]</span> <span class="token punctuation">;</span><span class="token keyword">then</span> 
            <span class="token function">read</span> line <span class="token operator">&lt;</span><span class="token string">"<span class="token variable">$config</span>"</span>
            <span class="token punctuation">[</span> -z <span class="token string">"<span class="token variable">$line</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">{</span> <span class="token keyword">echo</span> <span class="token string">"time invalid"</span><span class="token punctuation">;</span><span class="token keyword">exit</span> 1<span class="token punctuation">;</span> <span class="token punctuation">}</span>
            <span class="token punctuation">[</span> -n <span class="token string">"<span class="token variable">${line//[0-9]/}</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">{</span> <span class="token keyword">echo</span> <span class="token string">"time invalid"</span><span class="token punctuation">;</span><span class="token keyword">exit</span> 1<span class="token punctuation">;</span> <span class="token punctuation">}</span>
            <span class="token function">time</span> <span class="token operator">=</span> <span class="token variable">$line</span>
        <span class="token keyword">else</span>
            <span class="token keyword">echo</span> <span class="token string">"config unreadable"</span>
            <span class="token keyword">exit</span> 1<span class="token punctuation">;</span>
        <span class="token keyword">fi</span>
    <span class="token keyword">elif</span> <span class="token punctuation">[</span> -n <span class="token string">"<span class="token variable">$time</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>
        <span class="token punctuation">[</span> -n <span class="token string">"<span class="token variable">${line//[0-9]/}</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">{</span> <span class="token keyword">echo</span> <span class="token string">"time invalid"</span><span class="token punctuation">;</span><span class="token keyword">exit</span> 1<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">else</span> 
        <span class="token keyword">echo</span> <span class="token string">"must give me a time to sleep"</span>
        <span class="token keyword">exit</span> 1
    <span class="token keyword">fi</span>

<span class="token keyword">else</span>
    <span class="token comment" spellcheck="true"># kill mode</span>
    <span class="token keyword">:</span>
<span class="token keyword">fi</span>

<span class="token keyword">echo</span> <span class="token string">"mode : <span class="token variable">$mode</span>"</span>
<span class="token keyword">echo</span> <span class="token string">"pidfile : <span class="token variable">$pidfile</span>"</span>
<span class="token keyword">echo</span> <span class="token string">"time : <span class="token variable">$time</span>"</span>
<span class="token keyword">function</span> startmysleep<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    pidfile<span class="token operator">=</span><span class="token variable">$1</span>
    time<span class="token operator">=</span><span class="token variable">$2</span>

    <span class="token comment" spellcheck="true"># $!： 表示最近一个后台子进程的pid</span>
    <span class="token punctuation">(</span> <span class="token function">sleep</span> <span class="token variable">$time</span> <span class="token operator">&amp;</span> <span class="token keyword">echo</span> <span class="token variable">$!</span> <span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token string">"<span class="token variable">$pidfile</span>"</span>


<span class="token punctuation">}</span>

<span class="token keyword">function</span> killmysleep<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    pidfile<span class="token operator">=</span><span class="token variable">$1</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> -r <span class="token string">"<span class="token variable">${pidfile}</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span> 
        <span class="token keyword">while</span> <span class="token function">read</span> pid<span class="token punctuation">;</span><span class="token keyword">do</span> 
            <span class="token punctuation">[</span> -z <span class="token string">"<span class="token variable">$pid</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">{</span> <span class="token keyword">echo</span> <span class="token string">"pid invalid"</span><span class="token punctuation">;</span><span class="token keyword">exit</span> 1<span class="token punctuation">;</span> <span class="token punctuation">}</span>
            <span class="token punctuation">[</span> -n <span class="token string">"<span class="token variable">${pid//[0-9]/}</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">{</span> <span class="token keyword">echo</span> <span class="token string">"pid invalid"</span><span class="token punctuation">;</span><span class="token keyword">exit</span> 1<span class="token punctuation">;</span> <span class="token punctuation">}</span>
            <span class="token keyword">echo</span> <span class="token string">"this <span class="token variable">$pid</span> has been killed...."</span>
            <span class="token function">kill</span> <span class="token variable">$pid</span>

        <span class="token keyword">done</span> <span class="token operator">&lt;</span> <span class="token string">"<span class="token variable">${pidfile}</span>"</span>
        <span class="token function">rm</span> -rf <span class="token string">"<span class="token variable">$pidfile</span>"</span>
        <span class="token keyword">return</span> 0
    <span class="token keyword">fi</span>
    <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">${pidfile}</span> unreadable"</span>
    <span class="token keyword">return</span> 1

<span class="token punctuation">}</span>
<span class="token keyword">case</span> <span class="token string">"<span class="token variable">$mode</span>"</span> <span class="token keyword">in</span>
    start<span class="token punctuation">)</span>
        startmysleep <span class="token variable">$pidfile</span> <span class="token variable">$time</span>
        <span class="token punctuation">;</span><span class="token punctuation">;</span>
    kill<span class="token punctuation">)</span>
        killmysleep <span class="token variable">$pidfile</span> 
        <span class="token punctuation">;</span><span class="token punctuation">;</span>
    *<span class="token punctuation">)</span>
        usage
        <span class="token keyword">exit</span> 1
esac</code></pre>
<h5 id="17-3-tee命令的花式用法"><a href="#17-3-tee命令的花式用法" class="headerlink" title="17.3  tee命令的花式用法"></a>17.3  tee命令的花式用法</h5><ol>
<li><code>echo haha | tee file1 file2 file3</code></li>
<li><code>tee &gt;(cmd1) &gt;(cmd2) stdout</code><ul>
<li>数据可能会和bash的命令提示符混合在一起</li>
<li>解决方案：再把数据通过管道输出给cat （可避免后台进程执行不完就出现命令提示符的状况）  或  把进程替换的数据分别写入不同文件</li>
<li>多个命令的输出结果顺序无法保证</li>
</ul>
</li>
<li>tee 只能把数据传递给多个文件，不能传递给多个命令（除非使用进程替换：进程替换是数据传递给虚拟文件，然后从虚拟文件读取数据，不建议用进程替换，顺序会乱）</li>
</ol>
<p><code>echo  haha | tee &gt;(grep &quot;a&quot;) &gt;(sed &quot;s/haha/heihei/&quot;) &gt;/dev/null | cat</code></p>
<h5 id="17-4-pee命令"><a href="#17-4-pee命令" class="headerlink" title="17.4  pee命令"></a>17.4  pee命令</h5><ol>
<li>数据传递给多个命令，并且保证最后的输出顺序</li>
</ol>
<p><code>echo haha | pee &quot;grep &#39;a&#39;&quot; &quot;sed &#39;s/haha/heihei/&#39;&quot;</code></p>
<h5 id="17-5-shell脚本的规范："><a href="#17-5-shell脚本的规范：" class="headerlink" title="17.5 shell脚本的规范："></a>17.5 shell脚本的规范：</h5><p> <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-shell-styleguide/contents/" target="_blank" rel="noopener">https://zh-google-styleguide.readthedocs.io/en/latest/google-shell-styleguide/contents/</a> </p>
<h5 id="17-6-shell脚本编程书籍推荐："><a href="#17-6-shell脚本编程书籍推荐：" class="headerlink" title="17.6 shell脚本编程书籍推荐："></a>17.6 shell脚本编程书籍推荐：</h5><p>《shell脚本专家指南》</p>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://blog.aloogu.com" rel="external nofollow noreferrer">kylin</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://blog.aloogu.com/2020/05/23/bash-shell-kernel/">http://blog.aloogu.com/2020/05/23/bash-shell-kernel/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="http://blog.aloogu.com" target="_blank">kylin</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Linux/">
                                    <span class="chip bg-color">Linux</span>
                                </a>
                            
                                <a href="/tags/Bash-Shell/">
                                    <span class="chip bg-color">Bash-Shell</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2020/05/23/bash-shell-kernel/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/5.jpg" class="responsive-img" alt="Bash-Shell-Kernel">
                        
                        <span class="card-title">Bash-Shell-Kernel</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Bash-shell 的一些知识，帮助理解shell脚本
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-05-23
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Linux/" class="post-category">
                                    Linux
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Linux/">
                        <span class="chip bg-color">Linux</span>
                    </a>
                    
                    <a href="/tags/Bash-Shell/">
                        <span class="chip bg-color">Bash-Shell</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/03/30/rsa/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/8.jpg" class="responsive-img" alt="RSA">
                        
                        <span class="card-title">RSA</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            RSA---烧脑的东西--膜拜密码圈大佬
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-03-30
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/RSA/" class="post-category">
                                    RSA
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Web/">
                        <span class="chip bg-color">Web</span>
                    </a>
                    
                    <a href="/tags/RSA/">
                        <span class="chip bg-color">RSA</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('100')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: kylin小小鱼<br />'
            + '文章作者: kylin<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('3'),
            headingSelector: 'h2, h3, h4, h5, h6'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4, h5, h6').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2020</span>
            <a href="http://blog.aloogu.com" target="_blank">kylin</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">72.3k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2020";
                    var startMonth = "3";
                    var startDate = "26";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/lingying177" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1770824244@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1770824244" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1770824244" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    
    
    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    
	<script src="https://cdn.jsdelivr.net/gh/Yafine/cdn@3.1.4/source/js/click_show_text.js" type="module"></script>
    

</body>

</html>
